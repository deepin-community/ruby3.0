From: Lucas Kanashiro <lucas.kanashiro@canonical.com>
Date: Wed, 19 Jan 2022 17:33:30 -0300
Subject: Update rubygems to version 3.3.3

---
 lib/rubygems.rb                                    |  163 +-
 lib/rubygems/bundler_version_finder.rb             |   52 +-
 lib/rubygems/command.rb                            |    8 +-
 lib/rubygems/command_manager.rb                    |   12 +-
 lib/rubygems/commands/build_command.rb             |    6 +-
 lib/rubygems/commands/cert_command.rb              |   33 +-
 lib/rubygems/commands/check_command.rb             |    8 +-
 lib/rubygems/commands/cleanup_command.rb           |    6 +-
 lib/rubygems/commands/contents_command.rb          |    4 +-
 lib/rubygems/commands/dependency_command.rb        |    6 +-
 lib/rubygems/commands/environment_command.rb       |    2 +-
 lib/rubygems/commands/fetch_command.rb             |    8 +-
 lib/rubygems/commands/generate_index_command.rb    |    4 +-
 lib/rubygems/commands/help_command.rb              |    2 +-
 lib/rubygems/commands/info_command.rb              |    4 +-
 lib/rubygems/commands/install_command.rb           |   30 +-
 lib/rubygems/commands/list_command.rb              |    4 +-
 lib/rubygems/commands/lock_command.rb              |    2 +-
 lib/rubygems/commands/mirror_command.rb            |    2 +-
 lib/rubygems/commands/open_command.rb              |    4 +-
 lib/rubygems/commands/outdated_command.rb          |    8 +-
 lib/rubygems/commands/owner_command.rb             |    8 +-
 lib/rubygems/commands/pristine_command.rb          |   20 +-
 lib/rubygems/commands/push_command.rb              |    8 +-
 lib/rubygems/commands/query_command.rb             |    6 +-
 lib/rubygems/commands/rdoc_command.rb              |    6 +-
 lib/rubygems/commands/search_command.rb            |    4 +-
 lib/rubygems/commands/server_command.rb            |   95 +-
 lib/rubygems/commands/setup_command.rb             |  172 +-
 lib/rubygems/commands/signin_command.rb            |    4 +-
 lib/rubygems/commands/signout_command.rb           |    2 +-
 lib/rubygems/commands/sources_command.rb           |    8 +-
 lib/rubygems/commands/specification_command.rb     |    8 +-
 lib/rubygems/commands/stale_command.rb             |    2 +-
 lib/rubygems/commands/uninstall_command.rb         |    8 +-
 lib/rubygems/commands/unpack_command.rb            |   10 +-
 lib/rubygems/commands/update_command.rb            |   33 +-
 lib/rubygems/commands/which_command.rb             |    2 +-
 lib/rubygems/commands/yank_command.rb              |    8 +-
 lib/rubygems/config_file.rb                        |   10 +-
 lib/rubygems/core_ext/tcpsocket_init.rb            |    4 +-
 lib/rubygems/defaults.rb                           |   24 +-
 lib/rubygems/dependency.rb                         |   14 +-
 lib/rubygems/dependency_installer.rb               |   16 +-
 lib/rubygems/dependency_list.rb                    |    6 +-
 lib/rubygems/deprecate.rb                          |   59 +-
 lib/rubygems/doctor.rb                             |    4 +-
 lib/rubygems/errors.rb                             |    6 +-
 lib/rubygems/exceptions.rb                         |   34 +-
 lib/rubygems/ext/builder.rb                        |   20 +-
 lib/rubygems/ext/cmake_builder.rb                  |    2 +-
 lib/rubygems/ext/ext_conf_builder.rb               |    3 +-
 lib/rubygems/ext/rake_builder.rb                   |    3 +-
 lib/rubygems/gem_runner.rb                         |    6 +-
 lib/rubygems/gemcutter_utilities.rb                |    7 +-
 lib/rubygems/indexer.rb                            |    4 +-
 lib/rubygems/install_default_message.rb            |    4 +-
 lib/rubygems/install_message.rb                    |    4 +-
 lib/rubygems/install_update_options.rb             |   21 +-
 lib/rubygems/installer.rb                          |   96 +-
 lib/rubygems/installer_test_case.rb                |  247 ---
 lib/rubygems/local_remote_options.rb               |    8 +-
 lib/rubygems/mock_gem_ui.rb                        |    2 +-
 lib/rubygems/name_tuple.rb                         |    5 +-
 lib/rubygems/optparse.rb                           |    3 +
 lib/rubygems/optparse/.document                    |    1 +
 lib/rubygems/optparse/lib/optionparser.rb          |    2 +
 lib/rubygems/optparse/lib/optparse.rb              | 2230 ++++++++++++++++++++
 lib/rubygems/optparse/lib/optparse/ac.rb           |   54 +
 lib/rubygems/optparse/lib/optparse/date.rb         |   18 +
 lib/rubygems/optparse/lib/optparse/kwargs.rb       |   22 +
 lib/rubygems/optparse/lib/optparse/shellwords.rb   |    7 +
 lib/rubygems/optparse/lib/optparse/time.rb         |   11 +
 lib/rubygems/optparse/lib/optparse/uri.rb          |    7 +
 lib/rubygems/optparse/lib/optparse/version.rb      |   71 +
 lib/rubygems/package.rb                            |   82 +-
 lib/rubygems/package/io_source.rb                  |    4 +
 lib/rubygems/package/tar_reader.rb                 |    2 +-
 lib/rubygems/package/tar_test_case.rb              |  139 --
 lib/rubygems/package_task.rb                       |    4 +-
 lib/rubygems/path_support.rb                       |    7 +-
 lib/rubygems/platform.rb                           |    7 +-
 lib/rubygems/query_utils.rb                        |    8 +-
 lib/rubygems/rdoc.rb                               |    2 +-
 lib/rubygems/remote_fetcher.rb                     |   41 +-
 lib/rubygems/request.rb                            |   12 +-
 lib/rubygems/request/connection_pools.rb           |    2 +-
 lib/rubygems/request/http_pool.rb                  |    2 +-
 lib/rubygems/request_set.rb                        |   14 +-
 lib/rubygems/request_set/lockfile.rb               |    2 +-
 lib/rubygems/request_set/lockfile/tokenizer.rb     |    2 +-
 lib/rubygems/requirement.rb                        |   25 +-
 lib/rubygems/resolver.rb                           |   62 +-
 lib/rubygems/resolver/git_specification.rb         |    2 +-
 lib/rubygems/resolver/installer_set.rb             |    8 +-
 lib/rubygems/resolver/molinillo.rb                 |    2 +-
 .../molinillo/lib/molinillo/dependency_graph.rb    |    4 +-
 lib/rubygems/resolver/set.rb                       |    1 -
 lib/rubygems/resolver/specification.rb             |    2 +-
 lib/rubygems/s3_uri_signer.rb                      |   10 +-
 lib/rubygems/safe_yaml.rb                          |    2 -
 lib/rubygems/security.rb                           |   87 +-
 lib/rubygems/security/policy.rb                    |    8 +-
 lib/rubygems/security/signer.rb                    |    9 +-
 lib/rubygems/security_option.rb                    |   10 +-
 lib/rubygems/server.rb                             |  882 --------
 lib/rubygems/source.rb                             |   18 +-
 lib/rubygems/source/git.rb                         |    4 +-
 lib/rubygems/spec_fetcher.rb                       |   12 +-
 lib/rubygems/specification.rb                      |  128 +-
 lib/rubygems/specification_policy.rb               |    4 +-
 lib/rubygems/stub_specification.rb                 |    2 +-
 lib/rubygems/syck_hack.rb                          |   77 -
 lib/rubygems/test_case.rb                          | 1610 --------------
 lib/rubygems/test_utilities.rb                     |  373 ----
 lib/rubygems/text.rb                               |   41 +-
 lib/rubygems/tsort.rb                              |    3 +
 lib/rubygems/tsort/.document                       |    1 +
 lib/rubygems/tsort/lib/tsort.rb                    |  454 ++++
 lib/rubygems/uninstaller.rb                        |   58 +-
 lib/rubygems/unknown_command_spell_checker.rb      |   21 +
 lib/rubygems/uri.rb                                |  111 +
 lib/rubygems/uri_parser.rb                         |   34 -
 lib/rubygems/uri_parsing.rb                        |   23 -
 lib/rubygems/user_interaction.rb                   |    6 +-
 lib/rubygems/util.rb                               |    2 +-
 lib/rubygems/util/licenses.rb                      |    4 +-
 lib/rubygems/validator.rb                          |    4 +-
 lib/rubygems/version.rb                            |    2 +
 lib/rubygems/version_option.rb                     |    6 +-
 130 files changed, 3968 insertions(+), 4281 deletions(-)
 delete mode 100644 lib/rubygems/installer_test_case.rb
 create mode 100644 lib/rubygems/optparse.rb
 create mode 100644 lib/rubygems/optparse/.document
 create mode 100644 lib/rubygems/optparse/lib/optionparser.rb
 create mode 100644 lib/rubygems/optparse/lib/optparse.rb
 create mode 100644 lib/rubygems/optparse/lib/optparse/ac.rb
 create mode 100644 lib/rubygems/optparse/lib/optparse/date.rb
 create mode 100644 lib/rubygems/optparse/lib/optparse/kwargs.rb
 create mode 100644 lib/rubygems/optparse/lib/optparse/shellwords.rb
 create mode 100644 lib/rubygems/optparse/lib/optparse/time.rb
 create mode 100644 lib/rubygems/optparse/lib/optparse/uri.rb
 create mode 100644 lib/rubygems/optparse/lib/optparse/version.rb
 delete mode 100644 lib/rubygems/package/tar_test_case.rb
 delete mode 100644 lib/rubygems/server.rb
 delete mode 100644 lib/rubygems/syck_hack.rb
 delete mode 100644 lib/rubygems/test_case.rb
 delete mode 100644 lib/rubygems/test_utilities.rb
 create mode 100644 lib/rubygems/tsort.rb
 create mode 100644 lib/rubygems/tsort/.document
 create mode 100644 lib/rubygems/tsort/lib/tsort.rb
 create mode 100644 lib/rubygems/unknown_command_spell_checker.rb
 create mode 100644 lib/rubygems/uri.rb
 delete mode 100644 lib/rubygems/uri_parser.rb
 delete mode 100644 lib/rubygems/uri_parsing.rb

diff --git a/lib/rubygems.rb b/lib/rubygems.rb
index cb03a9e..e24580c 100644
--- a/lib/rubygems.rb
+++ b/lib/rubygems.rb
@@ -8,15 +8,15 @@
 require 'rbconfig'
 
 module Gem
-  VERSION = "3.2.22".freeze
+  VERSION = "3.3.3".freeze
 end
 
 # Must be first since it unloads the prelude from 1.9.2
-require 'rubygems/compatibility'
+require_relative 'rubygems/compatibility'
 
-require 'rubygems/defaults'
-require 'rubygems/deprecate'
-require 'rubygems/errors'
+require_relative 'rubygems/defaults'
+require_relative 'rubygems/deprecate'
+require_relative 'rubygems/errors'
 
 ##
 # RubyGems is the Ruby standard for publishing and managing third party
@@ -163,22 +163,12 @@ module Gem
     specifications/default
   ].freeze
 
-  ##
-  # Exception classes used in a Gem.read_binary +rescue+ statement
-
-  READ_BINARY_ERRORS = [Errno::EACCES, Errno::EROFS, Errno::ENOSYS, Errno::ENOTSUP].freeze
-
-  ##
-  # Exception classes used in Gem.write_binary +rescue+ statement
-
-  WRITE_BINARY_ERRORS = [Errno::ENOSYS, Errno::ENOTSUP].freeze
-
   @@win_platform = nil
 
   @configuration = nil
   @gemdeps = nil
   @loaded_specs = {}
-  LOADED_SPECS_MUTEX = Mutex.new
+  LOADED_SPECS_MUTEX = Thread::Mutex.new
   @path_to_default_spec_map = {}
   @platforms = []
   @ruby = nil
@@ -249,9 +239,6 @@ module Gem
   # you to specify specific gem versions.
 
   def self.bin_path(name, exec_name = nil, *requirements)
-    # TODO: fails test_self_bin_path_bin_file_gone_in_latest
-    # Gem::Specification.find_by_name(name, *requirements).bin_file exec_name
-
     requirements = Gem::Requirement.default if
       requirements.empty?
 
@@ -275,9 +262,6 @@ module Gem
 
     unless spec = specs.first
       msg = "can't find gem #{dep} with executable #{exec_name}"
-      if dep.filters_bundler? && bundler_message = Gem::BundlerVersionFinder.missing_version_message
-        msg = bundler_message
-      end
       raise Gem::GemNotFoundException, msg
     end
 
@@ -562,7 +546,7 @@ An Array (#{env.inspect}) was passed in from #{caller[3]}
   #   => [#<Gem::Specification:0x1013b4528 @name="minitest", ...>]
 
   def self.install(name, version = Gem::Requirement.default, *options)
-    require "rubygems/dependency_installer"
+    require_relative "rubygems/dependency_installer"
     inst = Gem::DependencyInstaller.new(*options)
     inst.install name, version
     inst.installed_gems
@@ -628,22 +612,12 @@ An Array (#{env.inspect}) was passed in from #{caller[3]}
     rescue ::LoadError
       # If we can't load psych, that's fine, go on.
     else
-      # If 'yaml' has already been required, then we have to
-      # be sure to switch it over to the newly loaded psych.
-      if defined?(YAML::ENGINE) && YAML::ENGINE.yamler != "psych"
-        YAML::ENGINE.yamler = "psych"
-      end
-
-      require 'rubygems/psych_additions'
-      require 'rubygems/psych_tree'
+      require_relative 'rubygems/psych_additions'
+      require_relative 'rubygems/psych_tree'
     end
 
     require 'yaml'
-    require 'rubygems/safe_yaml'
-
-    # Now that we're sure some kind of yaml library is loaded, pull
-    # in our hack to deal with Syck's DefaultKey ugliness.
-    require 'rubygems/syck_hack'
+    require_relative 'rubygems/safe_yaml'
 
     @yaml_loaded = true
   end
@@ -792,40 +766,42 @@ An Array (#{env.inspect}) was passed in from #{caller[3]}
   # Safely read a file in binary mode on all platforms.
 
   def self.read_binary(path)
-    File.open path, 'rb+' do |f|
-      f.flock(File::LOCK_EX)
-      f.read
+    open_with_flock(path, 'rb+') do |io|
+      io.read
     end
-  rescue *READ_BINARY_ERRORS
-    File.open path, 'rb' do |f|
-      f.read
-    end
-  rescue Errno::ENOLCK # NFS
-    if Thread.main != Thread.current
-      raise
-    else
-      File.open path, 'rb' do |f|
-        f.read
-      end
+  rescue Errno::EACCES, Errno::EROFS
+    open_with_flock(path, 'rb') do |io|
+      io.read
     end
   end
 
   ##
   # Safely write a file in binary mode on all platforms.
   def self.write_binary(path, data)
-    File.open(path, 'wb') do |io|
-      begin
-        io.flock(File::LOCK_EX)
-      rescue *WRITE_BINARY_ERRORS
-      end
+    open_with_flock(path, 'wb') do |io|
       io.write data
     end
+  end
+
+  ##
+  # Open a file with given flags, and protect access with flock
+
+  def self.open_with_flock(path, flags, &block)
+    File.open(path, flags) do |io|
+      if !java_platform? && !solaris_platform?
+        begin
+          io.flock(File::LOCK_EX)
+        rescue Errno::ENOSYS, Errno::ENOTSUP
+        end
+      end
+      yield io
+    end
   rescue Errno::ENOLCK # NFS
     if Thread.main != Thread.current
       raise
     else
-      File.open(path, 'wb') do |io|
-        io.write data
+      File.open(path, flags) do |io|
+        yield io
       end
     end
   end
@@ -867,7 +843,7 @@ An Array (#{env.inspect}) was passed in from #{caller[3]}
     fetcher      = Gem::SpecFetcher.fetcher
     spec_tuples, = fetcher.spec_for_dependency dependency
 
-    spec, = spec_tuples.first
+    spec, = spec_tuples.last
 
     spec
   end
@@ -1003,7 +979,7 @@ An Array (#{env.inspect}) was passed in from #{caller[3]}
   # Lazily loads DefaultUserInteraction and returns the default UI.
 
   def self.ui
-    require 'rubygems/user_interaction'
+    require_relative 'rubygems/user_interaction'
 
     Gem::DefaultUserInteraction.ui
   end
@@ -1039,6 +1015,13 @@ An Array (#{env.inspect}) was passed in from #{caller[3]}
     RUBY_PLATFORM == "java"
   end
 
+  ##
+  # Is this platform Solaris?
+
+  def self.solaris_platform?
+    RUBY_PLATFORM =~ /solaris/
+  end
+
   ##
   # Load +plugins+ as Ruby files
 
@@ -1063,7 +1046,9 @@ An Array (#{env.inspect}) was passed in from #{caller[3]}
   # Find rubygems plugin files in the standard location and load them
 
   def self.load_plugins
-    load_plugin_files Gem::Util.glob_files_in_dir("*#{Gem.plugin_suffix_pattern}", plugindir)
+    Gem.path.each do |gem_path|
+      load_plugin_files Gem::Util.glob_files_in_dir("*#{Gem.plugin_suffix_pattern}", plugindir(gem_path))
+    end
   end
 
   ##
@@ -1121,27 +1106,22 @@ An Array (#{env.inspect}) was passed in from #{caller[3]}
     end
 
     ENV["BUNDLE_GEMFILE"] ||= File.expand_path(path)
-    require 'rubygems/user_interaction'
-    Gem::DefaultUserInteraction.use_ui(ui) do
-      require "bundler"
-      begin
-        Bundler.ui.silence do
-          @gemdeps = Bundler.setup
+    require_relative 'rubygems/user_interaction'
+    require "bundler"
+    begin
+      Gem::DefaultUserInteraction.use_ui(ui) do
+        begin
+          Bundler.ui.silence do
+            @gemdeps = Bundler.setup
+          end
+        ensure
+          Gem::DefaultUserInteraction.ui.close
         end
-      ensure
-        Gem::DefaultUserInteraction.ui.close
       end
-      @gemdeps.requested_specs.map(&:to_spec).sort_by(&:name)
-    end
-
-  rescue => e
-    case e
-    when Gem::LoadError, Gem::UnsatisfiableDependencyError, (defined?(Bundler::GemNotFound) ? Bundler::GemNotFound : Gem::LoadError)
+    rescue Bundler::BundlerError => e
       warn e.message
-      warn "You may need to `gem install -g` to install missing gems"
+      warn "You may need to `bundle install` to install missing gems"
       warn ""
-    else
-      raise
     end
   end
 
@@ -1309,7 +1289,12 @@ An Array (#{env.inspect}) was passed in from #{caller[3]}
     end
 
     def default_gem_load_paths
-      @default_gem_load_paths ||= $LOAD_PATH[load_path_insert_index..-1]
+      @default_gem_load_paths ||= $LOAD_PATH[load_path_insert_index..-1].map do |lp|
+        expanded = File.expand_path(lp)
+        next expanded unless File.exist?(expanded)
+
+        File.realpath(expanded)
+      end
     end
   end
 
@@ -1326,19 +1311,17 @@ An Array (#{env.inspect}) was passed in from #{caller[3]}
   autoload :Licenses,           File.expand_path('rubygems/util/licenses', __dir__)
   autoload :NameTuple,          File.expand_path('rubygems/name_tuple', __dir__)
   autoload :PathSupport,        File.expand_path('rubygems/path_support', __dir__)
-  autoload :Platform,           File.expand_path('rubygems/platform', __dir__)
   autoload :RequestSet,         File.expand_path('rubygems/request_set', __dir__)
-  autoload :Requirement,        File.expand_path('rubygems/requirement', __dir__)
   autoload :Resolver,           File.expand_path('rubygems/resolver', __dir__)
   autoload :Source,             File.expand_path('rubygems/source', __dir__)
   autoload :SourceList,         File.expand_path('rubygems/source_list', __dir__)
   autoload :SpecFetcher,        File.expand_path('rubygems/spec_fetcher', __dir__)
-  autoload :Specification,      File.expand_path('rubygems/specification', __dir__)
   autoload :Util,               File.expand_path('rubygems/util', __dir__)
   autoload :Version,            File.expand_path('rubygems/version', __dir__)
 end
 
-require 'rubygems/exceptions'
+require_relative 'rubygems/exceptions'
+require_relative 'rubygems/specification'
 
 # REFACTOR: This should be pulled out into some kind of hacks file.
 begin
@@ -1347,6 +1330,14 @@ begin
 
   require 'rubygems/defaults/operating_system'
 rescue LoadError
+  # Ignored
+rescue StandardError => e
+  msg = "#{e.message}\n" \
+    "Loading the rubygems/defaults/operating_system.rb file caused an error. " \
+    "This file is owned by your OS, not by rubygems upstream. " \
+    "Please find out which OS package this file belongs to and follow the guidelines from your OS to report " \
+    "the problem and ask for help."
+  raise e.class, msg
 end
 
 begin
@@ -1361,8 +1352,6 @@ end
 # Loads the default specs.
 Gem::Specification.load_defaults
 
-require 'rubygems/core_ext/kernel_gem'
-require 'rubygems/core_ext/kernel_require'
-require 'rubygems/core_ext/kernel_warn'
-
-Gem.use_gemdeps
+require_relative 'rubygems/core_ext/kernel_gem'
+require_relative 'rubygems/core_ext/kernel_require'
+require_relative 'rubygems/core_ext/kernel_warn'
diff --git a/lib/rubygems/bundler_version_finder.rb b/lib/rubygems/bundler_version_finder.rb
index 9ce0a23..14179ae 100644
--- a/lib/rubygems/bundler_version_finder.rb
+++ b/lib/rubygems/bundler_version_finder.rb
@@ -2,48 +2,18 @@
 
 module Gem::BundlerVersionFinder
   def self.bundler_version
-    version, _ = bundler_version_with_reason
+    v = ENV["BUNDLER_VERSION"]
 
-    return unless version
+    v ||= bundle_update_bundler_version
+    return if v == true
 
-    Gem::Version.new(version)
-  end
-
-  def self.bundler_version_with_reason
-    if v = ENV["BUNDLER_VERSION"]
-      return [v, "`$BUNDLER_VERSION`"]
-    end
-    if v = bundle_update_bundler_version
-      return if v == true
-      return [v, "`bundle update --bundler`"]
-    end
-    v, lockfile = lockfile_version
-    if v
-      return [v, "your #{lockfile}"]
-    end
-  end
+    v ||= lockfile_version
+    return unless v
 
-  def self.missing_version_message
-    return unless vr = bundler_version_with_reason
-    <<-EOS
-Could not find 'bundler' (#{vr.first}) required by #{vr.last}.
-To update to the latest version installed on your system, run `bundle update --bundler`.
-To install the missing version, run `gem install bundler:#{vr.first}`
-    EOS
+    Gem::Version.new(v)
   end
 
-  def self.compatible?(spec)
-    return true unless spec.name == "bundler".freeze
-    return true unless bundler_version = self.bundler_version
-
-    spec.version.segments.first == bundler_version.segments.first
-  end
-
-  def self.filter!(specs)
-    return unless bundler_version = self.bundler_version
-
-    specs.reject! {|spec| spec.version.segments.first != bundler_version.segments.first }
-
+  def self.prioritize!(specs)
     exact_match_index = specs.find_index {|spec| spec.version == bundler_version }
     return unless exact_match_index
 
@@ -68,12 +38,10 @@ To install the missing version, run `gem install bundler:#{vr.first}`
   private_class_method :bundle_update_bundler_version
 
   def self.lockfile_version
-    return unless lockfile = lockfile_contents
-    lockfile, contents = lockfile
-    lockfile ||= "lockfile"
+    return unless contents = lockfile_contents
     regexp = /\n\nBUNDLED WITH\n\s{2,}(#{Gem::Version::VERSION_PATTERN})\n/
     return unless contents =~ regexp
-    [$1, lockfile]
+    $1
   end
   private_class_method :lockfile_version
 
@@ -103,7 +71,7 @@ To install the missing version, run `gem install bundler:#{vr.first}`
 
     return unless File.file?(lockfile)
 
-    [lockfile, File.read(lockfile)]
+    File.read(lockfile)
   end
   private_class_method :lockfile_contents
 end
diff --git a/lib/rubygems/command.rb b/lib/rubygems/command.rb
index 303f54a..abdaa8e 100644
--- a/lib/rubygems/command.rb
+++ b/lib/rubygems/command.rb
@@ -5,7 +5,7 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'optparse'
+require_relative 'optparse'
 require_relative 'requirement'
 require_relative 'user_interaction'
 
@@ -19,7 +19,7 @@ require_relative 'user_interaction'
 class Gem::Command
   include Gem::UserInteraction
 
-  OptionParser.accept Symbol do |value|
+  Gem::OptionParser.accept Symbol do |value|
     value.to_sym
   end
 
@@ -344,7 +344,7 @@ class Gem::Command
   ##
   # Add a command-line option and handler to the command.
   #
-  # See OptionParser#make_switch for an explanation of +opts+.
+  # See Gem::OptionParser#make_switch for an explanation of +opts+.
   #
   # +handler+ will be called with two values, the value of the argument and
   # the options hash.
@@ -540,7 +540,7 @@ class Gem::Command
   # command.
 
   def create_option_parser
-    @parser = OptionParser.new
+    @parser = Gem::OptionParser.new
 
     add_parser_options
 
diff --git a/lib/rubygems/command_manager.rb b/lib/rubygems/command_manager.rb
index 97e5254..03cdd6a 100644
--- a/lib/rubygems/command_manager.rb
+++ b/lib/rubygems/command_manager.rb
@@ -5,9 +5,9 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/command'
-require 'rubygems/user_interaction'
-require 'rubygems/text'
+require_relative 'command'
+require_relative 'user_interaction'
+require_relative 'text'
 
 ##
 # The command manager registers and installs all the individual sub-commands
@@ -73,7 +73,9 @@ class Gem::CommandManager
   ].freeze
 
   ALIAS_COMMANDS = {
-    'i' => 'install',
+    'i'      => 'install',
+    'login'  => 'signin',
+    'logout' => 'signout',
   }.freeze
 
   ##
@@ -188,7 +190,7 @@ class Gem::CommandManager
       raise Gem::CommandLineError,
             "Ambiguous command #{cmd_name} matches [#{possibilities.join(', ')}]"
     elsif possibilities.empty?
-      raise Gem::CommandLineError, "Unknown command #{cmd_name}"
+      raise Gem::UnknownCommandError.new(cmd_name)
     end
 
     self[possibilities.first]
diff --git a/lib/rubygems/commands/build_command.rb b/lib/rubygems/commands/build_command.rb
index 842ec18..6d1a057 100644
--- a/lib/rubygems/commands/build_command.rb
+++ b/lib/rubygems/commands/build_command.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/package'
-require 'rubygems/version_option'
+require_relative '../command'
+require_relative '../package'
+require_relative '../version_option'
 
 class Gem::Commands::BuildCommand < Gem::Command
   include Gem::VersionOption
diff --git a/lib/rubygems/commands/cert_command.rb b/lib/rubygems/commands/cert_command.rb
index 3fc0dae..b59564d 100644
--- a/lib/rubygems/commands/cert_command.rb
+++ b/lib/rubygems/commands/cert_command.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/security'
+require_relative '../command'
+require_relative '../security'
 
 class Gem::Commands::CertCommand < Gem::Command
   def initialize
@@ -43,10 +43,15 @@ class Gem::Commands::CertCommand < Gem::Command
       options[:key] = open_private_key(key_file)
     end
 
+    add_option('-A', '--key-algorithm ALGORITHM',
+               'Select which key algorithm to use for --build') do |algorithm, options|
+      options[:key_algorithm] = algorithm
+    end
+
     add_option('-s', '--sign CERT',
                'Signs CERT with the key from -K',
                'and the certificate from -C') do |cert_file, options|
-      raise OptionParser::InvalidArgument, "#{cert_file}: does not exist" unless
+      raise Gem::OptionParser::InvalidArgument, "#{cert_file}: does not exist" unless
         File.file? cert_file
 
       options[:sign] << cert_file
@@ -80,23 +85,23 @@ class Gem::Commands::CertCommand < Gem::Command
     check_openssl
     OpenSSL::X509::Certificate.new File.read certificate_file
   rescue Errno::ENOENT
-    raise OptionParser::InvalidArgument, "#{certificate_file}: does not exist"
+    raise Gem::OptionParser::InvalidArgument, "#{certificate_file}: does not exist"
   rescue OpenSSL::X509::CertificateError
-    raise OptionParser::InvalidArgument,
+    raise Gem::OptionParser::InvalidArgument,
       "#{certificate_file}: invalid X509 certificate"
   end
 
   def open_private_key(key_file)
     check_openssl
     passphrase = ENV['GEM_PRIVATE_KEY_PASSPHRASE']
-    key = OpenSSL::PKey::RSA.new File.read(key_file), passphrase
-    raise OptionParser::InvalidArgument,
+    key = OpenSSL::PKey.read File.read(key_file), passphrase
+    raise Gem::OptionParser::InvalidArgument,
       "#{key_file}: private key not found" unless key.private?
     key
   rescue Errno::ENOENT
-    raise OptionParser::InvalidArgument, "#{key_file}: does not exist"
-  rescue OpenSSL::PKey::RSAError
-    raise OptionParser::InvalidArgument, "#{key_file}: invalid RSA key"
+    raise Gem::OptionParser::InvalidArgument, "#{key_file}: does not exist"
+  rescue OpenSSL::PKey::PKeyError, ArgumentError
+    raise Gem::OptionParser::InvalidArgument, "#{key_file}: invalid RSA, DSA, or EC key"
   end
 
   def execute
@@ -170,7 +175,8 @@ class Gem::Commands::CertCommand < Gem::Command
     raise Gem::CommandLineError,
           "Passphrase and passphrase confirmation don't match" unless passphrase == passphrase_confirmation
 
-    key      = Gem::Security.create_key
+    algorithm = options[:key_algorithm] || Gem::Security::DEFAULT_KEY_ALGORITHM
+    key = Gem::Security.create_key(algorithm)
     key_path = Gem::Security.write key, "gem-private_key.pem", 0600, passphrase
 
     return key, key_path
@@ -255,13 +261,14 @@ For further reading on signing gems see `ri Gem::Security`.
     key_file = File.join Gem.default_key_path
     key = File.read key_file
     passphrase = ENV['GEM_PRIVATE_KEY_PASSPHRASE']
-    options[:key] = OpenSSL::PKey::RSA.new key, passphrase
+    options[:key] = OpenSSL::PKey.read key, passphrase
+
   rescue Errno::ENOENT
     alert_error \
       "--private-key not specified and ~/.gem/gem-private_key.pem does not exist"
 
     terminate_interaction 1
-  rescue OpenSSL::PKey::RSAError
+  rescue OpenSSL::PKey::PKeyError
     alert_error \
       "--private-key not specified and ~/.gem/gem-private_key.pem is not valid"
 
diff --git a/lib/rubygems/commands/check_command.rb b/lib/rubygems/commands/check_command.rb
index 8b8eda5..3b6b97a 100644
--- a/lib/rubygems/commands/check_command.rb
+++ b/lib/rubygems/commands/check_command.rb
@@ -1,8 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/version_option'
-require 'rubygems/validator'
-require 'rubygems/doctor'
+require_relative '../command'
+require_relative '../version_option'
+require_relative '../validator'
+require_relative '../doctor'
 
 class Gem::Commands::CheckCommand < Gem::Command
   include Gem::VersionOption
diff --git a/lib/rubygems/commands/cleanup_command.rb b/lib/rubygems/commands/cleanup_command.rb
index 662badc..c965085 100644
--- a/lib/rubygems/commands/cleanup_command.rb
+++ b/lib/rubygems/commands/cleanup_command.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/dependency_list'
-require 'rubygems/uninstaller'
+require_relative '../command'
+require_relative '../dependency_list'
+require_relative '../uninstaller'
 
 class Gem::Commands::CleanupCommand < Gem::Command
   def initialize
diff --git a/lib/rubygems/commands/contents_command.rb b/lib/rubygems/commands/contents_command.rb
index f17aed6..716022c 100644
--- a/lib/rubygems/commands/contents_command.rb
+++ b/lib/rubygems/commands/contents_command.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/version_option'
+require_relative '../command'
+require_relative '../version_option'
 
 class Gem::Commands::ContentsCommand < Gem::Command
   include Gem::VersionOption
diff --git a/lib/rubygems/commands/dependency_command.rb b/lib/rubygems/commands/dependency_command.rb
index e472d8f..7d21707 100644
--- a/lib/rubygems/commands/dependency_command.rb
+++ b/lib/rubygems/commands/dependency_command.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/local_remote_options'
-require 'rubygems/version_option'
+require_relative '../command'
+require_relative '../local_remote_options'
+require_relative '../version_option'
 
 class Gem::Commands::DependencyCommand < Gem::Command
   include Gem::LocalRemoteOptions
diff --git a/lib/rubygems/commands/environment_command.rb b/lib/rubygems/commands/environment_command.rb
index 37429fb..b6eeb62 100644
--- a/lib/rubygems/commands/environment_command.rb
+++ b/lib/rubygems/commands/environment_command.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require 'rubygems/command'
+require_relative '../command'
 
 class Gem::Commands::EnvironmentCommand < Gem::Command
   def initialize
diff --git a/lib/rubygems/commands/fetch_command.rb b/lib/rubygems/commands/fetch_command.rb
index 6a1b346..3738516 100644
--- a/lib/rubygems/commands/fetch_command.rb
+++ b/lib/rubygems/commands/fetch_command.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/local_remote_options'
-require 'rubygems/version_option'
+require_relative '../command'
+require_relative '../local_remote_options'
+require_relative '../version_option'
 
 class Gem::Commands::FetchCommand < Gem::Command
   include Gem::LocalRemoteOptions
@@ -60,7 +60,7 @@ then repackaging it.
         specs_and_sources = filtered unless filtered.empty?
       end
 
-      spec, source = specs_and_sources.max_by {|s,| s.version }
+      spec, source = specs_and_sources.max_by {|s,| s }
 
       if spec.nil?
         show_lookup_failure gem_name, version, errors, options[:domain]
diff --git a/lib/rubygems/commands/generate_index_command.rb b/lib/rubygems/commands/generate_index_command.rb
index 93e25ef..87200da 100644
--- a/lib/rubygems/commands/generate_index_command.rb
+++ b/lib/rubygems/commands/generate_index_command.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/indexer'
+require_relative '../command'
+require_relative '../indexer'
 
 ##
 # Generates a index files for use as a gem server.
diff --git a/lib/rubygems/commands/help_command.rb b/lib/rubygems/commands/help_command.rb
index 4e8d760..7f3383c 100644
--- a/lib/rubygems/commands/help_command.rb
+++ b/lib/rubygems/commands/help_command.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require 'rubygems/command'
+require_relative '../command'
 
 class Gem::Commands::HelpCommand < Gem::Command
   # :stopdoc:
diff --git a/lib/rubygems/commands/info_command.rb b/lib/rubygems/commands/info_command.rb
index 9ca6ae3..3f2dd4a 100644
--- a/lib/rubygems/commands/info_command.rb
+++ b/lib/rubygems/commands/info_command.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: true
 
-require 'rubygems/command'
-require 'rubygems/query_utils'
+require_relative '../command'
+require_relative '../query_utils'
 
 class Gem::Commands::InfoCommand < Gem::Command
   include Gem::QueryUtils
diff --git a/lib/rubygems/commands/install_command.rb b/lib/rubygems/commands/install_command.rb
index dcab60c..adf2cdb 100644
--- a/lib/rubygems/commands/install_command.rb
+++ b/lib/rubygems/commands/install_command.rb
@@ -1,10 +1,10 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/install_update_options'
-require 'rubygems/dependency_installer'
-require 'rubygems/local_remote_options'
-require 'rubygems/validator'
-require 'rubygems/version_option'
+require_relative '../command'
+require_relative '../install_update_options'
+require_relative '../dependency_installer'
+require_relative '../local_remote_options'
+require_relative '../validator'
+require_relative '../version_option'
 
 ##
 # Gem installer command line tool
@@ -27,6 +27,8 @@ class Gem::Commands::InstallCommand < Gem::Command
       :without_groups    => [],
     })
 
+    defaults.merge!(install_update_options)
+
     super 'install', 'Install a gem into the local repository', defaults
 
     add_install_update_options
@@ -43,8 +45,9 @@ class Gem::Commands::InstallCommand < Gem::Command
   end
 
   def defaults_str # :nodoc:
-    "--both --version '#{Gem::Requirement.default}' --document --no-force\n" +
-    "--install-dir #{Gem.dir} --lock"
+    "--both --version '#{Gem::Requirement.default}' --no-force\n" +
+    "--install-dir #{Gem.dir} --lock\n" +
+    install_update_defaults_str
   end
 
   def description # :nodoc:
@@ -169,7 +172,7 @@ You can use `i` command instead of `install`.
   end
 
   def install_from_gemdeps # :nodoc:
-    require 'rubygems/request_set'
+    require_relative '../request_set'
     rs = Gem::RequestSet.new
 
     specs = rs.install_from_gemdeps options do |req, inst|
@@ -244,11 +247,11 @@ You can use `i` command instead of `install`.
 
   def load_hooks # :nodoc:
     if options[:install_as_default]
-      require 'rubygems/install_default_message'
+      require_relative '../install_default_message'
     else
-      require 'rubygems/install_message'
+      require_relative '../install_message'
     end
-    require 'rubygems/rdoc'
+    require_relative '../rdoc'
   end
 
   def show_install_errors(errors) # :nodoc:
@@ -257,7 +260,8 @@ You can use `i` command instead of `install`.
     errors.each do |x|
       return unless Gem::SourceFetchProblem === x
 
-      msg = "Unable to pull data from '#{x.source.uri}': #{x.error.message}"
+      require_relative "../uri"
+      msg = "Unable to pull data from '#{Gem::Uri.new(x.source.uri).redacted}': #{x.error.message}"
 
       alert_warning msg
     end
diff --git a/lib/rubygems/commands/list_command.rb b/lib/rubygems/commands/list_command.rb
index 5c99d3d..dea1111 100644
--- a/lib/rubygems/commands/list_command.rb
+++ b/lib/rubygems/commands/list_command.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/query_utils'
+require_relative '../command'
+require_relative '../query_utils'
 
 ##
 # Searches for gems starting with the supplied argument.
diff --git a/lib/rubygems/commands/lock_command.rb b/lib/rubygems/commands/lock_command.rb
index f1dc1ac..cb6229a 100644
--- a/lib/rubygems/commands/lock_command.rb
+++ b/lib/rubygems/commands/lock_command.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require 'rubygems/command'
+require_relative '../command'
 
 class Gem::Commands::LockCommand < Gem::Command
   def initialize
diff --git a/lib/rubygems/commands/mirror_command.rb b/lib/rubygems/commands/mirror_command.rb
index 86671a9..7daa47e 100644
--- a/lib/rubygems/commands/mirror_command.rb
+++ b/lib/rubygems/commands/mirror_command.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require 'rubygems/command'
+require_relative '../command'
 
 unless defined? Gem::Commands::MirrorCommand
   class Gem::Commands::MirrorCommand < Gem::Command
diff --git a/lib/rubygems/commands/open_command.rb b/lib/rubygems/commands/open_command.rb
index 8012a9a..1e616fd 100644
--- a/lib/rubygems/commands/open_command.rb
+++ b/lib/rubygems/commands/open_command.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/version_option'
+require_relative '../command'
+require_relative '../version_option'
 
 class Gem::Commands::OpenCommand < Gem::Command
   include Gem::VersionOption
diff --git a/lib/rubygems/commands/outdated_command.rb b/lib/rubygems/commands/outdated_command.rb
index 3579bfc..162d338 100644
--- a/lib/rubygems/commands/outdated_command.rb
+++ b/lib/rubygems/commands/outdated_command.rb
@@ -1,8 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/local_remote_options'
-require 'rubygems/spec_fetcher'
-require 'rubygems/version_option'
+require_relative '../command'
+require_relative '../local_remote_options'
+require_relative '../spec_fetcher'
+require_relative '../version_option'
 
 class Gem::Commands::OutdatedCommand < Gem::Command
   include Gem::LocalRemoteOptions
diff --git a/lib/rubygems/commands/owner_command.rb b/lib/rubygems/commands/owner_command.rb
index dd49027..0a56652 100644
--- a/lib/rubygems/commands/owner_command.rb
+++ b/lib/rubygems/commands/owner_command.rb
@@ -1,8 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/local_remote_options'
-require 'rubygems/gemcutter_utilities'
-require 'rubygems/text'
+require_relative '../command'
+require_relative '../local_remote_options'
+require_relative '../gemcutter_utilities'
+require_relative '../text'
 
 class Gem::Commands::OwnerCommand < Gem::Command
   include Gem::Text
diff --git a/lib/rubygems/commands/pristine_command.rb b/lib/rubygems/commands/pristine_command.rb
index 1431059..13979b0 100644
--- a/lib/rubygems/commands/pristine_command.rb
+++ b/lib/rubygems/commands/pristine_command.rb
@@ -1,8 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/package'
-require 'rubygems/installer'
-require 'rubygems/version_option'
+require_relative '../command'
+require_relative '../package'
+require_relative '../installer'
+require_relative '../version_option'
 
 class Gem::Commands::PristineCommand < Gem::Command
   include Gem::VersionOption
@@ -50,6 +50,11 @@ class Gem::Commands::PristineCommand < Gem::Command
       options[:env_shebang] = value
     end
 
+    add_option('-i', '--install-dir DIR',
+               'Gem repository to get binstubs and plugins installed') do |value, options|
+      options[:install_dir] = File.expand_path(value)
+    end
+
     add_option('-n', '--bindir DIR',
                'Directory where executables are',
                'located') do |value, options|
@@ -138,7 +143,7 @@ extensions will be restored.
       gem = spec.cache_file
 
       unless File.exist? gem or options[:only_executables] or options[:only_plugins]
-        require 'rubygems/remote_fetcher'
+        require_relative '../remote_fetcher'
 
         say "Cached gem for #{spec.full_name} not found, attempting to fetch..."
 
@@ -163,11 +168,12 @@ extensions will be restored.
         end
 
       bin_dir = options[:bin_dir] if options[:bin_dir]
+      install_dir = options[:install_dir] if options[:install_dir]
 
       installer_options = {
         :wrappers => true,
         :force => true,
-        :install_dir => spec.base_dir,
+        :install_dir => install_dir || spec.base_dir,
         :env_shebang => env_shebang,
         :build_args => spec.build_args,
         :bin_dir => bin_dir,
@@ -177,7 +183,7 @@ extensions will be restored.
         installer = Gem::Installer.for_spec(spec, installer_options)
         installer.generate_bin
       elsif options[:only_plugins]
-        installer = Gem::Installer.for_spec(spec)
+        installer = Gem::Installer.for_spec(spec, installer_options)
         installer.generate_plugins
       else
         installer = Gem::Installer.at(gem, installer_options)
diff --git a/lib/rubygems/commands/push_command.rb b/lib/rubygems/commands/push_command.rb
index 1a9a193..1864b4b 100644
--- a/lib/rubygems/commands/push_command.rb
+++ b/lib/rubygems/commands/push_command.rb
@@ -1,8 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/local_remote_options'
-require 'rubygems/gemcutter_utilities'
-require 'rubygems/package'
+require_relative '../command'
+require_relative '../local_remote_options'
+require_relative '../gemcutter_utilities'
+require_relative '../package'
 
 class Gem::Commands::PushCommand < Gem::Command
   include Gem::LocalRemoteOptions
diff --git a/lib/rubygems/commands/query_command.rb b/lib/rubygems/commands/query_command.rb
index 789afd6..5896bec 100644
--- a/lib/rubygems/commands/query_command.rb
+++ b/lib/rubygems/commands/query_command.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/query_utils'
-require 'rubygems/deprecate'
+require_relative '../command'
+require_relative '../query_utils'
+require_relative '../deprecate'
 
 class Gem::Commands::QueryCommand < Gem::Command
   extend Gem::Deprecate
diff --git a/lib/rubygems/commands/rdoc_command.rb b/lib/rubygems/commands/rdoc_command.rb
index e8c9e84..305c80c 100644
--- a/lib/rubygems/commands/rdoc_command.rb
+++ b/lib/rubygems/commands/rdoc_command.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/version_option'
-require 'rubygems/rdoc'
+require_relative '../command'
+require_relative '../version_option'
+require_relative '../rdoc'
 require 'fileutils'
 
 class Gem::Commands::RdocCommand < Gem::Command
diff --git a/lib/rubygems/commands/search_command.rb b/lib/rubygems/commands/search_command.rb
index aeb2119..488d777 100644
--- a/lib/rubygems/commands/search_command.rb
+++ b/lib/rubygems/commands/search_command.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/query_utils'
+require_relative '../command'
+require_relative '../query_utils'
 
 class Gem::Commands::SearchCommand < Gem::Command
   include Gem::QueryUtils
diff --git a/lib/rubygems/commands/server_command.rb b/lib/rubygems/commands/server_command.rb
index 594cf77..f8cad3b 100644
--- a/lib/rubygems/commands/server_command.rb
+++ b/lib/rubygems/commands/server_command.rb
@@ -1,88 +1,25 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/server'
-require 'rubygems/deprecate'
-
-class Gem::Commands::ServerCommand < Gem::Command
-  extend Gem::Deprecate
-  rubygems_deprecate_command
-
-  def initialize
-    super 'server', 'Documentation and gem repository HTTP server',
-          :port => 8808, :gemdir => [], :daemon => false
-
-    OptionParser.accept :Port do |port|
-      if port =~ /\A\d+\z/
-        port = Integer port
-        raise OptionParser::InvalidArgument, "#{port}: not a port number" if
-          port > 65535
-
-        port
-      else
-        begin
-          Socket.getservbyname port
-        rescue SocketError
-          raise OptionParser::InvalidArgument, "#{port}: no such named service"
-        end
+require_relative '../command'
+
+unless defined? Gem::Commands::ServerCommand
+  class Gem::Commands::ServerCommand < Gem::Command
+    def initialize
+      super('server', 'Starts up a web server that hosts the RDoc (requires rubygems-server)')
+      begin
+        Gem::Specification.find_by_name('rubygems-server').activate
+      rescue Gem::LoadError
+        # no-op
       end
     end
 
-    add_option '-p', '--port=PORT', :Port,
-               'port to listen on' do |port, options|
-      options[:port] = port
-    end
-
-    add_option '-d', '--dir=GEMDIR',
-               'directories from which to serve gems',
-               'multiple directories may be provided' do |gemdir, options|
-      options[:gemdir] << File.expand_path(gemdir)
+    def description # :nodoc:
+      <<-EOF
+The server command has been moved to the rubygems-server gem.
+      EOF
     end
 
-    add_option '--[no-]daemon', 'run as a daemon' do |daemon, options|
-      options[:daemon] = daemon
+    def execute
+      alert_error "Install the rubygems-server gem for the server command"
     end
-
-    add_option '-b', '--bind=HOST,HOST',
-               'addresses to bind', Array do |address, options|
-      options[:addresses] ||= []
-      options[:addresses].push(*address)
-    end
-
-    add_option '-l', '--launch[=COMMAND]',
-               'launches a browser window',
-               "COMMAND defaults to 'start' on Windows",
-               "and 'open' on all other platforms" do |launch, options|
-      launch ||= Gem.win_platform? ? 'start' : 'open'
-      options[:launch] = launch
-    end
-  end
-
-  def defaults_str # :nodoc:
-    "--port 8808 --dir #{Gem.dir} --no-daemon"
-  end
-
-  def description # :nodoc:
-    <<-EOF
-The server command starts up a web server that hosts the RDoc for your
-installed gems and can operate as a server for installation of gems on other
-machines.
-
-The cache files for installed gems must exist to use the server as a source
-for gem installation.
-
-To install gems from a running server, use `gem install GEMNAME --source
-http://gem_server_host:8808`
-
-You can set up a shortcut to gem server documentation using the URL:
-
-  http://localhost:8808/rdoc?q=%s - Firefox
-  http://localhost:8808/rdoc?q=* - LaunchBar
-
-    EOF
-  end
-
-  def execute
-    options[:gemdir] = Gem.path if options[:gemdir].empty?
-    Gem::Server.run options
   end
 end
diff --git a/lib/rubygems/commands/setup_command.rb b/lib/rubygems/commands/setup_command.rb
index 47e215c..0601dcc 100644
--- a/lib/rubygems/commands/setup_command.rb
+++ b/lib/rubygems/commands/setup_command.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require 'rubygems/command'
+require_relative '../command'
 
 ##
 # Installs RubyGems itself.  This command is ordinarily only available from a
@@ -12,8 +12,6 @@ class Gem::Commands::SetupCommand < Gem::Command
   ENV_PATHS = %w[/usr/bin/env /bin/env].freeze
 
   def initialize
-    require 'tmpdir'
-
     super 'setup', 'Install RubyGems',
           :format_executable => false, :document => %w[ri],
           :force => true,
@@ -149,13 +147,6 @@ By default, this RubyGems will install gem as:
   def execute
     @verbose = Gem.configuration.really_verbose
 
-    install_destdir = options[:destdir]
-
-    unless install_destdir.empty?
-      ENV['GEM_HOME'] ||= File.join(install_destdir,
-                                    Gem.default_dir.gsub(/^[a-zA-Z]:/, ''))
-    end
-
     check_ruby_version
 
     require 'fileutils'
@@ -166,8 +157,8 @@ By default, this RubyGems will install gem as:
     end
     extend MakeDirs
 
-    lib_dir, bin_dir = make_destination_dirs install_destdir
-    man_dir = generate_default_man_dir install_destdir
+    lib_dir, bin_dir = make_destination_dirs
+    man_dir = generate_default_man_dir
 
     install_lib lib_dir
 
@@ -189,8 +180,8 @@ By default, this RubyGems will install gem as:
 
     say "RubyGems #{Gem::VERSION} installed"
 
-    regenerate_binstubs if options[:regenerate_binstubs]
-    regenerate_plugins if options[:regenerate_plugins]
+    regenerate_binstubs(bin_dir) if options[:regenerate_binstubs]
+    regenerate_plugins(bin_dir) if options[:regenerate_plugins]
 
     uninstall_old_gemcutter
 
@@ -258,35 +249,34 @@ By default, this RubyGems will install gem as:
       say "Installing #{tool} executable" if @verbose
 
       Dir.chdir path do
-        bin_files = Dir['*']
+        bin_file = "gem"
 
-        bin_files -= %w[update_rubygems]
+        require 'tmpdir'
 
-        bin_files.each do |bin_file|
-          dest_file = target_bin_path(bin_dir, bin_file)
-          bin_tmp_file = File.join Dir.tmpdir, "#{bin_file}.#{$$}"
+        dest_file = target_bin_path(bin_dir, bin_file)
+        bin_tmp_file = File.join Dir.tmpdir, "#{bin_file}.#{$$}"
 
-          begin
-            bin = File.readlines bin_file
-            bin[0] = shebang
+        begin
+          bin = File.readlines bin_file
+          bin[0] = shebang
 
-            File.open bin_tmp_file, 'w' do |fp|
-              fp.puts bin.join
-            end
-
-            install bin_tmp_file, dest_file, :mode => prog_mode
-            bin_file_names << dest_file
-          ensure
-            rm bin_tmp_file
+          File.open bin_tmp_file, 'w' do |fp|
+            fp.puts bin.join
           end
 
-          next unless Gem.win_platform?
+          install bin_tmp_file, dest_file, :mode => prog_mode
+          bin_file_names << dest_file
+        ensure
+          rm bin_tmp_file
+        end
+
+        next unless Gem.win_platform?
 
-          begin
-            bin_cmd_file = File.join Dir.tmpdir, "#{bin_file}.bat"
+        begin
+          bin_cmd_file = File.join Dir.tmpdir, "#{bin_file}.bat"
 
-            File.open bin_cmd_file, 'w' do |file|
-              file.puts <<-TEXT
+          File.open bin_cmd_file, 'w' do |file|
+            file.puts <<-TEXT
   @ECHO OFF
   IF NOT "%~f0" == "~f0" GOTO :WinNT
   @"#{File.basename(Gem.ruby).chomp('"')}" "#{dest_file}" %1 %2 %3 %4 %5 %6 %7 %8 %9
@@ -294,12 +284,11 @@ By default, this RubyGems will install gem as:
   :WinNT
   @"#{File.basename(Gem.ruby).chomp('"')}" "%~dpn0" %*
   TEXT
-            end
-
-            install bin_cmd_file, "#{dest_file}.bat", :mode => prog_mode
-          ensure
-            rm bin_cmd_file
           end
+
+          install bin_cmd_file, "#{dest_file}.bat", :mode => prog_mode
+        ensure
+          rm bin_cmd_file
         end
       end
     end
@@ -348,7 +337,7 @@ By default, this RubyGems will install gem as:
         rm_rf dir
       end
 
-      require 'rubygems/rdoc'
+      require_relative '../rdoc'
 
       fake_spec = Gem::Specification.new 'rubygems', Gem::VERSION
       def fake_spec.full_gem_path
@@ -371,8 +360,7 @@ By default, this RubyGems will install gem as:
   end
 
   def install_default_bundler_gem(bin_dir)
-    specs_dir = Gem.default_specifications_dir
-    specs_dir = File.join(options[:destdir], specs_dir) unless Gem.win_platform?
+    specs_dir = File.join(default_dir, "specifications", "default")
     mkdir_p specs_dir, :mode => 0755
 
     bundler_spec = Dir.chdir("bundler") { Gem::Specification.load("bundler.gemspec") }
@@ -387,8 +375,20 @@ By default, this RubyGems will install gem as:
 
     bundler_spec = Gem::Specification.load(default_spec_path)
 
+    # The base_dir value for a specification is inferred by walking up from the
+    # folder where the spec was `loaded_from`. In the case of default gems, we
+    # walk up two levels, because they live at `specifications/default/`, whereas
+    # in the case of regular gems we walk up just one level because they live at
+    # `specifications/`. However, in this case, the gem we are installing is
+    # misdetected as a regular gem, when it's a default gem in reality. This is
+    # because when there's a `:destdir`, the `loaded_from` path has changed and
+    # doesn't match `Gem.default_specifications_dir` which is the criteria to
+    # tag a gem as a default gem. So, in that case, write the correct
+    # `@base_dir` directly.
+    bundler_spec.instance_variable_set(:@base_dir, File.dirname(File.dirname(specs_dir)))
+
     # Remove gemspec that was same version of vendored bundler.
-    normal_gemspec = File.join(Gem.default_dir, "specifications", "bundler-#{bundler_spec.version}.gemspec")
+    normal_gemspec = File.join(default_dir, "specifications", "bundler-#{bundler_spec.version}.gemspec")
     if File.file? normal_gemspec
       File.delete normal_gemspec
     end
@@ -401,19 +401,26 @@ By default, this RubyGems will install gem as:
     end
 
     bundler_bin_dir = bundler_spec.bin_dir
-    bundler_bin_dir = File.join(options[:destdir], bundler_bin_dir) unless Gem.win_platform?
     mkdir_p bundler_bin_dir, :mode => 0755
     bundler_spec.executables.each do |e|
       cp File.join("bundler", bundler_spec.bindir, e), File.join(bundler_bin_dir, e)
     end
 
-    require 'rubygems/installer'
+    require_relative '../installer'
 
     Dir.chdir("bundler") do
       built_gem = Gem::Package.build(bundler_spec)
       begin
-        installer = Gem::Installer.at(built_gem, env_shebang: options[:env_shebang], format_executable: options[:format_executable], force: options[:force], install_as_default: true, bin_dir: bin_dir, wrappers: true)
-        installer.install
+        Gem::Installer.at(
+          built_gem,
+          env_shebang: options[:env_shebang],
+          format_executable: options[:format_executable],
+          force: options[:force],
+          install_as_default: true,
+          bin_dir: bin_dir,
+          install_dir: default_dir,
+          wrappers: true
+        ).install
       ensure
         FileUtils.rm_f built_gem
       end
@@ -424,11 +431,11 @@ By default, this RubyGems will install gem as:
     say "Bundler #{bundler_spec.version} installed"
   end
 
-  def make_destination_dirs(install_destdir)
+  def make_destination_dirs
     lib_dir, bin_dir = Gem.default_rubygems_dirs
 
     unless lib_dir
-      lib_dir, bin_dir = generate_default_dirs(install_destdir)
+      lib_dir, bin_dir = generate_default_dirs
     end
 
     mkdir_p lib_dir, :mode => 0755
@@ -437,7 +444,7 @@ By default, this RubyGems will install gem as:
     return lib_dir, bin_dir
   end
 
-  def generate_default_man_dir(install_destdir)
+  def generate_default_man_dir
     prefix = options[:prefix]
 
     if prefix.empty?
@@ -447,14 +454,10 @@ By default, this RubyGems will install gem as:
       man_dir = File.join prefix, 'man'
     end
 
-    unless install_destdir.empty?
-      man_dir = File.join install_destdir, man_dir.gsub(/^[a-zA-Z]:/, '')
-    end
-
-    man_dir
+    prepend_destdir_if_present(man_dir)
   end
 
-  def generate_default_dirs(install_destdir)
+  def generate_default_dirs
     prefix = options[:prefix]
     site_or_vendor = options[:site_or_vendor]
 
@@ -462,28 +465,11 @@ By default, this RubyGems will install gem as:
       lib_dir = RbConfig::CONFIG[site_or_vendor]
       bin_dir = RbConfig::CONFIG['bindir']
     else
-      # Apple installed RubyGems into libdir, and RubyGems <= 1.1.0 gets
-      # confused about installation location, so switch back to
-      # sitelibdir/vendorlibdir.
-      if defined?(APPLE_GEM_HOME) and
-        # just in case Apple and RubyGems don't get this patched up proper.
-        (prefix == RbConfig::CONFIG['libdir'] or
-         # this one is important
-         prefix == File.join(RbConfig::CONFIG['libdir'], 'ruby'))
-        lib_dir = RbConfig::CONFIG[site_or_vendor]
-        bin_dir = RbConfig::CONFIG['bindir']
-      else
-        lib_dir = File.join prefix, 'lib'
-        bin_dir = File.join prefix, 'bin'
-      end
+      lib_dir = File.join prefix, 'lib'
+      bin_dir = File.join prefix, 'bin'
     end
 
-    unless install_destdir.empty?
-      lib_dir = File.join install_destdir, lib_dir.gsub(/^[a-zA-Z]:/, '')
-      bin_dir = File.join install_destdir, bin_dir.gsub(/^[a-zA-Z]:/, '')
-    end
-
-    [lib_dir, bin_dir]
+    [prepend_destdir_if_present(lib_dir), prepend_destdir_if_present(bin_dir)]
   end
 
   def files_in(dir)
@@ -596,7 +582,7 @@ abort "#{deprecation_message}"
   end
 
   def uninstall_old_gemcutter
-    require 'rubygems/uninstaller'
+    require_relative '../uninstaller'
 
     ui = Gem::Uninstaller.new('gemcutter', :all => true, :ignore => true,
                               :version => '< 0.4')
@@ -604,11 +590,12 @@ abort "#{deprecation_message}"
   rescue Gem::InstallError
   end
 
-  def regenerate_binstubs
-    require "rubygems/commands/pristine_command"
+  def regenerate_binstubs(bindir)
+    require_relative "pristine_command"
     say "Regenerating binstubs"
 
     args = %w[--all --only-executables --silent]
+    args << "--bindir=#{bindir}"
     if options[:env_shebang]
       args << "--env-shebang"
     end
@@ -617,11 +604,13 @@ abort "#{deprecation_message}"
     command.invoke(*args)
   end
 
-  def regenerate_plugins
-    require "rubygems/commands/pristine_command"
+  def regenerate_plugins(bindir)
+    require_relative "pristine_command"
     say "Regenerating plugins"
 
     args = %w[--all --only-plugins --silent]
+    args << "--bindir=#{bindir}"
+    args << "--install-dir=#{default_dir}"
 
     command = Gem::Commands::PristineCommand.new
     command.invoke(*args)
@@ -629,6 +618,25 @@ abort "#{deprecation_message}"
 
   private
 
+  def default_dir
+    prefix = options[:prefix]
+
+    if prefix.empty?
+      dir = Gem.default_dir
+    else
+      dir = prefix
+    end
+
+    prepend_destdir_if_present(dir)
+  end
+
+  def prepend_destdir_if_present(path)
+    destdir = options[:destdir]
+    return path if destdir.empty?
+
+    File.join(options[:destdir], path.gsub(/^[a-zA-Z]:/, ''))
+  end
+
   def install_file_list(files, dest_dir)
     files.each do |file|
       install_file file, dest_dir
diff --git a/lib/rubygems/commands/signin_command.rb b/lib/rubygems/commands/signin_command.rb
index 2e19c83..23bb2f9 100644
--- a/lib/rubygems/commands/signin_command.rb
+++ b/lib/rubygems/commands/signin_command.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/gemcutter_utilities'
+require_relative '../command'
+require_relative '../gemcutter_utilities'
 
 class Gem::Commands::SigninCommand < Gem::Command
   include Gem::GemcutterUtilities
diff --git a/lib/rubygems/commands/signout_command.rb b/lib/rubygems/commands/signout_command.rb
index ebbe746..c9485e0 100644
--- a/lib/rubygems/commands/signout_command.rb
+++ b/lib/rubygems/commands/signout_command.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require 'rubygems/command'
+require_relative '../command'
 
 class Gem::Commands::SignoutCommand < Gem::Command
   def initialize
diff --git a/lib/rubygems/commands/sources_command.rb b/lib/rubygems/commands/sources_command.rb
index f74fb12..9e74f3c 100644
--- a/lib/rubygems/commands/sources_command.rb
+++ b/lib/rubygems/commands/sources_command.rb
@@ -1,8 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/remote_fetcher'
-require 'rubygems/spec_fetcher'
-require 'rubygems/local_remote_options'
+require_relative '../command'
+require_relative '../remote_fetcher'
+require_relative '../spec_fetcher'
+require_relative '../local_remote_options'
 
 class Gem::Commands::SourcesCommand < Gem::Command
   include Gem::LocalRemoteOptions
diff --git a/lib/rubygems/commands/specification_command.rb b/lib/rubygems/commands/specification_command.rb
index 3fddaaa..473b6e7 100644
--- a/lib/rubygems/commands/specification_command.rb
+++ b/lib/rubygems/commands/specification_command.rb
@@ -1,8 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/local_remote_options'
-require 'rubygems/version_option'
-require 'rubygems/package'
+require_relative '../command'
+require_relative '../local_remote_options'
+require_relative '../version_option'
+require_relative '../package'
 
 class Gem::Commands::SpecificationCommand < Gem::Command
   include Gem::LocalRemoteOptions
diff --git a/lib/rubygems/commands/stale_command.rb b/lib/rubygems/commands/stale_command.rb
index badc990..62a9796 100644
--- a/lib/rubygems/commands/stale_command.rb
+++ b/lib/rubygems/commands/stale_command.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require 'rubygems/command'
+require_relative '../command'
 
 class Gem::Commands::StaleCommand < Gem::Command
   def initialize
diff --git a/lib/rubygems/commands/uninstall_command.rb b/lib/rubygems/commands/uninstall_command.rb
index 1540b2f..467c8bf 100644
--- a/lib/rubygems/commands/uninstall_command.rb
+++ b/lib/rubygems/commands/uninstall_command.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/version_option'
-require 'rubygems/uninstaller'
+require_relative '../command'
+require_relative '../version_option'
+require_relative '../uninstaller'
 require 'fileutils'
 
 ##
@@ -81,7 +81,7 @@ class Gem::Commands::UninstallCommand < Gem::Command
                'Uninstall gem from the vendor directory.',
                'Only for use by gem repackagers.') do |value, options|
       unless Gem.vendor_dir
-        raise OptionParser::InvalidOption.new 'your platform is not supported'
+        raise Gem::OptionParser::InvalidOption.new 'your platform is not supported'
       end
 
       alert_warning 'Use your OS package manager to uninstall vendor gems'
diff --git a/lib/rubygems/commands/unpack_command.rb b/lib/rubygems/commands/unpack_command.rb
index 8d90d08..3f17083 100644
--- a/lib/rubygems/commands/unpack_command.rb
+++ b/lib/rubygems/commands/unpack_command.rb
@@ -1,9 +1,9 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/version_option'
-require 'rubygems/security_option'
-require 'rubygems/remote_fetcher'
-require 'rubygems/package'
+require_relative '../command'
+require_relative '../version_option'
+require_relative '../security_option'
+require_relative '../remote_fetcher'
+require_relative '../package'
 
 # forward-declare
 
diff --git a/lib/rubygems/commands/update_command.rb b/lib/rubygems/commands/update_command.rb
index 8d168d1..513351d 100644
--- a/lib/rubygems/commands/update_command.rb
+++ b/lib/rubygems/commands/update_command.rb
@@ -1,13 +1,13 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/command_manager'
-require 'rubygems/dependency_installer'
-require 'rubygems/install_update_options'
-require 'rubygems/local_remote_options'
-require 'rubygems/spec_fetcher'
-require 'rubygems/version_option'
-require 'rubygems/install_message' # must come before rdoc for messaging
-require 'rubygems/rdoc'
+require_relative '../command'
+require_relative '../command_manager'
+require_relative '../dependency_installer'
+require_relative '../install_update_options'
+require_relative '../local_remote_options'
+require_relative '../spec_fetcher'
+require_relative '../version_option'
+require_relative '../install_message' # must come before rdoc for messaging
+require_relative '../rdoc'
 
 class Gem::Commands::UpdateCommand < Gem::Command
   include Gem::InstallUpdateOptions
@@ -19,13 +19,17 @@ class Gem::Commands::UpdateCommand < Gem::Command
   attr_reader :updated # :nodoc:
 
   def initialize
-    super 'update', 'Update installed gems to the latest version',
-      :document => %w[rdoc ri],
-      :force    => false
+    options = {
+      :force => false,
+    }
+
+    options.merge!(install_update_options)
+
+    super 'update', 'Update installed gems to the latest version', options
 
     add_install_update_options
 
-    OptionParser.accept Gem::Version do |value|
+    Gem::OptionParser.accept Gem::Version do |value|
       Gem::Version.new value
 
       value
@@ -51,7 +55,8 @@ class Gem::Commands::UpdateCommand < Gem::Command
   end
 
   def defaults_str # :nodoc:
-    "--document --no-force --install-dir #{Gem.dir}"
+    "--no-force --install-dir #{Gem.dir}\n" +
+    install_update_defaults_str
   end
 
   def description # :nodoc:
diff --git a/lib/rubygems/commands/which_command.rb b/lib/rubygems/commands/which_command.rb
index d42ab18..44e87a2 100644
--- a/lib/rubygems/commands/which_command.rb
+++ b/lib/rubygems/commands/which_command.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require 'rubygems/command'
+require_relative '../command'
 
 class Gem::Commands::WhichCommand < Gem::Command
   def initialize
diff --git a/lib/rubygems/commands/yank_command.rb b/lib/rubygems/commands/yank_command.rb
index a793025..cad78ae 100644
--- a/lib/rubygems/commands/yank_command.rb
+++ b/lib/rubygems/commands/yank_command.rb
@@ -1,8 +1,8 @@
 # frozen_string_literal: true
-require 'rubygems/command'
-require 'rubygems/local_remote_options'
-require 'rubygems/version_option'
-require 'rubygems/gemcutter_utilities'
+require_relative '../command'
+require_relative '../local_remote_options'
+require_relative '../version_option'
+require_relative '../gemcutter_utilities'
 
 class Gem::Commands::YankCommand < Gem::Command
   include Gem::LocalRemoteOptions
diff --git a/lib/rubygems/config_file.rb b/lib/rubygems/config_file.rb
index 3746d7a..60c1d50 100644
--- a/lib/rubygems/config_file.rb
+++ b/lib/rubygems/config_file.rb
@@ -5,7 +5,7 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/user_interaction'
+require_relative 'user_interaction'
 require 'rbconfig'
 
 ##
@@ -320,7 +320,8 @@ if you believe they were disclosed to a third party.
     config = load_file(credentials_path).merge(host => api_key)
 
     dirname = File.dirname credentials_path
-    FileUtils.mkdir_p(dirname) unless File.exist? dirname
+    require 'fileutils'
+    FileUtils.mkdir_p(dirname)
 
     Gem.load_yaml
 
@@ -457,9 +458,8 @@ if you believe they were disclosed to a third party.
 
   # Writes out this config file, replacing its source.
   def write
-    unless File.exist?(File.dirname(config_file_name))
-      FileUtils.mkdir_p File.dirname(config_file_name)
-    end
+    require 'fileutils'
+    FileUtils.mkdir_p File.dirname(config_file_name)
 
     File.open config_file_name, 'w' do |io|
       io.write to_yaml
diff --git a/lib/rubygems/core_ext/tcpsocket_init.rb b/lib/rubygems/core_ext/tcpsocket_init.rb
index 3d9740c..2a79b63 100644
--- a/lib/rubygems/core_ext/tcpsocket_init.rb
+++ b/lib/rubygems/core_ext/tcpsocket_init.rb
@@ -11,10 +11,10 @@ module CoreExtensions
       IPV4_DELAY_SECONDS = 0.1
 
       def initialize(host, serv, *rest)
-        mutex = Mutex.new
+        mutex = Thread::Mutex.new
         addrs = []
         threads = []
-        cond_var = ConditionVariable.new
+        cond_var = Thread::ConditionVariable.new
 
         Addrinfo.foreach(host, serv, nil, :STREAM) do |addr|
           Thread.report_on_exception = false if defined? Thread.report_on_exception = ()
diff --git a/lib/rubygems/defaults.rb b/lib/rubygems/defaults.rb
index e95bc06..39b69dd 100644
--- a/lib/rubygems/defaults.rb
+++ b/lib/rubygems/defaults.rb
@@ -34,21 +34,7 @@ module Gem
   # specified in the environment
 
   def self.default_dir
-    path = if defined? RUBY_FRAMEWORK_VERSION
-             [
-               File.dirname(RbConfig::CONFIG['sitedir']),
-               'Gems',
-               RbConfig::CONFIG['ruby_version'],
-             ]
-           else
-             [
-               RbConfig::CONFIG['rubylibprefix'],
-               'gems',
-               RbConfig::CONFIG['ruby_version'],
-             ]
-           end
-
-    @default_dir ||= File.join(*path)
+    @default_dir ||= File.join(RbConfig::CONFIG['rubylibprefix'], 'gems', RbConfig::CONFIG['ruby_version'])
   end
 
   ##
@@ -73,7 +59,7 @@ module Gem
   # Path to specification files of default gems.
 
   def self.default_specifications_dir
-    File.join(Gem.default_dir, "specifications", "default")
+    @default_specifications_dir ||= File.join(Gem.default_dir, "specifications", "default")
   end
 
   ##
@@ -197,11 +183,7 @@ module Gem
   # The default directory for binaries
 
   def self.default_bindir
-    if defined? RUBY_FRAMEWORK_VERSION # mac framework support
-      '/usr/local/bin'
-    else # generic install
-      RbConfig::CONFIG['bindir']
-    end
+    RbConfig::CONFIG['bindir']
   end
 
   def self.ruby_engine
diff --git a/lib/rubygems/dependency.rb b/lib/rubygems/dependency.rb
index 3721204..3640362 100644
--- a/lib/rubygems/dependency.rb
+++ b/lib/rubygems/dependency.rb
@@ -277,7 +277,7 @@ class Gem::Dependency
       requirement.satisfied_by?(spec.version) && env_req.satisfied_by?(spec.version)
     end.map(&:to_spec)
 
-    Gem::BundlerVersionFinder.filter!(matches) if filters_bundler?
+    Gem::BundlerVersionFinder.prioritize!(matches) if prioritizes_bundler?
 
     if platform_only
       matches.reject! do |spec|
@@ -295,7 +295,7 @@ class Gem::Dependency
     @requirement.specific?
   end
 
-  def filters_bundler?
+  def prioritizes_bundler?
     name == "bundler".freeze && !specific?
   end
 
@@ -325,11 +325,11 @@ class Gem::Dependency
     active = matches.find {|spec| spec.activated? }
     return active if active
 
-    return matches.first if prerelease?
-
-    # Move prereleases to the end of the list for >= 0 requirements
-    pre, matches = matches.partition {|spec| spec.version.prerelease? }
-    matches += pre if requirement == Gem::Requirement.default
+    unless prerelease?
+      # Move prereleases to the end of the list for >= 0 requirements
+      pre, matches = matches.partition {|spec| spec.version.prerelease? }
+      matches += pre if requirement == Gem::Requirement.default
+    end
 
     matches.first
   end
diff --git a/lib/rubygems/dependency_installer.rb b/lib/rubygems/dependency_installer.rb
index 400a5de..913bba3 100644
--- a/lib/rubygems/dependency_installer.rb
+++ b/lib/rubygems/dependency_installer.rb
@@ -1,12 +1,12 @@
 # frozen_string_literal: true
-require 'rubygems'
-require 'rubygems/dependency_list'
-require 'rubygems/package'
-require 'rubygems/installer'
-require 'rubygems/spec_fetcher'
-require 'rubygems/user_interaction'
-require 'rubygems/available_set'
-require 'rubygems/deprecate'
+require_relative '../rubygems'
+require_relative 'dependency_list'
+require_relative 'package'
+require_relative 'installer'
+require_relative 'spec_fetcher'
+require_relative 'user_interaction'
+require_relative 'available_set'
+require_relative 'deprecate'
 
 ##
 # Installs a gem along with all its dependencies from local and remote gems.
diff --git a/lib/rubygems/dependency_list.rb b/lib/rubygems/dependency_list.rb
index bcf436c..10e08fc 100644
--- a/lib/rubygems/dependency_list.rb
+++ b/lib/rubygems/dependency_list.rb
@@ -5,8 +5,8 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'tsort'
-require 'rubygems/deprecate'
+require_relative 'tsort'
+require_relative 'deprecate'
 
 ##
 # Gem::DependencyList is used for installing and uninstalling gems in the
@@ -20,7 +20,7 @@ class Gem::DependencyList
   attr_reader :specs
 
   include Enumerable
-  include TSort
+  include Gem::TSort
 
   ##
   # Allows enabling/disabling use of development dependencies
diff --git a/lib/rubygems/deprecate.rb b/lib/rubygems/deprecate.rb
index 8c822cd..5fe0afb 100644
--- a/lib/rubygems/deprecate.rb
+++ b/lib/rubygems/deprecate.rb
@@ -1,23 +1,70 @@
 # frozen_string_literal: true
 ##
-# Provides a single method +deprecate+ to be used to declare when
-# something is going away.
+# Provides 3 methods for declaring when something is going away.
+#
+# +deprecate(name, repl, year, month)+:
+#     Indicate something may be removed on/after a certain date.
+#
+# +rubygems_deprecate(name, replacement=:none)+:
+#     Indicate something will be removed in the next major RubyGems version,
+#     and (optionally) a replacement for it.
+#
+# +rubygems_deprecate_command+:
+#     Indicate a RubyGems command (in +lib/rubygems/commands/*.rb+) will be
+#     removed in the next RubyGems version.
+#
+# Also provides +skip_during+ for temporarily turning off deprecation warnings.
+# This is intended to be used in the test suite, so deprecation warnings
+# don't cause test failures if you need to make sure stderr is otherwise empty.
+#
+#
+# Example usage of +deprecate+ and +rubygems_deprecate+:
 #
 #     class Legacy
-#       def self.klass_method
+#       def self.some_class_method
 #         # ...
 #       end
 #
-#       def instance_method
+#       def some_instance_method
+#         # ...
+#       end
+#
+#       def some_old_method
 #         # ...
 #       end
 #
 #       extend Gem::Deprecate
-#       deprecate :instance_method, "X.z", 2011, 4
+#       deprecate :some_instance_method, "X.z", 2011, 4
+#       rubygems_deprecate :some_old_method, "Modern#some_new_method"
 #
 #       class << self
 #         extend Gem::Deprecate
-#         deprecate :klass_method, :none, 2011, 4
+#         deprecate :some_class_method, :none, 2011, 4
+#       end
+#     end
+#
+#
+# Example usage of +rubygems_deprecate_command+:
+#
+#     class Gem::Commands::QueryCommand < Gem::Command
+#       extend Gem::Deprecate
+#       rubygems_deprecate_command
+#
+#       # ...
+#     end
+#
+#
+# Example usage of +skip_during+:
+#
+#     class TestSomething < Gem::Testcase
+#       def test_some_thing_with_deprecations
+#         Gem::Deprecate.skip_during do
+#           actual_stdout, actual_stderr = capture_output do
+#             Gem.something_deprecated
+#           end
+#           assert_empty actual_stdout
+#           assert_equal(expected, actual_stderr)
+#         end
 #       end
 #     end
 
diff --git a/lib/rubygems/doctor.rb b/lib/rubygems/doctor.rb
index ef31aed..41bcda9 100644
--- a/lib/rubygems/doctor.rb
+++ b/lib/rubygems/doctor.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems'
-require 'rubygems/user_interaction'
+require_relative '../rubygems'
+require_relative 'user_interaction'
 
 ##
 # Cleans up after a partially-failed uninstall or for an invalid
diff --git a/lib/rubygems/errors.rb b/lib/rubygems/errors.rb
index abee206..f115ce2 100644
--- a/lib/rubygems/errors.rb
+++ b/lib/rubygems/errors.rb
@@ -59,9 +59,6 @@ module Gem
     private
 
     def build_message
-      if name == "bundler" && message = Gem::BundlerVersionFinder.missing_version_message
-        return message
-      end
       names = specs.map(&:full_name)
       "Could not find '#{name}' (#{requirement}) - did find: [#{names.join ','}]\n"
     end
@@ -171,8 +168,7 @@ module Gem
     # An English description of the error.
 
     def wordy
-      @source.uri.password = 'REDACTED' unless @source.uri.password.nil?
-      "Unable to download data from #{@source.uri} - #{@error.message}"
+      "Unable to download data from #{Gem::Uri.new(@source.uri).redacted} - #{@error.message}"
     end
 
     ##
diff --git a/lib/rubygems/exceptions.rb b/lib/rubygems/exceptions.rb
index 804863f..1806869 100644
--- a/lib/rubygems/exceptions.rb
+++ b/lib/rubygems/exceptions.rb
@@ -1,6 +1,7 @@
 # frozen_string_literal: true
 
-require 'rubygems/deprecate'
+require_relative 'deprecate'
+require_relative 'unknown_command_spell_checker'
 
 ##
 # Base exception class for RubyGems.  All exception raised by RubyGems are a
@@ -9,6 +10,34 @@ class Gem::Exception < RuntimeError; end
 
 class Gem::CommandLineError < Gem::Exception; end
 
+class Gem::UnknownCommandError < Gem::Exception
+  attr_reader :unknown_command
+
+  def initialize(unknown_command)
+    self.class.attach_correctable
+
+    @unknown_command = unknown_command
+    super("Unknown command #{unknown_command}")
+  end
+
+  def self.attach_correctable
+    return if defined?(@attached)
+
+    if defined?(DidYouMean::SPELL_CHECKERS) && defined?(DidYouMean::Correctable)
+      if DidYouMean.respond_to?(:correct_error)
+        DidYouMean.correct_error(Gem::UnknownCommandError, Gem::UnknownCommandSpellChecker)
+      else
+        DidYouMean::SPELL_CHECKERS['Gem::UnknownCommandError'] =
+          Gem::UnknownCommandSpellChecker
+
+        prepend DidYouMean::Correctable
+      end
+    end
+
+    @attached = true
+  end
+end
+
 class Gem::DependencyError < Gem::Exception; end
 
 class Gem::DependencyRemovalException < Gem::Exception; end
@@ -200,7 +229,7 @@ class Gem::SystemExitException < SystemExit
   def initialize(exit_code)
     @exit_code = exit_code
 
-    super "Exiting RubyGems with exit_code #{exit_code}"
+    super exit_code, "Exiting RubyGems with exit_code #{exit_code}"
   end
 end
 
@@ -259,3 +288,4 @@ end
 # Backwards compatible typo'd exception class for early RubyGems 2.0.x
 
 Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError # :nodoc:
+Gem.deprecate_constant :UnsatisfiableDepedencyError
diff --git a/lib/rubygems/ext/builder.rb b/lib/rubygems/ext/builder.rb
index e4af450..6d32be6 100644
--- a/lib/rubygems/ext/builder.rb
+++ b/lib/rubygems/ext/builder.rb
@@ -24,13 +24,14 @@ class Gem::Ext::Builder
 
     # try to find make program from Ruby configure arguments first
     RbConfig::CONFIG['configure_args'] =~ /with-make-prog\=(\w+)/
-    make_program = ENV['MAKE'] || ENV['make'] || $1
-    unless make_program
-      make_program = (/mswin/ =~ RUBY_PLATFORM) ? 'nmake' : 'make'
+    make_program_name = ENV['MAKE'] || ENV['make'] || $1
+    unless make_program_name
+      make_program_name = (/mswin/ =~ RUBY_PLATFORM) ? 'nmake' : 'make'
     end
-    make_program = Shellwords.split(make_program)
+    make_program = Shellwords.split(make_program_name)
 
-    destdir = 'DESTDIR=%s' % ENV['DESTDIR']
+    # The installation of the bundled gems is failed when DESTDIR is empty in mswin platform.
+    destdir = (/\bnmake/i !~ make_program_name || ENV['DESTDIR'] && ENV['DESTDIR'] != "") ? 'DESTDIR=%s' % ENV['DESTDIR'] : ''
 
     ['clean', '', 'install'].each do |target|
       # Pass DESTDIR via command line to override what's in MAKEFLAGS
@@ -57,19 +58,22 @@ class Gem::Ext::Builder
         p(command)
       end
       results << "current directory: #{dir}"
+      require "shellwords"
       results << command.shelljoin
 
       require "open3"
       # Set $SOURCE_DATE_EPOCH for the subprocess.
       env = {'SOURCE_DATE_EPOCH' => Gem.source_date_epoch_string}
-      output, status = Open3.capture2e(env, *command, :chdir => dir)
+      output, status = begin
+                         Open3.capture2e(env, *command, :chdir => dir)
+                       rescue => error
+                         raise Gem::InstallError, "#{command_name || class_name} failed#{error.message}"
+                       end
       if verbose
         puts output
       else
         results << output
       end
-    rescue => error
-      raise Gem::InstallError, "#{command_name || class_name} failed#{error.message}"
     ensure
       ENV['RUBYGEMS_GEMDEPS'] = rubygems_gemdeps
     end
diff --git a/lib/rubygems/ext/cmake_builder.rb b/lib/rubygems/ext/cmake_builder.rb
index 269e876..e47cabe 100644
--- a/lib/rubygems/ext/cmake_builder.rb
+++ b/lib/rubygems/ext/cmake_builder.rb
@@ -1,9 +1,9 @@
 # frozen_string_literal: true
-require_relative '../command'
 
 class Gem::Ext::CmakeBuilder < Gem::Ext::Builder
   def self.build(extension, dest_path, results, args=[], lib_dir=nil, cmake_dir=Dir.pwd)
     unless File.exist?(File.join(cmake_dir, 'Makefile'))
+      require_relative '../command'
       cmd = ["cmake", ".", "-DCMAKE_INSTALL_PREFIX=#{dest_path}", *Gem::Command.build_args]
 
       run cmd, results, class_name, cmake_dir
diff --git a/lib/rubygems/ext/ext_conf_builder.rb b/lib/rubygems/ext/ext_conf_builder.rb
index 1f73796..3ca3463 100644
--- a/lib/rubygems/ext/ext_conf_builder.rb
+++ b/lib/rubygems/ext/ext_conf_builder.rb
@@ -5,8 +5,6 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'shellwords'
-
 class Gem::Ext::ExtConfBuilder < Gem::Ext::Builder
   def self.build(extension, dest_path, results, args=[], lib_dir=nil, extension_dir=Dir.pwd)
     require 'fileutils'
@@ -40,6 +38,7 @@ class Gem::Ext::ExtConfBuilder < Gem::Ext::Builder
       begin
         # workaround for https://github.com/oracle/truffleruby/issues/2115
         siteconf_path = RUBY_ENGINE == "truffleruby" ? siteconf.path.dup : siteconf.path
+        require "shellwords"
         cmd = Gem.ruby.shellsplit << "-I" << File.expand_path("../../..", __FILE__) <<
               "-r" << get_relative_path(siteconf_path, extension_dir) << File.basename(extension)
         cmd.push(*args)
diff --git a/lib/rubygems/ext/rake_builder.rb b/lib/rubygems/ext/rake_builder.rb
index 64a6c0e..fed98e7 100644
--- a/lib/rubygems/ext/rake_builder.rb
+++ b/lib/rubygems/ext/rake_builder.rb
@@ -5,8 +5,6 @@
 # See LICENSE.txt for permissions.
 #++
 
-require "shellwords"
-
 class Gem::Ext::RakeBuilder < Gem::Ext::Builder
   def self.build(extension, dest_path, results, args=[], lib_dir=nil, extension_dir=Dir.pwd)
     if File.basename(extension) =~ /mkrf_conf/i
@@ -16,6 +14,7 @@ class Gem::Ext::RakeBuilder < Gem::Ext::Builder
     rake = ENV['rake']
 
     if rake
+      require "shellwords"
       rake = rake.shellsplit
     else
       begin
diff --git a/lib/rubygems/gem_runner.rb b/lib/rubygems/gem_runner.rb
index a366745..55b5a7d 100644
--- a/lib/rubygems/gem_runner.rb
+++ b/lib/rubygems/gem_runner.rb
@@ -5,9 +5,9 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems'
-require 'rubygems/command_manager'
-require 'rubygems/deprecate'
+require_relative '../rubygems'
+require_relative 'command_manager'
+require_relative 'deprecate'
 
 ##
 # Load additional plugins from $LOAD_PATH
diff --git a/lib/rubygems/gemcutter_utilities.rb b/lib/rubygems/gemcutter_utilities.rb
index 00e6891..0968e1a 100644
--- a/lib/rubygems/gemcutter_utilities.rb
+++ b/lib/rubygems/gemcutter_utilities.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems/remote_fetcher'
-require 'rubygems/text'
+require_relative 'remote_fetcher'
+require_relative 'text'
 
 ##
 # Utility methods for using the RubyGems API.
@@ -31,7 +31,8 @@ module Gem::GemcutterUtilities
 
   def add_otp_option
     add_option('--otp CODE',
-               'Digit code for multifactor authentication') do |value, options|
+               'Digit code for multifactor authentication',
+               'You can also use the environment variable GEM_HOST_OTP_CODE') do |value, options|
       options[:otp] = value
     end
   end
diff --git a/lib/rubygems/indexer.rb b/lib/rubygems/indexer.rb
index e595459..6e8dade 100644
--- a/lib/rubygems/indexer.rb
+++ b/lib/rubygems/indexer.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems'
-require 'rubygems/package'
+require_relative '../rubygems'
+require_relative 'package'
 require 'tmpdir'
 
 ##
diff --git a/lib/rubygems/install_default_message.rb b/lib/rubygems/install_default_message.rb
index f68fd2f..052ef52 100644
--- a/lib/rubygems/install_default_message.rb
+++ b/lib/rubygems/install_default_message.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems'
-require 'rubygems/user_interaction'
+require_relative '../rubygems'
+require_relative 'user_interaction'
 
 ##
 # A post-install hook that displays "Successfully installed
diff --git a/lib/rubygems/install_message.rb b/lib/rubygems/install_message.rb
index 3c13888..861ead3 100644
--- a/lib/rubygems/install_message.rb
+++ b/lib/rubygems/install_message.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
-require 'rubygems'
-require 'rubygems/user_interaction'
+require_relative '../rubygems'
+require_relative 'user_interaction'
 
 ##
 # A default post-install hook that displays "Successfully installed
diff --git a/lib/rubygems/install_update_options.rb b/lib/rubygems/install_update_options.rb
index ef1ad1e..2203b17 100644
--- a/lib/rubygems/install_update_options.rb
+++ b/lib/rubygems/install_update_options.rb
@@ -5,8 +5,8 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems'
-require 'rubygems/security_option'
+require_relative '../rubygems'
+require_relative 'security_option'
 
 ##
 # Mixin methods for install and update options for Gem::Commands
@@ -51,7 +51,7 @@ module Gem::InstallUpdateOptions
                'Install gem into the vendor directory.',
                'Only for use by gem repackagers.') do |value, options|
       unless Gem.vendor_dir
-        raise OptionParser::InvalidOption.new 'your platform is not supported'
+        raise Gem::OptionParser::InvalidOption.new 'your platform is not supported'
       end
 
       options[:vendor] = true
@@ -143,7 +143,7 @@ module Gem::InstallUpdateOptions
       unless v
         message = v ? v : "(tried #{Gem::GEM_DEP_FILES.join ', '})"
 
-        raise OptionParser::InvalidArgument,
+        raise Gem::OptionParser::InvalidArgument,
                 "cannot find gem dependencies file #{message}"
       end
 
@@ -181,10 +181,19 @@ module Gem::InstallUpdateOptions
   end
 
   ##
-  # Default options for the gem install command.
+  # Default options for the gem install and update commands.
+
+  def install_update_options
+    {
+      :document => %w[ri],
+    }
+  end
+
+  ##
+  # Default description for the gem install and update commands.
 
   def install_update_defaults_str
-    '--document=rdoc,ri --wrappers'
+    '--document=ri'
   end
 
 end
diff --git a/lib/rubygems/installer.rb b/lib/rubygems/installer.rb
index 8c28660..ab09c18 100644
--- a/lib/rubygems/installer.rb
+++ b/lib/rubygems/installer.rb
@@ -5,13 +5,12 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/command'
-require 'rubygems/installer_uninstaller_utils'
-require 'rubygems/exceptions'
-require 'rubygems/deprecate'
-require 'rubygems/package'
-require 'rubygems/ext'
-require 'rubygems/user_interaction'
+require_relative 'installer_uninstaller_utils'
+require_relative 'exceptions'
+require_relative 'deprecate'
+require_relative 'package'
+require_relative 'ext'
+require_relative 'user_interaction'
 
 ##
 # The installer installs the files contained in the .gem into the Gem.home.
@@ -68,19 +67,28 @@ class Gem::Installer
 
   @path_warning = false
 
-  @install_lock = Mutex.new
-
   class << self
-    ##
-    # True if we've warned about PATH not including Gem.bindir
+    #
+    # Changes in rubygems to lazily loading `rubygems/command` (in order to
+    # lazily load `optparse` as a side effect) affect bundler's custom installer
+    # which uses `Gem::Command` without requiring it (up until bundler 2.2.29).
+    # This hook is to compensate for that missing require.
+    #
+    # TODO: Remove when rubygems no longer supports running on bundler older
+    # than 2.2.29.
 
-    attr_accessor :path_warning
+    def inherited(klass)
+      if klass.name == "Bundler::RubyGemsGemInstaller"
+        require "rubygems/command"
+      end
+
+      super(klass)
+    end
 
     ##
-    # Certain aspects of the install process are not thread-safe. This lock is
-    # used to allow multiple threads to install Gems at the same time.
+    # True if we've warned about PATH not including Gem.bindir
 
-    attr_reader :install_lock
+    attr_accessor :path_warning
 
     ##
     # Overrides the executable format.
@@ -285,8 +293,6 @@ class Gem::Installer
   def install
     pre_install_checks
 
-    FileUtils.rm_f File.join gem_home, 'specifications', spec.spec_name
-
     run_pre_install_hooks
 
     # Set loaded_from to ensure extension_dir is correct
@@ -326,7 +332,7 @@ class Gem::Installer
 
     say spec.post_install_message if options[:post_install_message] && !spec.post_install_message.nil?
 
-    Gem::Installer.install_lock.synchronize { Gem::Specification.reset }
+    Gem::Specification.reset
 
     run_post_install_hooks
 
@@ -440,13 +446,9 @@ class Gem::Installer
   # specifications directory.
 
   def write_spec
-    File.open spec_file, 'w' do |file|
-      spec.installed_by_version = Gem.rubygems_version
+    spec.installed_by_version = Gem.rubygems_version
 
-      file.puts spec.to_ruby_for_cache
-
-      file.fsync rescue nil # for filesystems without fsync(2)
-    end
+    Gem.write_binary(spec_file, spec.to_ruby_for_cache)
   end
 
   ##
@@ -454,9 +456,7 @@ class Gem::Installer
   # specifications/default directory.
 
   def write_default_spec
-    File.open(default_spec_file, "w") do |file|
-      file.puts spec.to_ruby
-    end
+    Gem.write_binary(default_spec_file, spec.to_ruby)
   end
 
   ##
@@ -511,7 +511,7 @@ class Gem::Installer
   end
 
   def generate_plugins # :nodoc:
-    latest = Gem::Installer.install_lock.synchronize { Gem::Specification.latest_spec_for(spec.name) }
+    latest = Gem::Specification.latest_spec_for(spec.name)
     return if latest && latest.version > spec.version
 
     ensure_writable_dir @plugins_dir
@@ -676,7 +676,7 @@ class Gem::Installer
     @development         = options[:development]
     @build_root          = options[:build_root]
 
-    @build_args = options[:build_args] || Gem::Command.build_args
+    @build_args = options[:build_args]
 
     unless @build_root.nil?
       @bin_dir = File.join(@build_root, @bin_dir.gsub(/^[a-zA-Z]:/, ''))
@@ -761,14 +761,14 @@ class Gem::Installer
 #
 
 require 'rubygems'
-
+#{gemdeps_load(spec.name)}
 version = "#{Gem::Requirement.default_prerelease}"
 
 str = ARGV.first
 if str
   str = str.b[/\\A_(.*)_\\z/, 1]
   if str and Gem::Version.correct?(str)
-    version = str
+    #{explicit_version_requirement(spec.name)}
     ARGV.shift
   end
 end
@@ -782,6 +782,25 @@ end
 TEXT
   end
 
+  def gemdeps_load(name)
+    return '' if name == "bundler"
+
+    <<-TEXT
+
+Gem.use_gemdeps
+TEXT
+  end
+
+  def explicit_version_requirement(name)
+    code = "version = str"
+    return code unless name == "bundler"
+
+    code += <<-TEXT
+
+    ENV['BUNDLER_VERSION'] = str
+TEXT
+  end
+
   ##
   # return the stub script text used to launch the true Ruby script
 
@@ -823,7 +842,7 @@ TEXT
   # configure scripts and rakefiles or mkrf_conf files.
 
   def build_extensions
-    builder = Gem::Ext::Builder.new spec, @build_args
+    builder = Gem::Ext::Builder.new spec, build_args
 
     builder.build_extensions
   end
@@ -910,7 +929,7 @@ TEXT
   # extensions.
 
   def write_build_info_file
-    return if @build_args.empty?
+    return if build_args.empty?
 
     build_info_dir = File.join gem_home, 'build_info'
 
@@ -920,7 +939,7 @@ TEXT
     build_info_file = File.join build_info_dir, "#{spec.full_name}.info"
 
     File.open build_info_file, 'w' do |io|
-      @build_args.each do |arg|
+      build_args.each do |arg|
         io.puts arg
       end
     end
@@ -945,4 +964,13 @@ TEXT
 
     raise Gem::FilePermissionError.new(dir) unless File.writable? dir
   end
+
+  private
+
+  def build_args
+    @build_args ||= begin
+                      require_relative "command"
+                      Gem::Command.build_args
+                    end
+  end
 end
diff --git a/lib/rubygems/installer_test_case.rb b/lib/rubygems/installer_test_case.rb
deleted file mode 100644
index 416dac7..0000000
--- a/lib/rubygems/installer_test_case.rb
+++ /dev/null
@@ -1,247 +0,0 @@
-# frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/installer'
-
-class Gem::Installer
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :bin_dir
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :build_args
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :gem_dir
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :force
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :format
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :gem_home
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :env_shebang
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :ignore_dependencies
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :format_executable
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :security_policy
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
-  attr_writer :wrappers
-end
-
-##
-# A test case for Gem::Installer.
-
-class Gem::InstallerTestCase < Gem::TestCase
-  def setup
-    super
-
-    Gem::Installer.path_warning = false
-  end
-
-  ##
-  # The path where installed executables live
-
-  def util_inst_bindir
-    File.join @gemhome, "bin"
-  end
-
-  ##
-  # Adds an executable named "executable" to +spec+ with the given +shebang+.
-  #
-  # The executable is also written to the bin dir in @tmpdir and the installed
-  # gem directory for +spec+.
-
-  def util_make_exec(spec = @spec, shebang = "#!/usr/bin/ruby", bindir = "bin")
-    spec.executables = %w[executable]
-    spec.bindir = bindir
-
-    exec_path = spec.bin_file "executable"
-    write_file exec_path do |io|
-      io.puts shebang
-    end
-
-    bin_path = File.join @tempdir, "bin", "executable"
-    write_file bin_path do |io|
-      io.puts shebang
-    end
-  end
-
-  ##
-  # Creates the following instance variables:
-  #
-  # @spec::
-  #   a spec named 'a', intended for regular installs
-  #
-  # @gem::
-  #   the path to a built gem from @spec
-  #
-  # And returns a Gem::Installer for the @spec that installs into @gemhome
-
-  def setup_base_installer(force = true)
-    @gem = setup_base_gem
-    util_installer @spec, @gemhome, false, force
-  end
-
-  ##
-  # Creates the following instance variables:
-  #
-  # @spec::
-  #   a spec named 'a', intended for regular installs
-  #
-  # And returns a gem built for the @spec
-
-  def setup_base_gem
-    @spec = setup_base_spec
-    util_build_gem @spec
-    @spec.cache_file
-  end
-
-  ##
-  # Sets up a generic specification for testing the rubygems installer
-  #
-  # And returns it
-
-  def setup_base_spec
-    quick_gem 'a' do |spec|
-      util_make_exec spec
-    end
-  end
-
-  ##
-  # Creates the following instance variables:
-  #
-  # @spec::
-  #   a spec named 'a', intended for regular installs
-  # @user_spec::
-  #   a spec named 'b', intended for user installs
-  #
-  # @gem::
-  #   the path to a built gem from @spec
-  # @user_gem::
-  #   the path to a built gem from @user_spec
-  #
-  # And returns a Gem::Installer for the @user_spec that installs into Gem.user_dir
-
-  def setup_base_user_installer
-    @user_spec = quick_gem 'b' do |spec|
-      util_make_exec spec
-    end
-
-    util_build_gem @user_spec
-
-    @user_gem = @user_spec.cache_file
-
-    util_installer @user_spec, Gem.user_dir, :user
-  end
-
-  ##
-  # Sets up the base @gem, builds it and returns an installer for it.
-  #
-  def util_setup_installer(&block)
-    @gem = setup_base_gem
-
-    util_setup_gem(&block)
-  end
-
-  ##
-  # Builds the @spec gem and returns an installer for it.  The built gem
-  # includes:
-  #
-  #   bin/executable
-  #   lib/code.rb
-  #   ext/a/mkrf_conf.rb
-
-  def util_setup_gem(ui = @ui, force = true)
-    @spec.files << File.join('lib', 'code.rb')
-    @spec.extensions << File.join('ext', 'a', 'mkrf_conf.rb')
-
-    Dir.chdir @tempdir do
-      FileUtils.mkdir_p 'bin'
-      FileUtils.mkdir_p 'lib'
-      FileUtils.mkdir_p File.join('ext', 'a')
-
-      File.open File.join('bin', 'executable'), 'w' do |f|
-        f.puts "raise 'ran executable'"
-      end
-
-      File.open File.join('lib', 'code.rb'), 'w' do |f|
-        f.puts '1'
-      end
-
-      File.open File.join('ext', 'a', 'mkrf_conf.rb'), 'w' do |f|
-        f << <<-EOF
-          File.open 'Rakefile', 'w' do |rf| rf.puts "task :default" end
-        EOF
-      end
-
-      yield @spec if block_given?
-
-      use_ui ui do
-        FileUtils.rm_f @gem
-
-        @gem = Gem::Package.build @spec
-      end
-    end
-
-    Gem::Installer.at @gem, :force => force
-  end
-
-  ##
-  # Creates an installer for +spec+ that will install into +gem_home+.  If
-  # +user+ is true a user-install will be performed.
-
-  def util_installer(spec, gem_home, user=false, force=true)
-    Gem::Installer.at(spec.cache_file,
-                       :install_dir => gem_home,
-                       :user_install => user,
-                       :force => force)
-  end
-
-  @@symlink_supported = nil
-
-  # This is needed for Windows environment without symlink support enabled (the default
-  # for non admin) to be able to skip test for features using symlinks.
-  def symlink_supported?
-    if @@symlink_supported.nil?
-      begin
-        File.symlink("", "")
-      rescue Errno::ENOENT, Errno::EEXIST
-        @@symlink_supported = true
-      rescue NotImplementedError, SystemCallError
-        @@symlink_supported = false
-      end
-    end
-    @@symlink_supported
-  end
-end
diff --git a/lib/rubygems/local_remote_options.rb b/lib/rubygems/local_remote_options.rb
index 2d0509e..0b8b0ee 100644
--- a/lib/rubygems/local_remote_options.rb
+++ b/lib/rubygems/local_remote_options.rb
@@ -6,7 +6,7 @@
 #++
 
 require 'uri'
-require 'rubygems'
+require_relative '../rubygems'
 
 ##
 # Mixin methods for local and remote Gem::Command options.
@@ -14,14 +14,14 @@ require 'rubygems'
 module Gem::LocalRemoteOptions
 
   ##
-  # Allows OptionParser to handle HTTP URIs.
+  # Allows Gem::OptionParser to handle HTTP URIs.
 
   def accept_uri_http
-    OptionParser.accept URI::HTTP do |value|
+    Gem::OptionParser.accept URI::HTTP do |value|
       begin
         uri = URI.parse value
       rescue URI::InvalidURIError
-        raise OptionParser::InvalidArgument, value
+        raise Gem::OptionParser::InvalidArgument, value
       end
 
       valid_uri_schemes = ["http", "https", "file", "s3"]
diff --git a/lib/rubygems/mock_gem_ui.rb b/lib/rubygems/mock_gem_ui.rb
index ec244fb..914ecb9 100644
--- a/lib/rubygems/mock_gem_ui.rb
+++ b/lib/rubygems/mock_gem_ui.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require 'rubygems/user_interaction'
+require_relative 'user_interaction'
 
 ##
 # This Gem::StreamUI subclass records input and output to StringIO for
diff --git a/lib/rubygems/name_tuple.rb b/lib/rubygems/name_tuple.rb
index 3d0afa3..c732d7f 100644
--- a/lib/rubygems/name_tuple.rb
+++ b/lib/rubygems/name_tuple.rb
@@ -89,9 +89,8 @@ class Gem::NameTuple
   alias to_s inspect # :nodoc:
 
   def <=>(other)
-    [@name, @version, @platform == Gem::Platform::RUBY ? -1 : 1] <=>
-      [other.name, other.version,
-       other.platform == Gem::Platform::RUBY ? -1 : 1]
+    [@name, @version, Gem::Platform.sort_priority(@platform)] <=>
+      [other.name, other.version, Gem::Platform.sort_priority(other.platform)]
   end
 
   include Comparable
diff --git a/lib/rubygems/optparse.rb b/lib/rubygems/optparse.rb
new file mode 100644
index 0000000..65be9f6
--- /dev/null
+++ b/lib/rubygems/optparse.rb
@@ -0,0 +1,3 @@
+# frozen_string_literal: true
+
+require_relative 'optparse/lib/optparse'
diff --git a/lib/rubygems/optparse/.document b/lib/rubygems/optparse/.document
new file mode 100644
index 0000000..0c43bbd
--- /dev/null
+++ b/lib/rubygems/optparse/.document
@@ -0,0 +1 @@
+# Vendored files do not need to be documented
diff --git a/lib/rubygems/optparse/lib/optionparser.rb b/lib/rubygems/optparse/lib/optionparser.rb
new file mode 100644
index 0000000..4b9b40d
--- /dev/null
+++ b/lib/rubygems/optparse/lib/optionparser.rb
@@ -0,0 +1,2 @@
+# frozen_string_literal: false
+require_relative 'optparse'
diff --git a/lib/rubygems/optparse/lib/optparse.rb b/lib/rubygems/optparse/lib/optparse.rb
new file mode 100644
index 0000000..e4b1c61
--- /dev/null
+++ b/lib/rubygems/optparse/lib/optparse.rb
@@ -0,0 +1,2230 @@
+# frozen_string_literal: true
+#
+# optparse.rb - command-line option analysis with the Gem::OptionParser class.
+#
+# Author:: Nobu Nakada
+# Documentation:: Nobu Nakada and Gavin Sinclair.
+#
+# See Gem::OptionParser for documentation.
+#
+
+
+#--
+# == Developer Documentation (not for RDoc output)
+#
+# === Class tree
+#
+# - Gem::OptionParser:: front end
+# - Gem::OptionParser::Switch:: each switches
+# - Gem::OptionParser::List:: options list
+# - Gem::OptionParser::ParseError:: errors on parsing
+#   - Gem::OptionParser::AmbiguousOption
+#   - Gem::OptionParser::NeedlessArgument
+#   - Gem::OptionParser::MissingArgument
+#   - Gem::OptionParser::InvalidOption
+#   - Gem::OptionParser::InvalidArgument
+#     - Gem::OptionParser::AmbiguousArgument
+#
+# === Object relationship diagram
+#
+#   +--------------+
+#   | Gem::OptionParser |<>-----+
+#   +--------------+       |                      +--------+
+#                          |                    ,-| Switch |
+#        on_head -------->+---------------+    /  +--------+
+#        accept/reject -->| List          |<|>-
+#                         |               |<|>-  +----------+
+#        on ------------->+---------------+    `-| argument |
+#                           :           :        |  class   |
+#                         +---------------+      |==========|
+#        on_tail -------->|               |      |pattern   |
+#                         +---------------+      |----------|
+#   Gem::OptionParser.accept ->| DefaultList   |      |converter |
+#                reject   |(shared between|      +----------+
+#                         | all instances)|
+#                         +---------------+
+#
+#++
+#
+# == Gem::OptionParser
+#
+# === New to \Gem::OptionParser?
+#
+# See the {Tutorial}[./doc/optparse/tutorial_rdoc.html].
+#
+# === Introduction
+#
+# Gem::OptionParser is a class for command-line option analysis.  It is much more
+# advanced, yet also easier to use, than GetoptLong, and is a more Ruby-oriented
+# solution.
+#
+# === Features
+#
+# 1. The argument specification and the code to handle it are written in the
+#    same place.
+# 2. It can output an option summary; you don't need to maintain this string
+#    separately.
+# 3. Optional and mandatory arguments are specified very gracefully.
+# 4. Arguments can be automatically converted to a specified class.
+# 5. Arguments can be restricted to a certain set.
+#
+# All of these features are demonstrated in the examples below.  See
+# #make_switch for full documentation.
+#
+# === Minimal example
+#
+#   require 'rubygems/optparse/lib/optparse'
+#
+#   options = {}
+#   Gem::OptionParser.new do |parser|
+#     parser.banner = "Usage: example.rb [options]"
+#
+#     parser.on("-v", "--[no-]verbose", "Run verbosely") do |v|
+#       options[:verbose] = v
+#     end
+#   end.parse!
+#
+#   p options
+#   p ARGV
+#
+# === Generating Help
+#
+# Gem::OptionParser can be used to automatically generate help for the commands you
+# write:
+#
+#   require 'rubygems/optparse/lib/optparse'
+#
+#   Options = Struct.new(:name)
+#
+#   class Parser
+#     def self.parse(options)
+#       args = Options.new("world")
+#
+#       opt_parser = Gem::OptionParser.new do |parser|
+#         parser.banner = "Usage: example.rb [options]"
+#
+#         parser.on("-nNAME", "--name=NAME", "Name to say hello to") do |n|
+#           args.name = n
+#         end
+#
+#         parser.on("-h", "--help", "Prints this help") do
+#           puts parser
+#           exit
+#         end
+#       end
+#
+#       opt_parser.parse!(options)
+#       return args
+#     end
+#   end
+#   options = Parser.parse %w[--help]
+#
+#   #=>
+#      # Usage: example.rb [options]
+#      #     -n, --name=NAME                  Name to say hello to
+#      #     -h, --help                       Prints this help
+#
+# === Required Arguments
+#
+# For options that require an argument, option specification strings may include an
+# option name in all caps. If an option is used without the required argument,
+# an exception will be raised.
+#
+#   require 'rubygems/optparse/lib/optparse'
+#
+#   options = {}
+#   Gem::OptionParser.new do |parser|
+#     parser.on("-r", "--require LIBRARY",
+#               "Require the LIBRARY before executing your script") do |lib|
+#       puts "You required #{lib}!"
+#     end
+#   end.parse!
+#
+# Used:
+#
+#   $ ruby optparse-test.rb -r
+#   optparse-test.rb:9:in `<main>': missing argument: -r (Gem::OptionParser::MissingArgument)
+#   $ ruby optparse-test.rb -r my-library
+#   You required my-library!
+#
+# === Type Coercion
+#
+# Gem::OptionParser supports the ability to coerce command line arguments
+# into objects for us.
+#
+# Gem::OptionParser comes with a few ready-to-use kinds of  type
+# coercion. They are:
+#
+# - Date  -- Anything accepted by +Date.parse+
+# - DateTime -- Anything accepted by +DateTime.parse+
+# - Time -- Anything accepted by +Time.httpdate+ or +Time.parse+
+# - URI  -- Anything accepted by +URI.parse+
+# - Shellwords -- Anything accepted by +Shellwords.shellwords+
+# - String -- Any non-empty string
+# - Integer -- Any integer. Will convert octal. (e.g. 124, -3, 040)
+# - Float -- Any float. (e.g. 10, 3.14, -100E+13)
+# - Numeric -- Any integer, float, or rational (1, 3.4, 1/3)
+# - DecimalInteger -- Like +Integer+, but no octal format.
+# - OctalInteger -- Like +Integer+, but no decimal format.
+# - DecimalNumeric -- Decimal integer or float.
+# - TrueClass --  Accepts '+, yes, true, -, no, false' and
+#   defaults as +true+
+# - FalseClass -- Same as +TrueClass+, but defaults to +false+
+# - Array -- Strings separated by ',' (e.g. 1,2,3)
+# - Regexp -- Regular expressions. Also includes options.
+#
+# We can also add our own coercions, which we will cover below.
+#
+# ==== Using Built-in Conversions
+#
+# As an example, the built-in +Time+ conversion is used. The other built-in
+# conversions behave in the same way.
+# Gem::OptionParser will attempt to parse the argument
+# as a +Time+. If it succeeds, that time will be passed to the
+# handler block. Otherwise, an exception will be raised.
+#
+#   require 'rubygems/optparse/lib/optparse'
+#   require 'rubygems/optparse/lib/optparse/time'
+#   Gem::OptionParser.new do |parser|
+#     parser.on("-t", "--time [TIME]", Time, "Begin execution at given time") do |time|
+#       p time
+#     end
+#   end.parse!
+#
+# Used:
+#
+#   $ ruby optparse-test.rb  -t nonsense
+#   ... invalid argument: -t nonsense (Gem::OptionParser::InvalidArgument)
+#   $ ruby optparse-test.rb  -t 10-11-12
+#   2010-11-12 00:00:00 -0500
+#   $ ruby optparse-test.rb  -t 9:30
+#   2014-08-13 09:30:00 -0400
+#
+# ==== Creating Custom Conversions
+#
+# The +accept+ method on Gem::OptionParser may be used to create converters.
+# It specifies which conversion block to call whenever a class is specified.
+# The example below uses it to fetch a +User+ object before the +on+ handler receives it.
+#
+#   require 'rubygems/optparse/lib/optparse'
+#
+#   User = Struct.new(:id, :name)
+#
+#   def find_user id
+#     not_found = ->{ raise "No User Found for id #{id}" }
+#     [ User.new(1, "Sam"),
+#       User.new(2, "Gandalf") ].find(not_found) do |u|
+#       u.id == id
+#     end
+#   end
+#
+#   op = Gem::OptionParser.new
+#   op.accept(User) do |user_id|
+#     find_user user_id.to_i
+#   end
+#
+#   op.on("--user ID", User) do |user|
+#     puts user
+#   end
+#
+#   op.parse!
+#
+# Used:
+#
+#   $ ruby optparse-test.rb --user 1
+#   #<struct User id=1, name="Sam">
+#   $ ruby optparse-test.rb --user 2
+#   #<struct User id=2, name="Gandalf">
+#   $ ruby optparse-test.rb --user 3
+#   optparse-test.rb:15:in `block in find_user': No User Found for id 3 (RuntimeError)
+#
+# === Store options to a Hash
+#
+# The +into+ option of +order+, +parse+ and so on methods stores command line options into a Hash.
+#
+#   require 'rubygems/optparse/lib/optparse'
+#
+#   options = {}
+#   Gem::OptionParser.new do |parser|
+#     parser.on('-a')
+#     parser.on('-b NUM', Integer)
+#     parser.on('-v', '--verbose')
+#   end.parse!(into: options)
+#
+#   p options
+#
+# Used:
+#
+#   $ ruby optparse-test.rb -a
+#   {:a=>true}
+#   $ ruby optparse-test.rb -a -v
+#   {:a=>true, :verbose=>true}
+#   $ ruby optparse-test.rb -a -b 100
+#   {:a=>true, :b=>100}
+#
+# === Complete example
+#
+# The following example is a complete Ruby program.  You can run it and see the
+# effect of specifying various options.  This is probably the best way to learn
+# the features of +optparse+.
+#
+#   require 'rubygems/optparse/lib/optparse'
+#   require 'rubygems/optparse/lib/optparse/time'
+#   require 'ostruct'
+#   require 'pp'
+#
+#   class OptparseExample
+#     Version = '1.0.0'
+#
+#     CODES = %w[iso-2022-jp shift_jis euc-jp utf8 binary]
+#     CODE_ALIASES = { "jis" => "iso-2022-jp", "sjis" => "shift_jis" }
+#
+#     class ScriptOptions
+#       attr_accessor :library, :inplace, :encoding, :transfer_type,
+#                     :verbose, :extension, :delay, :time, :record_separator,
+#                     :list
+#
+#       def initialize
+#         self.library = []
+#         self.inplace = false
+#         self.encoding = "utf8"
+#         self.transfer_type = :auto
+#         self.verbose = false
+#       end
+#
+#       def define_options(parser)
+#         parser.banner = "Usage: example.rb [options]"
+#         parser.separator ""
+#         parser.separator "Specific options:"
+#
+#         # add additional options
+#         perform_inplace_option(parser)
+#         delay_execution_option(parser)
+#         execute_at_time_option(parser)
+#         specify_record_separator_option(parser)
+#         list_example_option(parser)
+#         specify_encoding_option(parser)
+#         optional_option_argument_with_keyword_completion_option(parser)
+#         boolean_verbose_option(parser)
+#
+#         parser.separator ""
+#         parser.separator "Common options:"
+#         # No argument, shows at tail.  This will print an options summary.
+#         # Try it and see!
+#         parser.on_tail("-h", "--help", "Show this message") do
+#           puts parser
+#           exit
+#         end
+#         # Another typical switch to print the version.
+#         parser.on_tail("--version", "Show version") do
+#           puts Version
+#           exit
+#         end
+#       end
+#
+#       def perform_inplace_option(parser)
+#         # Specifies an optional option argument
+#         parser.on("-i", "--inplace [EXTENSION]",
+#                   "Edit ARGV files in place",
+#                   "(make backup if EXTENSION supplied)") do |ext|
+#           self.inplace = true
+#           self.extension = ext || ''
+#           self.extension.sub!(/\A\.?(?=.)/, ".")  # Ensure extension begins with dot.
+#         end
+#       end
+#
+#       def delay_execution_option(parser)
+#         # Cast 'delay' argument to a Float.
+#         parser.on("--delay N", Float, "Delay N seconds before executing") do |n|
+#           self.delay = n
+#         end
+#       end
+#
+#       def execute_at_time_option(parser)
+#         # Cast 'time' argument to a Time object.
+#         parser.on("-t", "--time [TIME]", Time, "Begin execution at given time") do |time|
+#           self.time = time
+#         end
+#       end
+#
+#       def specify_record_separator_option(parser)
+#         # Cast to octal integer.
+#         parser.on("-F", "--irs [OCTAL]", Gem::OptionParser::OctalInteger,
+#                   "Specify record separator (default \\0)") do |rs|
+#           self.record_separator = rs
+#         end
+#       end
+#
+#       def list_example_option(parser)
+#         # List of arguments.
+#         parser.on("--list x,y,z", Array, "Example 'list' of arguments") do |list|
+#           self.list = list
+#         end
+#       end
+#
+#       def specify_encoding_option(parser)
+#         # Keyword completion.  We are specifying a specific set of arguments (CODES
+#         # and CODE_ALIASES - notice the latter is a Hash), and the user may provide
+#         # the shortest unambiguous text.
+#         code_list = (CODE_ALIASES.keys + CODES).join(', ')
+#         parser.on("--code CODE", CODES, CODE_ALIASES, "Select encoding",
+#                   "(#{code_list})") do |encoding|
+#           self.encoding = encoding
+#         end
+#       end
+#
+#       def optional_option_argument_with_keyword_completion_option(parser)
+#         # Optional '--type' option argument with keyword completion.
+#         parser.on("--type [TYPE]", [:text, :binary, :auto],
+#                   "Select transfer type (text, binary, auto)") do |t|
+#           self.transfer_type = t
+#         end
+#       end
+#
+#       def boolean_verbose_option(parser)
+#         # Boolean switch.
+#         parser.on("-v", "--[no-]verbose", "Run verbosely") do |v|
+#           self.verbose = v
+#         end
+#       end
+#     end
+#
+#     #
+#     # Return a structure describing the options.
+#     #
+#     def parse(args)
+#       # The options specified on the command line will be collected in
+#       # *options*.
+#
+#       @options = ScriptOptions.new
+#       @args = Gem::OptionParser.new do |parser|
+#         @options.define_options(parser)
+#         parser.parse!(args)
+#       end
+#       @options
+#     end
+#
+#     attr_reader :parser, :options
+#   end  # class OptparseExample
+#
+#   example = OptparseExample.new
+#   options = example.parse(ARGV)
+#   pp options # example.options
+#   pp ARGV
+#
+# === Shell Completion
+#
+# For modern shells (e.g. bash, zsh, etc.), you can use shell
+# completion for command line options.
+#
+# === Further documentation
+#
+# The above examples, along with the accompanying
+# {Tutorial}[./doc/optparse/tutorial_rdoc.html],
+# should be enough to learn how to use this class.
+# If you have any questions, file a ticket at http://bugs.ruby-lang.org.
+#
+class Gem::OptionParser
+  Gem::OptionParser::Version = "0.2.0"
+
+  # :stopdoc:
+  NoArgument = [NO_ARGUMENT = :NONE, nil].freeze
+  RequiredArgument = [REQUIRED_ARGUMENT = :REQUIRED, true].freeze
+  OptionalArgument = [OPTIONAL_ARGUMENT = :OPTIONAL, false].freeze
+  # :startdoc:
+
+  #
+  # Keyword completion module.  This allows partial arguments to be specified
+  # and resolved against a list of acceptable values.
+  #
+  module Completion
+    def self.regexp(key, icase)
+      Regexp.new('\A' + Regexp.quote(key).gsub(/\w+\b/, '\&\w*'), icase)
+    end
+
+    def self.candidate(key, icase = false, pat = nil, &block)
+      pat ||= Completion.regexp(key, icase)
+      candidates = []
+      block.call do |k, *v|
+        (if Regexp === k
+           kn = ""
+           k === key
+         else
+           kn = defined?(k.id2name) ? k.id2name : k
+           pat === kn
+         end) or next
+        v << k if v.empty?
+        candidates << [k, v, kn]
+      end
+      candidates
+    end
+
+    def candidate(key, icase = false, pat = nil)
+      Completion.candidate(key, icase, pat, &method(:each))
+    end
+
+    public
+    def complete(key, icase = false, pat = nil)
+      candidates = candidate(key, icase, pat, &method(:each)).sort_by {|k, v, kn| kn.size}
+      if candidates.size == 1
+        canon, sw, * = candidates[0]
+      elsif candidates.size > 1
+        canon, sw, cn = candidates.shift
+        candidates.each do |k, v, kn|
+          next if sw == v
+          if String === cn and String === kn
+            if cn.rindex(kn, 0)
+              canon, sw, cn = k, v, kn
+              next
+            elsif kn.rindex(cn, 0)
+              next
+            end
+          end
+          throw :ambiguous, key
+        end
+      end
+      if canon
+        block_given? or return key, *sw
+        yield(key, *sw)
+      end
+    end
+
+    def convert(opt = nil, val = nil, *)
+      val
+    end
+  end
+
+
+  #
+  # Map from option/keyword string to object with completion.
+  #
+  class OptionMap < Hash
+    include Completion
+  end
+
+
+  #
+  # Individual switch class.  Not important to the user.
+  #
+  # Defined within Switch are several Switch-derived classes: NoArgument,
+  # RequiredArgument, etc.
+  #
+  class Switch
+    attr_reader :pattern, :conv, :short, :long, :arg, :desc, :block
+
+    #
+    # Guesses argument style from +arg+.  Returns corresponding
+    # Gem::OptionParser::Switch class (OptionalArgument, etc.).
+    #
+    def self.guess(arg)
+      case arg
+      when ""
+        t = self
+      when /\A=?\[/
+        t = Switch::OptionalArgument
+      when /\A\s+\[/
+        t = Switch::PlacedArgument
+      else
+        t = Switch::RequiredArgument
+      end
+      self >= t or incompatible_argument_styles(arg, t)
+      t
+    end
+
+    def self.incompatible_argument_styles(arg, t)
+      raise(ArgumentError, "#{arg}: incompatible argument styles\n  #{self}, #{t}",
+            ParseError.filter_backtrace(caller(2)))
+    end
+
+    def self.pattern
+      NilClass
+    end
+
+    def initialize(pattern = nil, conv = nil,
+                   short = nil, long = nil, arg = nil,
+                   desc = ([] if short or long), block = nil, &_block)
+      raise if Array === pattern
+      block ||= _block
+      @pattern, @conv, @short, @long, @arg, @desc, @block =
+        pattern, conv, short, long, arg, desc, block
+    end
+
+    #
+    # Parses +arg+ and returns rest of +arg+ and matched portion to the
+    # argument pattern. Yields when the pattern doesn't match substring.
+    #
+    def parse_arg(arg) # :nodoc:
+      pattern or return nil, [arg]
+      unless m = pattern.match(arg)
+        yield(InvalidArgument, arg)
+        return arg, []
+      end
+      if String === m
+        m = [s = m]
+      else
+        m = m.to_a
+        s = m[0]
+        return nil, m unless String === s
+      end
+      raise InvalidArgument, arg unless arg.rindex(s, 0)
+      return nil, m if s.length == arg.length
+      yield(InvalidArgument, arg) # didn't match whole arg
+      return arg[s.length..-1], m
+    end
+    private :parse_arg
+
+    #
+    # Parses argument, converts and returns +arg+, +block+ and result of
+    # conversion. Yields at semi-error condition instead of raising an
+    # exception.
+    #
+    def conv_arg(arg, val = []) # :nodoc:
+      if conv
+        val = conv.call(*val)
+      else
+        val = proc {|v| v}.call(*val)
+      end
+      return arg, block, val
+    end
+    private :conv_arg
+
+    #
+    # Produces the summary text. Each line of the summary is yielded to the
+    # block (without newline).
+    #
+    # +sdone+::  Already summarized short style options keyed hash.
+    # +ldone+::  Already summarized long style options keyed hash.
+    # +width+::  Width of left side (option part). In other words, the right
+    #            side (description part) starts after +width+ columns.
+    # +max+::    Maximum width of left side -> the options are filled within
+    #            +max+ columns.
+    # +indent+:: Prefix string indents all summarized lines.
+    #
+    def summarize(sdone = {}, ldone = {}, width = 1, max = width - 1, indent = "")
+      sopts, lopts = [], [], nil
+      @short.each {|s| sdone.fetch(s) {sopts << s}; sdone[s] = true} if @short
+      @long.each {|s| ldone.fetch(s) {lopts << s}; ldone[s] = true} if @long
+      return if sopts.empty? and lopts.empty? # completely hidden
+
+      left = [sopts.join(', ')]
+      right = desc.dup
+
+      while s = lopts.shift
+        l = left[-1].length + s.length
+        l += arg.length if left.size == 1 && arg
+        l < max or sopts.empty? or left << +''
+        left[-1] << (left[-1].empty? ? ' ' * 4 : ', ') << s
+      end
+
+      if arg
+        left[0] << (left[1] ? arg.sub(/\A(\[?)=/, '\1') + ',' : arg)
+      end
+      mlen = left.collect {|ss| ss.length}.max.to_i
+      while mlen > width and l = left.shift
+        mlen = left.collect {|ss| ss.length}.max.to_i if l.length == mlen
+        if l.length < width and (r = right[0]) and !r.empty?
+          l = l.to_s.ljust(width) + ' ' + r
+          right.shift
+        end
+        yield(indent + l)
+      end
+
+      while begin l = left.shift; r = right.shift; l or r end
+        l = l.to_s.ljust(width) + ' ' + r if r and !r.empty?
+        yield(indent + l)
+      end
+
+      self
+    end
+
+    def add_banner(to)  # :nodoc:
+      unless @short or @long
+        s = desc.join
+        to << " [" + s + "]..." unless s.empty?
+      end
+      to
+    end
+
+    def match_nonswitch?(str)  # :nodoc:
+      @pattern =~ str unless @short or @long
+    end
+
+    #
+    # Main name of the switch.
+    #
+    def switch_name
+      (long.first || short.first).sub(/\A-+(?:\[no-\])?/, '')
+    end
+
+    def compsys(sdone, ldone)   # :nodoc:
+      sopts, lopts = [], []
+      @short.each {|s| sdone.fetch(s) {sopts << s}; sdone[s] = true} if @short
+      @long.each {|s| ldone.fetch(s) {lopts << s}; ldone[s] = true} if @long
+      return if sopts.empty? and lopts.empty? # completely hidden
+
+      (sopts+lopts).each do |opt|
+        # "(-x -c -r)-l[left justify]"
+        if /^--\[no-\](.+)$/ =~ opt
+          o = $1
+          yield("--#{o}", desc.join(""))
+          yield("--no-#{o}", desc.join(""))
+        else
+          yield("#{opt}", desc.join(""))
+        end
+      end
+    end
+
+    #
+    # Switch that takes no arguments.
+    #
+    class NoArgument < self
+
+      #
+      # Raises an exception if any arguments given.
+      #
+      def parse(arg, argv)
+        yield(NeedlessArgument, arg) if arg
+        conv_arg(arg)
+      end
+
+      def self.incompatible_argument_styles(*)
+      end
+
+      def self.pattern
+        Object
+      end
+    end
+
+    #
+    # Switch that takes an argument.
+    #
+    class RequiredArgument < self
+
+      #
+      # Raises an exception if argument is not present.
+      #
+      def parse(arg, argv)
+        unless arg
+          raise MissingArgument if argv.empty?
+          arg = argv.shift
+        end
+        conv_arg(*parse_arg(arg, &method(:raise)))
+      end
+    end
+
+    #
+    # Switch that can omit argument.
+    #
+    class OptionalArgument < self
+
+      #
+      # Parses argument if given, or uses default value.
+      #
+      def parse(arg, argv, &error)
+        if arg
+          conv_arg(*parse_arg(arg, &error))
+        else
+          conv_arg(arg)
+        end
+      end
+    end
+
+    #
+    # Switch that takes an argument, which does not begin with '-'.
+    #
+    class PlacedArgument < self
+
+      #
+      # Returns nil if argument is not present or begins with '-'.
+      #
+      def parse(arg, argv, &error)
+        if !(val = arg) and (argv.empty? or /\A-/ =~ (val = argv[0]))
+          return nil, block, nil
+        end
+        opt = (val = parse_arg(val, &error))[1]
+        val = conv_arg(*val)
+        if opt and !arg
+          argv.shift
+        else
+          val[0] = nil
+        end
+        val
+      end
+    end
+  end
+
+  #
+  # Simple option list providing mapping from short and/or long option
+  # string to Gem::OptionParser::Switch and mapping from acceptable argument to
+  # matching pattern and converter pair. Also provides summary feature.
+  #
+  class List
+    # Map from acceptable argument types to pattern and converter pairs.
+    attr_reader :atype
+
+    # Map from short style option switches to actual switch objects.
+    attr_reader :short
+
+    # Map from long style option switches to actual switch objects.
+    attr_reader :long
+
+    # List of all switches and summary string.
+    attr_reader :list
+
+    #
+    # Just initializes all instance variables.
+    #
+    def initialize
+      @atype = {}
+      @short = OptionMap.new
+      @long = OptionMap.new
+      @list = []
+    end
+
+    #
+    # See Gem::OptionParser.accept.
+    #
+    def accept(t, pat = /.*/m, &block)
+      if pat
+        pat.respond_to?(:match) or
+          raise TypeError, "has no `match'", ParseError.filter_backtrace(caller(2))
+      else
+        pat = t if t.respond_to?(:match)
+      end
+      unless block
+        block = pat.method(:convert).to_proc if pat.respond_to?(:convert)
+      end
+      @atype[t] = [pat, block]
+    end
+
+    #
+    # See Gem::OptionParser.reject.
+    #
+    def reject(t)
+      @atype.delete(t)
+    end
+
+    #
+    # Adds +sw+ according to +sopts+, +lopts+ and +nlopts+.
+    #
+    # +sw+::     Gem::OptionParser::Switch instance to be added.
+    # +sopts+::  Short style option list.
+    # +lopts+::  Long style option list.
+    # +nlopts+:: Negated long style options list.
+    #
+    def update(sw, sopts, lopts, nsw = nil, nlopts = nil) # :nodoc:
+      sopts.each {|o| @short[o] = sw} if sopts
+      lopts.each {|o| @long[o] = sw} if lopts
+      nlopts.each {|o| @long[o] = nsw} if nsw and nlopts
+      used = @short.invert.update(@long.invert)
+      @list.delete_if {|o| Switch === o and !used[o]}
+    end
+    private :update
+
+    #
+    # Inserts +switch+ at the head of the list, and associates short, long
+    # and negated long options. Arguments are:
+    #
+    # +switch+::      Gem::OptionParser::Switch instance to be inserted.
+    # +short_opts+::  List of short style options.
+    # +long_opts+::   List of long style options.
+    # +nolong_opts+:: List of long style options with "no-" prefix.
+    #
+    #   prepend(switch, short_opts, long_opts, nolong_opts)
+    #
+    def prepend(*args)
+      update(*args)
+      @list.unshift(args[0])
+    end
+
+    #
+    # Appends +switch+ at the tail of the list, and associates short, long
+    # and negated long options. Arguments are:
+    #
+    # +switch+::      Gem::OptionParser::Switch instance to be inserted.
+    # +short_opts+::  List of short style options.
+    # +long_opts+::   List of long style options.
+    # +nolong_opts+:: List of long style options with "no-" prefix.
+    #
+    #   append(switch, short_opts, long_opts, nolong_opts)
+    #
+    def append(*args)
+      update(*args)
+      @list.push(args[0])
+    end
+
+    #
+    # Searches +key+ in +id+ list. The result is returned or yielded if a
+    # block is given. If it isn't found, nil is returned.
+    #
+    def search(id, key)
+      if list = __send__(id)
+        val = list.fetch(key) {return nil}
+        block_given? ? yield(val) : val
+      end
+    end
+
+    #
+    # Searches list +id+ for +opt+ and the optional patterns for completion
+    # +pat+. If +icase+ is true, the search is case insensitive. The result
+    # is returned or yielded if a block is given. If it isn't found, nil is
+    # returned.
+    #
+    def complete(id, opt, icase = false, *pat, &block)
+      __send__(id).complete(opt, icase, *pat, &block)
+    end
+
+    def get_candidates(id)
+      yield __send__(id).keys
+    end
+
+    #
+    # Iterates over each option, passing the option to the +block+.
+    #
+    def each_option(&block)
+      list.each(&block)
+    end
+
+    #
+    # Creates the summary table, passing each line to the +block+ (without
+    # newline). The arguments +args+ are passed along to the summarize
+    # method which is called on every option.
+    #
+    def summarize(*args, &block)
+      sum = []
+      list.reverse_each do |opt|
+        if opt.respond_to?(:summarize) # perhaps Gem::OptionParser::Switch
+          s = []
+          opt.summarize(*args) {|l| s << l}
+          sum.concat(s.reverse)
+        elsif !opt or opt.empty?
+          sum << ""
+        elsif opt.respond_to?(:each_line)
+          sum.concat([*opt.each_line].reverse)
+        else
+          sum.concat([*opt.each].reverse)
+        end
+      end
+      sum.reverse_each(&block)
+    end
+
+    def add_banner(to)  # :nodoc:
+      list.each do |opt|
+        if opt.respond_to?(:add_banner)
+          opt.add_banner(to)
+        end
+      end
+      to
+    end
+
+    def compsys(*args, &block)  # :nodoc:
+      list.each do |opt|
+        if opt.respond_to?(:compsys)
+          opt.compsys(*args, &block)
+        end
+      end
+    end
+  end
+
+  #
+  # Hash with completion search feature. See Gem::OptionParser::Completion.
+  #
+  class CompletingHash < Hash
+    include Completion
+
+    #
+    # Completion for hash key.
+    #
+    def match(key)
+      *values = fetch(key) {
+        raise AmbiguousArgument, catch(:ambiguous) {return complete(key)}
+      }
+      return key, *values
+    end
+  end
+
+  # :stopdoc:
+
+  #
+  # Enumeration of acceptable argument styles. Possible values are:
+  #
+  # NO_ARGUMENT::       The switch takes no arguments. (:NONE)
+  # REQUIRED_ARGUMENT:: The switch requires an argument. (:REQUIRED)
+  # OPTIONAL_ARGUMENT:: The switch requires an optional argument. (:OPTIONAL)
+  #
+  # Use like --switch=argument (long style) or -Xargument (short style). For
+  # short style, only portion matched to argument pattern is treated as
+  # argument.
+  #
+  ArgumentStyle = {}
+  NoArgument.each {|el| ArgumentStyle[el] = Switch::NoArgument}
+  RequiredArgument.each {|el| ArgumentStyle[el] = Switch::RequiredArgument}
+  OptionalArgument.each {|el| ArgumentStyle[el] = Switch::OptionalArgument}
+  ArgumentStyle.freeze
+
+  #
+  # Switches common used such as '--', and also provides default
+  # argument classes
+  #
+  DefaultList = List.new
+  DefaultList.short['-'] = Switch::NoArgument.new {}
+  DefaultList.long[''] = Switch::NoArgument.new {throw :terminate}
+
+
+  COMPSYS_HEADER = <<'XXX'      # :nodoc:
+
+typeset -A opt_args
+local context state line
+
+_arguments -s -S \
+XXX
+
+  def compsys(to, name = File.basename($0)) # :nodoc:
+    to << "#compdef #{name}\n"
+    to << COMPSYS_HEADER
+    visit(:compsys, {}, {}) {|o, d|
+      to << %Q[  "#{o}[#{d.gsub(/[\"\[\]]/, '\\\\\&')}]" \\\n]
+    }
+    to << "  '*:file:_files' && return 0\n"
+  end
+
+  #
+  # Default options for ARGV, which never appear in option summary.
+  #
+  Officious = {}
+
+  #
+  # --help
+  # Shows option summary.
+  #
+  Officious['help'] = proc do |parser|
+    Switch::NoArgument.new do |arg|
+      puts parser.help
+      exit
+    end
+  end
+
+  #
+  # --*-completion-bash=WORD
+  # Shows candidates for command line completion.
+  #
+  Officious['*-completion-bash'] = proc do |parser|
+    Switch::RequiredArgument.new do |arg|
+      puts parser.candidate(arg)
+      exit
+    end
+  end
+
+  #
+  # --*-completion-zsh[=NAME:FILE]
+  # Creates zsh completion file.
+  #
+  Officious['*-completion-zsh'] = proc do |parser|
+    Switch::OptionalArgument.new do |arg|
+      parser.compsys(STDOUT, arg)
+      exit
+    end
+  end
+
+  #
+  # --version
+  # Shows version string if Version is defined.
+  #
+  Officious['version'] = proc do |parser|
+    Switch::OptionalArgument.new do |pkg|
+      if pkg
+        begin
+          require 'rubygems/optparse/lib/optparse/version'
+        rescue LoadError
+        else
+          show_version(*pkg.split(/,/)) or
+            abort("#{parser.program_name}: no version found in package #{pkg}")
+          exit
+        end
+      end
+      v = parser.ver or abort("#{parser.program_name}: version unknown")
+      puts v
+      exit
+    end
+  end
+
+  # :startdoc:
+
+  #
+  # Class methods
+  #
+
+  #
+  # Initializes a new instance and evaluates the optional block in context
+  # of the instance. Arguments +args+ are passed to #new, see there for
+  # description of parameters.
+  #
+  # This method is *deprecated*, its behavior corresponds to the older #new
+  # method.
+  #
+  def self.with(*args, &block)
+    opts = new(*args)
+    opts.instance_eval(&block)
+    opts
+  end
+
+  #
+  # Returns an incremented value of +default+ according to +arg+.
+  #
+  def self.inc(arg, default = nil)
+    case arg
+    when Integer
+      arg.nonzero?
+    when nil
+      default.to_i + 1
+    end
+  end
+  def inc(*args)
+    self.class.inc(*args)
+  end
+
+  #
+  # Initializes the instance and yields itself if called with a block.
+  #
+  # +banner+:: Banner message.
+  # +width+::  Summary width.
+  # +indent+:: Summary indent.
+  #
+  def initialize(banner = nil, width = 32, indent = ' ' * 4)
+    @stack = [DefaultList, List.new, List.new]
+    @program_name = nil
+    @banner = banner
+    @summary_width = width
+    @summary_indent = indent
+    @default_argv = ARGV
+    @require_exact = false
+    add_officious
+    yield self if block_given?
+  end
+
+  def add_officious  # :nodoc:
+    list = base()
+    Officious.each do |opt, block|
+      list.long[opt] ||= block.call(self)
+    end
+  end
+
+  #
+  # Terminates option parsing. Optional parameter +arg+ is a string pushed
+  # back to be the first non-option argument.
+  #
+  def terminate(arg = nil)
+    self.class.terminate(arg)
+  end
+  def self.terminate(arg = nil)
+    throw :terminate, arg
+  end
+
+  @stack = [DefaultList]
+  def self.top() DefaultList end
+
+  #
+  # Directs to accept specified class +t+. The argument string is passed to
+  # the block in which it should be converted to the desired class.
+  #
+  # +t+::   Argument class specifier, any object including Class.
+  # +pat+:: Pattern for argument, defaults to +t+ if it responds to match.
+  #
+  #   accept(t, pat, &block)
+  #
+  def accept(*args, &blk) top.accept(*args, &blk) end
+  #
+  # See #accept.
+  #
+  def self.accept(*args, &blk) top.accept(*args, &blk) end
+
+  #
+  # Directs to reject specified class argument.
+  #
+  # +t+:: Argument class specifier, any object including Class.
+  #
+  #   reject(t)
+  #
+  def reject(*args, &blk) top.reject(*args, &blk) end
+  #
+  # See #reject.
+  #
+  def self.reject(*args, &blk) top.reject(*args, &blk) end
+
+  #
+  # Instance methods
+  #
+
+  # Heading banner preceding summary.
+  attr_writer :banner
+
+  # Program name to be emitted in error message and default banner,
+  # defaults to $0.
+  attr_writer :program_name
+
+  # Width for option list portion of summary. Must be Numeric.
+  attr_accessor :summary_width
+
+  # Indentation for summary. Must be String (or have + String method).
+  attr_accessor :summary_indent
+
+  # Strings to be parsed in default.
+  attr_accessor :default_argv
+
+  # Whether to require that options match exactly (disallows providing
+  # abbreviated long option as short option).
+  attr_accessor :require_exact
+
+  #
+  # Heading banner preceding summary.
+  #
+  def banner
+    unless @banner
+      @banner = +"Usage: #{program_name} [options]"
+      visit(:add_banner, @banner)
+    end
+    @banner
+  end
+
+  #
+  # Program name to be emitted in error message and default banner, defaults
+  # to $0.
+  #
+  def program_name
+    @program_name || File.basename($0, '.*')
+  end
+
+  # for experimental cascading :-)
+  alias set_banner banner=
+  alias set_program_name program_name=
+  alias set_summary_width summary_width=
+  alias set_summary_indent summary_indent=
+
+  # Version
+  attr_writer :version
+  # Release code
+  attr_writer :release
+
+  #
+  # Version
+  #
+  def version
+    (defined?(@version) && @version) || (defined?(::Version) && ::Version)
+  end
+
+  #
+  # Release code
+  #
+  def release
+    (defined?(@release) && @release) || (defined?(::Release) && ::Release) || (defined?(::RELEASE) && ::RELEASE)
+  end
+
+  #
+  # Returns version string from program_name, version and release.
+  #
+  def ver
+    if v = version
+      str = +"#{program_name} #{[v].join('.')}"
+      str << " (#{v})" if v = release
+      str
+    end
+  end
+
+  def warn(mesg = $!)
+    super("#{program_name}: #{mesg}")
+  end
+
+  def abort(mesg = $!)
+    super("#{program_name}: #{mesg}")
+  end
+
+  #
+  # Subject of #on / #on_head, #accept / #reject
+  #
+  def top
+    @stack[-1]
+  end
+
+  #
+  # Subject of #on_tail.
+  #
+  def base
+    @stack[1]
+  end
+
+  #
+  # Pushes a new List.
+  #
+  def new
+    @stack.push(List.new)
+    if block_given?
+      yield self
+    else
+      self
+    end
+  end
+
+  #
+  # Removes the last List.
+  #
+  def remove
+    @stack.pop
+  end
+
+  #
+  # Puts option summary into +to+ and returns +to+. Yields each line if
+  # a block is given.
+  #
+  # +to+:: Output destination, which must have method <<. Defaults to [].
+  # +width+:: Width of left side, defaults to @summary_width.
+  # +max+:: Maximum length allowed for left side, defaults to +width+ - 1.
+  # +indent+:: Indentation, defaults to @summary_indent.
+  #
+  def summarize(to = [], width = @summary_width, max = width - 1, indent = @summary_indent, &blk)
+    nl = "\n"
+    blk ||= proc {|l| to << (l.index(nl, -1) ? l : l + nl)}
+    visit(:summarize, {}, {}, width, max, indent, &blk)
+    to
+  end
+
+  #
+  # Returns option summary string.
+  #
+  def help; summarize("#{banner}".sub(/\n?\z/, "\n")) end
+  alias to_s help
+
+  #
+  # Returns option summary list.
+  #
+  def to_a; summarize("#{banner}".split(/^/)) end
+
+  #
+  # Checks if an argument is given twice, in which case an ArgumentError is
+  # raised. Called from Gem::OptionParser#switch only.
+  #
+  # +obj+:: New argument.
+  # +prv+:: Previously specified argument.
+  # +msg+:: Exception message.
+  #
+  def notwice(obj, prv, msg) # :nodoc:
+    unless !prv or prv == obj
+      raise(ArgumentError, "argument #{msg} given twice: #{obj}",
+            ParseError.filter_backtrace(caller(2)))
+    end
+    obj
+  end
+  private :notwice
+
+  SPLAT_PROC = proc {|*a| a.length <= 1 ? a.first : a} # :nodoc:
+
+  # :call-seq:
+  #   make_switch(params, block = nil)
+  #
+  # :include: ../doc/optparse/creates_option.rdoc
+  #
+  def make_switch(opts, block = nil)
+    short, long, nolong, style, pattern, conv, not_pattern, not_conv, not_style = [], [], []
+    ldesc, sdesc, desc, arg = [], [], []
+    default_style = Switch::NoArgument
+    default_pattern = nil
+    klass = nil
+    q, a = nil
+    has_arg = false
+
+    opts.each do |o|
+      # argument class
+      next if search(:atype, o) do |pat, c|
+        klass = notwice(o, klass, 'type')
+        if not_style and not_style != Switch::NoArgument
+          not_pattern, not_conv = pat, c
+        else
+          default_pattern, conv = pat, c
+        end
+      end
+
+      # directly specified pattern(any object possible to match)
+      if (!(String === o || Symbol === o)) and o.respond_to?(:match)
+        pattern = notwice(o, pattern, 'pattern')
+        if pattern.respond_to?(:convert)
+          conv = pattern.method(:convert).to_proc
+        else
+          conv = SPLAT_PROC
+        end
+        next
+      end
+
+      # anything others
+      case o
+      when Proc, Method
+        block = notwice(o, block, 'block')
+      when Array, Hash
+        case pattern
+        when CompletingHash
+        when nil
+          pattern = CompletingHash.new
+          conv = pattern.method(:convert).to_proc if pattern.respond_to?(:convert)
+        else
+          raise ArgumentError, "argument pattern given twice"
+        end
+        o.each {|pat, *v| pattern[pat] = v.fetch(0) {pat}}
+      when Module
+        raise ArgumentError, "unsupported argument type: #{o}", ParseError.filter_backtrace(caller(4))
+      when *ArgumentStyle.keys
+        style = notwice(ArgumentStyle[o], style, 'style')
+      when /^--no-([^\[\]=\s]*)(.+)?/
+        q, a = $1, $2
+        o = notwice(a ? Object : TrueClass, klass, 'type')
+        not_pattern, not_conv = search(:atype, o) unless not_style
+        not_style = (not_style || default_style).guess(arg = a) if a
+        default_style = Switch::NoArgument
+        default_pattern, conv = search(:atype, FalseClass) unless default_pattern
+        ldesc << "--no-#{q}"
+        (q = q.downcase).tr!('_', '-')
+        long << "no-#{q}"
+        nolong << q
+      when /^--\[no-\]([^\[\]=\s]*)(.+)?/
+        q, a = $1, $2
+        o = notwice(a ? Object : TrueClass, klass, 'type')
+        if a
+          default_style = default_style.guess(arg = a)
+          default_pattern, conv = search(:atype, o) unless default_pattern
+        end
+        ldesc << "--[no-]#{q}"
+        (o = q.downcase).tr!('_', '-')
+        long << o
+        not_pattern, not_conv = search(:atype, FalseClass) unless not_style
+        not_style = Switch::NoArgument
+        nolong << "no-#{o}"
+      when /^--([^\[\]=\s]*)(.+)?/
+        q, a = $1, $2
+        if a
+          o = notwice(NilClass, klass, 'type')
+          default_style = default_style.guess(arg = a)
+          default_pattern, conv = search(:atype, o) unless default_pattern
+        end
+        ldesc << "--#{q}"
+        (o = q.downcase).tr!('_', '-')
+        long << o
+      when /^-(\[\^?\]?(?:[^\\\]]|\\.)*\])(.+)?/
+        q, a = $1, $2
+        o = notwice(Object, klass, 'type')
+        if a
+          default_style = default_style.guess(arg = a)
+          default_pattern, conv = search(:atype, o) unless default_pattern
+        else
+          has_arg = true
+        end
+        sdesc << "-#{q}"
+        short << Regexp.new(q)
+      when /^-(.)(.+)?/
+        q, a = $1, $2
+        if a
+          o = notwice(NilClass, klass, 'type')
+          default_style = default_style.guess(arg = a)
+          default_pattern, conv = search(:atype, o) unless default_pattern
+        end
+        sdesc << "-#{q}"
+        short << q
+      when /^=/
+        style = notwice(default_style.guess(arg = o), style, 'style')
+        default_pattern, conv = search(:atype, Object) unless default_pattern
+      else
+        desc.push(o)
+      end
+    end
+
+    default_pattern, conv = search(:atype, default_style.pattern) unless default_pattern
+    if !(short.empty? and long.empty?)
+      if has_arg and default_style == Switch::NoArgument
+        default_style = Switch::RequiredArgument
+      end
+      s = (style || default_style).new(pattern || default_pattern,
+                                       conv, sdesc, ldesc, arg, desc, block)
+    elsif !block
+      if style or pattern
+        raise ArgumentError, "no switch given", ParseError.filter_backtrace(caller)
+      end
+      s = desc
+    else
+      short << pattern
+      s = (style || default_style).new(pattern,
+                                       conv, nil, nil, arg, desc, block)
+    end
+    return s, short, long,
+      (not_style.new(not_pattern, not_conv, sdesc, ldesc, nil, desc, block) if not_style),
+      nolong
+  end
+
+  # :call-seq:
+  #   define(*params, &block)
+  #
+  # :include: ../doc/optparse/creates_option.rdoc
+  #
+  def define(*opts, &block)
+    top.append(*(sw = make_switch(opts, block)))
+    sw[0]
+  end
+
+  # :call-seq:
+  #   on(*params, &block)
+  #
+  # :include: ../doc/optparse/creates_option.rdoc
+  #
+  def on(*opts, &block)
+    define(*opts, &block)
+    self
+  end
+  alias def_option define
+
+  # :call-seq:
+  #   define_head(*params, &block)
+  #
+  # :include: ../doc/optparse/creates_option.rdoc
+  #
+  def define_head(*opts, &block)
+    top.prepend(*(sw = make_switch(opts, block)))
+    sw[0]
+  end
+
+  # :call-seq:
+  #   on_head(*params, &block)
+  #
+  # :include: ../doc/optparse/creates_option.rdoc
+  #
+  # The new option is added at the head of the summary.
+  #
+  def on_head(*opts, &block)
+    define_head(*opts, &block)
+    self
+  end
+  alias def_head_option define_head
+
+  # :call-seq:
+  #   define_tail(*params, &block)
+  #
+  # :include: ../doc/optparse/creates_option.rdoc
+  #
+  def define_tail(*opts, &block)
+    base.append(*(sw = make_switch(opts, block)))
+    sw[0]
+  end
+
+  #
+  # :call-seq:
+  #   on_tail(*params, &block)
+  #
+  # :include: ../doc/optparse/creates_option.rdoc
+  #
+  # The new option is added at the tail of the summary.
+  #
+  def on_tail(*opts, &block)
+    define_tail(*opts, &block)
+    self
+  end
+  alias def_tail_option define_tail
+
+  #
+  # Add separator in summary.
+  #
+  def separator(string)
+    top.append(string, nil, nil)
+  end
+
+  #
+  # Parses command line arguments +argv+ in order. When a block is given,
+  # each non-option argument is yielded. When optional +into+ keyword
+  # argument is provided, the parsed option values are stored there via
+  # <code>[]=</code> method (so it can be Hash, or OpenStruct, or other
+  # similar object).
+  #
+  # Returns the rest of +argv+ left unparsed.
+  #
+  def order(*argv, into: nil, &nonopt)
+    argv = argv[0].dup if argv.size == 1 and Array === argv[0]
+    order!(argv, into: into, &nonopt)
+  end
+
+  #
+  # Same as #order, but removes switches destructively.
+  # Non-option arguments remain in +argv+.
+  #
+  def order!(argv = default_argv, into: nil, &nonopt)
+    setter = ->(name, val) {into[name.to_sym] = val} if into
+    parse_in_order(argv, setter, &nonopt)
+  end
+
+  def parse_in_order(argv = default_argv, setter = nil, &nonopt)  # :nodoc:
+    opt, arg, val, rest = nil
+    nonopt ||= proc {|a| throw :terminate, a}
+    argv.unshift(arg) if arg = catch(:terminate) {
+      while arg = argv.shift
+        case arg
+        # long option
+        when /\A--([^=]*)(?:=(.*))?/m
+          opt, rest = $1, $2
+          opt.tr!('_', '-')
+          begin
+            sw, = complete(:long, opt, true)
+            if require_exact && !sw.long.include?(arg)
+              raise InvalidOption, arg
+            end
+          rescue ParseError
+            raise $!.set_option(arg, true)
+          end
+          begin
+            opt, cb, val = sw.parse(rest, argv) {|*exc| raise(*exc)}
+            val = cb.call(val) if cb
+            setter.call(sw.switch_name, val) if setter
+          rescue ParseError
+            raise $!.set_option(arg, rest)
+          end
+
+        # short option
+        when /\A-(.)((=).*|.+)?/m
+          eq, rest, opt = $3, $2, $1
+          has_arg, val = eq, rest
+          begin
+            sw, = search(:short, opt)
+            unless sw
+              begin
+                sw, = complete(:short, opt)
+                # short option matched.
+                val = arg.delete_prefix('-')
+                has_arg = true
+              rescue InvalidOption
+                raise if require_exact
+                # if no short options match, try completion with long
+                # options.
+                sw, = complete(:long, opt)
+                eq ||= !rest
+              end
+            end
+          rescue ParseError
+            raise $!.set_option(arg, true)
+          end
+          begin
+            opt, cb, val = sw.parse(val, argv) {|*exc| raise(*exc) if eq}
+          rescue ParseError
+            raise $!.set_option(arg, arg.length > 2)
+          else
+            raise InvalidOption, arg if has_arg and !eq and arg == "-#{opt}"
+          end
+          begin
+            argv.unshift(opt) if opt and (!rest or (opt = opt.sub(/\A-*/, '-')) != '-')
+            val = cb.call(val) if cb
+            setter.call(sw.switch_name, val) if setter
+          rescue ParseError
+            raise $!.set_option(arg, arg.length > 2)
+          end
+
+        # non-option argument
+        else
+          catch(:prune) do
+            visit(:each_option) do |sw0|
+              sw = sw0
+              sw.block.call(arg) if Switch === sw and sw.match_nonswitch?(arg)
+            end
+            nonopt.call(arg)
+          end
+        end
+      end
+
+      nil
+    }
+
+    visit(:search, :short, nil) {|sw| sw.block.call(*argv) if !sw.pattern}
+
+    argv
+  end
+  private :parse_in_order
+
+  #
+  # Parses command line arguments +argv+ in permutation mode and returns
+  # list of non-option arguments. When optional +into+ keyword
+  # argument is provided, the parsed option values are stored there via
+  # <code>[]=</code> method (so it can be Hash, or OpenStruct, or other
+  # similar object).
+  #
+  def permute(*argv, into: nil)
+    argv = argv[0].dup if argv.size == 1 and Array === argv[0]
+    permute!(argv, into: into)
+  end
+
+  #
+  # Same as #permute, but removes switches destructively.
+  # Non-option arguments remain in +argv+.
+  #
+  def permute!(argv = default_argv, into: nil)
+    nonopts = []
+    order!(argv, into: into, &nonopts.method(:<<))
+    argv[0, 0] = nonopts
+    argv
+  end
+
+  #
+  # Parses command line arguments +argv+ in order when environment variable
+  # POSIXLY_CORRECT is set, and in permutation mode otherwise.
+  # When optional +into+ keyword argument is provided, the parsed option
+  # values are stored there via <code>[]=</code> method (so it can be Hash,
+  # or OpenStruct, or other similar object).
+  #
+  def parse(*argv, into: nil)
+    argv = argv[0].dup if argv.size == 1 and Array === argv[0]
+    parse!(argv, into: into)
+  end
+
+  #
+  # Same as #parse, but removes switches destructively.
+  # Non-option arguments remain in +argv+.
+  #
+  def parse!(argv = default_argv, into: nil)
+    if ENV.include?('POSIXLY_CORRECT')
+      order!(argv, into: into)
+    else
+      permute!(argv, into: into)
+    end
+  end
+
+  #
+  # Wrapper method for getopts.rb.
+  #
+  #   params = ARGV.getopts("ab:", "foo", "bar:", "zot:Z;zot option")
+  #   # params["a"] = true   # -a
+  #   # params["b"] = "1"    # -b1
+  #   # params["foo"] = "1"  # --foo
+  #   # params["bar"] = "x"  # --bar x
+  #   # params["zot"] = "z"  # --zot Z
+  #
+  def getopts(*args)
+    argv = Array === args.first ? args.shift : default_argv
+    single_options, *long_options = *args
+
+    result = {}
+
+    single_options.scan(/(.)(:)?/) do |opt, val|
+      if val
+        result[opt] = nil
+        define("-#{opt} VAL")
+      else
+        result[opt] = false
+        define("-#{opt}")
+      end
+    end if single_options
+
+    long_options.each do |arg|
+      arg, desc = arg.split(';', 2)
+      opt, val = arg.split(':', 2)
+      if val
+        result[opt] = val.empty? ? nil : val
+        define("--#{opt}=#{result[opt] || "VAL"}", *[desc].compact)
+      else
+        result[opt] = false
+        define("--#{opt}", *[desc].compact)
+      end
+    end
+
+    parse_in_order(argv, result.method(:[]=))
+    result
+  end
+
+  #
+  # See #getopts.
+  #
+  def self.getopts(*args)
+    new.getopts(*args)
+  end
+
+  #
+  # Traverses @stack, sending each element method +id+ with +args+ and
+  # +block+.
+  #
+  def visit(id, *args, &block) # :nodoc:
+    @stack.reverse_each do |el|
+      el.__send__(id, *args, &block)
+    end
+    nil
+  end
+  private :visit
+
+  #
+  # Searches +key+ in @stack for +id+ hash and returns or yields the result.
+  #
+  def search(id, key) # :nodoc:
+    block_given = block_given?
+    visit(:search, id, key) do |k|
+      return block_given ? yield(k) : k
+    end
+  end
+  private :search
+
+  #
+  # Completes shortened long style option switch and returns pair of
+  # canonical switch and switch descriptor Gem::OptionParser::Switch.
+  #
+  # +typ+::   Searching table.
+  # +opt+::   Searching key.
+  # +icase+:: Search case insensitive if true.
+  # +pat+::   Optional pattern for completion.
+  #
+  def complete(typ, opt, icase = false, *pat) # :nodoc:
+    if pat.empty?
+      search(typ, opt) {|sw| return [sw, opt]} # exact match or...
+    end
+    ambiguous = catch(:ambiguous) {
+      visit(:complete, typ, opt, icase, *pat) {|o, *sw| return sw}
+    }
+    exc = ambiguous ? AmbiguousOption : InvalidOption
+    raise exc.new(opt, additional: self.method(:additional_message).curry[typ])
+  end
+  private :complete
+
+  #
+  # Returns additional info.
+  #
+  def additional_message(typ, opt)
+    return unless typ and opt and defined?(DidYouMean::SpellChecker)
+    all_candidates = []
+    visit(:get_candidates, typ) do |candidates|
+      all_candidates.concat(candidates)
+    end
+    all_candidates.select! {|cand| cand.is_a?(String) }
+    checker = DidYouMean::SpellChecker.new(dictionary: all_candidates)
+    suggestions = all_candidates & checker.correct(opt)
+    if DidYouMean.respond_to?(:formatter)
+      DidYouMean.formatter.message_for(suggestions)
+    else
+       "\nDid you mean?  #{suggestions.join("\n               ")}"
+    end
+  end
+
+  def candidate(word)
+    list = []
+    case word
+    when '-'
+      long = short = true
+    when /\A--/
+      word, arg = word.split(/=/, 2)
+      argpat = Completion.regexp(arg, false) if arg and !arg.empty?
+      long = true
+    when /\A-/
+      short = true
+    end
+    pat = Completion.regexp(word, long)
+    visit(:each_option) do |opt|
+      next unless Switch === opt
+      opts = (long ? opt.long : []) + (short ? opt.short : [])
+      opts = Completion.candidate(word, true, pat, &opts.method(:each)).map(&:first) if pat
+      if /\A=/ =~ opt.arg
+        opts.map! {|sw| sw + "="}
+        if arg and CompletingHash === opt.pattern
+          if opts = opt.pattern.candidate(arg, false, argpat)
+            opts.map!(&:last)
+          end
+        end
+      end
+      list.concat(opts)
+    end
+    list
+  end
+
+  #
+  # Loads options from file names as +filename+. Does nothing when the file
+  # is not present. Returns whether successfully loaded.
+  #
+  # +filename+ defaults to basename of the program without suffix in a
+  # directory ~/.options, then the basename with '.options' suffix
+  # under XDG and Haiku standard places.
+  #
+  def load(filename = nil)
+    unless filename
+      basename = File.basename($0, '.*')
+      return true if load(File.expand_path(basename, '~/.options')) rescue nil
+      basename << ".options"
+      return [
+        # XDG
+        ENV['XDG_CONFIG_HOME'],
+        '~/.config',
+        *ENV['XDG_CONFIG_DIRS']&.split(File::PATH_SEPARATOR),
+
+        # Haiku
+        '~/config/settings',
+      ].any? {|dir|
+        next if !dir or dir.empty?
+        load(File.expand_path(basename, dir)) rescue nil
+      }
+    end
+    begin
+      parse(*IO.readlines(filename).each {|s| s.chomp!})
+      true
+    rescue Errno::ENOENT, Errno::ENOTDIR
+      false
+    end
+  end
+
+  #
+  # Parses environment variable +env+ or its uppercase with splitting like a
+  # shell.
+  #
+  # +env+ defaults to the basename of the program.
+  #
+  def environment(env = File.basename($0, '.*'))
+    env = ENV[env] || ENV[env.upcase] or return
+    require 'shellwords'
+    parse(*Shellwords.shellwords(env))
+  end
+
+  #
+  # Acceptable argument classes
+  #
+
+  #
+  # Any string and no conversion. This is fall-back.
+  #
+  accept(Object) {|s,|s or s.nil?}
+
+  accept(NilClass) {|s,|s}
+
+  #
+  # Any non-empty string, and no conversion.
+  #
+  accept(String, /.+/m) {|s,*|s}
+
+  #
+  # Ruby/C-like integer, octal for 0-7 sequence, binary for 0b, hexadecimal
+  # for 0x, and decimal for others; with optional sign prefix. Converts to
+  # Integer.
+  #
+  decimal = '\d+(?:_\d+)*'
+  binary = 'b[01]+(?:_[01]+)*'
+  hex = 'x[\da-f]+(?:_[\da-f]+)*'
+  octal = "0(?:[0-7]+(?:_[0-7]+)*|#{binary}|#{hex})?"
+  integer = "#{octal}|#{decimal}"
+
+  accept(Integer, %r"\A[-+]?(?:#{integer})\z"io) {|s,|
+    begin
+      Integer(s)
+    rescue ArgumentError
+      raise Gem::OptionParser::InvalidArgument, s
+    end if s
+  }
+
+  #
+  # Float number format, and converts to Float.
+  #
+  float = "(?:#{decimal}(?=(.)?)(?:\\.(?:#{decimal})?)?|\\.#{decimal})(?:E[-+]?#{decimal})?"
+  floatpat = %r"\A[-+]?#{float}\z"io
+  accept(Float, floatpat) {|s,| s.to_f if s}
+
+  #
+  # Generic numeric format, converts to Integer for integer format, Float
+  # for float format, and Rational for rational format.
+  #
+  real = "[-+]?(?:#{octal}|#{float})"
+  accept(Numeric, /\A(#{real})(?:\/(#{real}))?\z/io) {|s, d, f, n,|
+    if n
+      Rational(d, n)
+    elsif f
+      Float(s)
+    else
+      Integer(s)
+    end
+  }
+
+  #
+  # Decimal integer format, to be converted to Integer.
+  #
+  DecimalInteger = /\A[-+]?#{decimal}\z/io
+  accept(DecimalInteger, DecimalInteger) {|s,|
+    begin
+      Integer(s, 10)
+    rescue ArgumentError
+      raise Gem::OptionParser::InvalidArgument, s
+    end if s
+  }
+
+  #
+  # Ruby/C like octal/hexadecimal/binary integer format, to be converted to
+  # Integer.
+  #
+  OctalInteger = /\A[-+]?(?:[0-7]+(?:_[0-7]+)*|0(?:#{binary}|#{hex}))\z/io
+  accept(OctalInteger, OctalInteger) {|s,|
+    begin
+      Integer(s, 8)
+    rescue ArgumentError
+      raise Gem::OptionParser::InvalidArgument, s
+    end if s
+  }
+
+  #
+  # Decimal integer/float number format, to be converted to Integer for
+  # integer format, Float for float format.
+  #
+  DecimalNumeric = floatpat     # decimal integer is allowed as float also.
+  accept(DecimalNumeric, floatpat) {|s, f|
+    begin
+      if f
+        Float(s)
+      else
+        Integer(s)
+      end
+    rescue ArgumentError
+      raise Gem::OptionParser::InvalidArgument, s
+    end if s
+  }
+
+  #
+  # Boolean switch, which means whether it is present or not, whether it is
+  # absent or not with prefix no-, or it takes an argument
+  # yes/no/true/false/+/-.
+  #
+  yesno = CompletingHash.new
+  %w[- no false].each {|el| yesno[el] = false}
+  %w[+ yes true].each {|el| yesno[el] = true}
+  yesno['nil'] = false          # should be nil?
+  accept(TrueClass, yesno) {|arg, val| val == nil or val}
+  #
+  # Similar to TrueClass, but defaults to false.
+  #
+  accept(FalseClass, yesno) {|arg, val| val != nil and val}
+
+  #
+  # List of strings separated by ",".
+  #
+  accept(Array) do |s, |
+    if s
+      s = s.split(',').collect {|ss| ss unless ss.empty?}
+    end
+    s
+  end
+
+  #
+  # Regular expression with options.
+  #
+  accept(Regexp, %r"\A/((?:\\.|[^\\])*)/([[:alpha:]]+)?\z|.*") do |all, s, o|
+    f = 0
+    if o
+      f |= Regexp::IGNORECASE if /i/ =~ o
+      f |= Regexp::MULTILINE if /m/ =~ o
+      f |= Regexp::EXTENDED if /x/ =~ o
+      k = o.delete("imx")
+      k = nil if k.empty?
+    end
+    Regexp.new(s || all, f, k)
+  end
+
+  #
+  # Exceptions
+  #
+
+  #
+  # Base class of exceptions from Gem::OptionParser.
+  #
+  class ParseError < RuntimeError
+    # Reason which caused the error.
+    Reason = 'parse error'
+
+    def initialize(*args, additional: nil)
+      @additional = additional
+      @arg0, = args
+      @args = args
+      @reason = nil
+    end
+
+    attr_reader :args
+    attr_writer :reason
+    attr_accessor :additional
+
+    #
+    # Pushes back erred argument(s) to +argv+.
+    #
+    def recover(argv)
+      argv[0, 0] = @args
+      argv
+    end
+
+    def self.filter_backtrace(array)
+      unless $DEBUG
+        array.delete_if(&%r"\A#{Regexp.quote(__FILE__)}:"o.method(:=~))
+      end
+      array
+    end
+
+    def set_backtrace(array)
+      super(self.class.filter_backtrace(array))
+    end
+
+    def set_option(opt, eq)
+      if eq
+        @args[0] = opt
+      else
+        @args.unshift(opt)
+      end
+      self
+    end
+
+    #
+    # Returns error reason. Override this for I18N.
+    #
+    def reason
+      @reason || self.class::Reason
+    end
+
+    def inspect
+      "#<#{self.class}: #{args.join(' ')}>"
+    end
+
+    #
+    # Default stringizing method to emit standard error message.
+    #
+    def message
+      "#{reason}: #{args.join(' ')}#{additional[@arg0] if additional}"
+    end
+
+    alias to_s message
+  end
+
+  #
+  # Raises when ambiguously completable string is encountered.
+  #
+  class AmbiguousOption < ParseError
+    const_set(:Reason, 'ambiguous option')
+  end
+
+  #
+  # Raises when there is an argument for a switch which takes no argument.
+  #
+  class NeedlessArgument < ParseError
+    const_set(:Reason, 'needless argument')
+  end
+
+  #
+  # Raises when a switch with mandatory argument has no argument.
+  #
+  class MissingArgument < ParseError
+    const_set(:Reason, 'missing argument')
+  end
+
+  #
+  # Raises when switch is undefined.
+  #
+  class InvalidOption < ParseError
+    const_set(:Reason, 'invalid option')
+  end
+
+  #
+  # Raises when the given argument does not match required format.
+  #
+  class InvalidArgument < ParseError
+    const_set(:Reason, 'invalid argument')
+  end
+
+  #
+  # Raises when the given argument word can't be completed uniquely.
+  #
+  class AmbiguousArgument < InvalidArgument
+    const_set(:Reason, 'ambiguous argument')
+  end
+
+  #
+  # Miscellaneous
+  #
+
+  #
+  # Extends command line arguments array (ARGV) to parse itself.
+  #
+  module Arguable
+
+    #
+    # Sets Gem::OptionParser object, when +opt+ is +false+ or +nil+, methods
+    # Gem::OptionParser::Arguable#options and Gem::OptionParser::Arguable#options= are
+    # undefined. Thus, there is no ways to access the Gem::OptionParser object
+    # via the receiver object.
+    #
+    def options=(opt)
+      unless @optparse = opt
+        class << self
+          undef_method(:options)
+          undef_method(:options=)
+        end
+      end
+    end
+
+    #
+    # Actual Gem::OptionParser object, automatically created if nonexistent.
+    #
+    # If called with a block, yields the Gem::OptionParser object and returns the
+    # result of the block. If an Gem::OptionParser::ParseError exception occurs
+    # in the block, it is rescued, a error message printed to STDERR and
+    # +nil+ returned.
+    #
+    def options
+      @optparse ||= Gem::OptionParser.new
+      @optparse.default_argv = self
+      block_given? or return @optparse
+      begin
+        yield @optparse
+      rescue ParseError
+        @optparse.warn $!
+        nil
+      end
+    end
+
+    #
+    # Parses +self+ destructively in order and returns +self+ containing the
+    # rest arguments left unparsed.
+    #
+    def order!(&blk) options.order!(self, &blk) end
+
+    #
+    # Parses +self+ destructively in permutation mode and returns +self+
+    # containing the rest arguments left unparsed.
+    #
+    def permute!() options.permute!(self) end
+
+    #
+    # Parses +self+ destructively and returns +self+ containing the
+    # rest arguments left unparsed.
+    #
+    def parse!() options.parse!(self) end
+
+    #
+    # Substitution of getopts is possible as follows. Also see
+    # Gem::OptionParser#getopts.
+    #
+    #   def getopts(*args)
+    #     ($OPT = ARGV.getopts(*args)).each do |opt, val|
+    #       eval "$OPT_#{opt.gsub(/[^A-Za-z0-9_]/, '_')} = val"
+    #     end
+    #   rescue Gem::OptionParser::ParseError
+    #   end
+    #
+    def getopts(*args)
+      options.getopts(self, *args)
+    end
+
+    #
+    # Initializes instance variable.
+    #
+    def self.extend_object(obj)
+      super
+      obj.instance_eval {@optparse = nil}
+    end
+    def initialize(*args)
+      super
+      @optparse = nil
+    end
+  end
+
+  #
+  # Acceptable argument classes. Now contains DecimalInteger, OctalInteger
+  # and DecimalNumeric. See Acceptable argument classes (in source code).
+  #
+  module Acceptables
+    const_set(:DecimalInteger, Gem::OptionParser::DecimalInteger)
+    const_set(:OctalInteger, Gem::OptionParser::OctalInteger)
+    const_set(:DecimalNumeric, Gem::OptionParser::DecimalNumeric)
+  end
+end
+
+# ARGV is arguable by Gem::OptionParser
+ARGV.extend(Gem::OptionParser::Arguable)
diff --git a/lib/rubygems/optparse/lib/optparse/ac.rb b/lib/rubygems/optparse/lib/optparse/ac.rb
new file mode 100644
index 0000000..ff2f4c2
--- /dev/null
+++ b/lib/rubygems/optparse/lib/optparse/ac.rb
@@ -0,0 +1,54 @@
+# frozen_string_literal: false
+require 'rubygems/optparse/lib/optparse'
+
+class Gem::OptionParser::AC < Gem::OptionParser
+  private
+
+  def _check_ac_args(name, block)
+    unless /\A\w[-\w]*\z/ =~ name
+      raise ArgumentError, name
+    end
+    unless block
+      raise ArgumentError, "no block given", ParseError.filter_backtrace(caller)
+    end
+  end
+
+  ARG_CONV = proc {|val| val.nil? ? true : val}
+
+  def _ac_arg_enable(prefix, name, help_string, block)
+    _check_ac_args(name, block)
+
+    sdesc = []
+    ldesc = ["--#{prefix}-#{name}"]
+    desc = [help_string]
+    q = name.downcase
+    ac_block = proc {|val| block.call(ARG_CONV.call(val))}
+    enable = Switch::PlacedArgument.new(nil, ARG_CONV, sdesc, ldesc, nil, desc, ac_block)
+    disable = Switch::NoArgument.new(nil, proc {false}, sdesc, ldesc, nil, desc, ac_block)
+    top.append(enable, [], ["enable-" + q], disable, ['disable-' + q])
+    enable
+  end
+
+  public
+
+  def ac_arg_enable(name, help_string, &block)
+    _ac_arg_enable("enable", name, help_string, block)
+  end
+
+  def ac_arg_disable(name, help_string, &block)
+    _ac_arg_enable("disable", name, help_string, block)
+  end
+
+  def ac_arg_with(name, help_string, &block)
+    _check_ac_args(name, block)
+
+    sdesc = []
+    ldesc = ["--with-#{name}"]
+    desc = [help_string]
+    q = name.downcase
+    with = Switch::PlacedArgument.new(*search(:atype, String), sdesc, ldesc, nil, desc, block)
+    without = Switch::NoArgument.new(nil, proc {}, sdesc, ldesc, nil, desc, block)
+    top.append(with, [], ["with-" + q], without, ['without-' + q])
+    with
+  end
+end
diff --git a/lib/rubygems/optparse/lib/optparse/date.rb b/lib/rubygems/optparse/lib/optparse/date.rb
new file mode 100644
index 0000000..11131e9
--- /dev/null
+++ b/lib/rubygems/optparse/lib/optparse/date.rb
@@ -0,0 +1,18 @@
+# frozen_string_literal: false
+require 'rubygems/optparse/lib/optparse'
+require 'date'
+
+Gem::OptionParser.accept(DateTime) do |s,|
+  begin
+    DateTime.parse(s) if s
+  rescue ArgumentError
+    raise Gem::OptionParser::InvalidArgument, s
+  end
+end
+Gem::OptionParser.accept(Date) do |s,|
+  begin
+    Date.parse(s) if s
+  rescue ArgumentError
+    raise Gem::OptionParser::InvalidArgument, s
+  end
+end
diff --git a/lib/rubygems/optparse/lib/optparse/kwargs.rb b/lib/rubygems/optparse/lib/optparse/kwargs.rb
new file mode 100644
index 0000000..9290344
--- /dev/null
+++ b/lib/rubygems/optparse/lib/optparse/kwargs.rb
@@ -0,0 +1,22 @@
+# frozen_string_literal: true
+require 'rubygems/optparse/lib/optparse'
+
+class Gem::OptionParser
+  # :call-seq:
+  #   define_by_keywords(options, method, **params)
+  #
+  # :include: ../../doc/optparse/creates_option.rdoc
+  #
+  def define_by_keywords(options, meth, **opts)
+    meth.parameters.each do |type, name|
+      case type
+      when :key, :keyreq
+        op, cl = *(type == :key ? %w"[ ]" : ["", ""])
+        define("--#{name}=#{op}#{name.upcase}#{cl}", *opts[name]) do |o|
+          options[name] = o
+        end
+      end
+    end
+    options
+  end
+end
diff --git a/lib/rubygems/optparse/lib/optparse/shellwords.rb b/lib/rubygems/optparse/lib/optparse/shellwords.rb
new file mode 100644
index 0000000..60dd919
--- /dev/null
+++ b/lib/rubygems/optparse/lib/optparse/shellwords.rb
@@ -0,0 +1,7 @@
+# frozen_string_literal: false
+# -*- ruby -*-
+
+require 'shellwords'
+require 'rubygems/optparse/lib/optparse'
+
+Gem::OptionParser.accept(Shellwords) {|s,| Shellwords.shellwords(s)}
diff --git a/lib/rubygems/optparse/lib/optparse/time.rb b/lib/rubygems/optparse/lib/optparse/time.rb
new file mode 100644
index 0000000..cb19f6e
--- /dev/null
+++ b/lib/rubygems/optparse/lib/optparse/time.rb
@@ -0,0 +1,11 @@
+# frozen_string_literal: false
+require 'rubygems/optparse/lib/optparse'
+require 'time'
+
+Gem::OptionParser.accept(Time) do |s,|
+  begin
+    (Time.httpdate(s) rescue Time.parse(s)) if s
+  rescue
+    raise Gem::OptionParser::InvalidArgument, s
+  end
+end
diff --git a/lib/rubygems/optparse/lib/optparse/uri.rb b/lib/rubygems/optparse/lib/optparse/uri.rb
new file mode 100644
index 0000000..088f309
--- /dev/null
+++ b/lib/rubygems/optparse/lib/optparse/uri.rb
@@ -0,0 +1,7 @@
+# frozen_string_literal: false
+# -*- ruby -*-
+
+require 'rubygems/optparse/lib/optparse'
+require 'uri'
+
+Gem::OptionParser.accept(URI) {|s,| URI.parse(s) if s}
diff --git a/lib/rubygems/optparse/lib/optparse/version.rb b/lib/rubygems/optparse/lib/optparse/version.rb
new file mode 100644
index 0000000..5d79e9d
--- /dev/null
+++ b/lib/rubygems/optparse/lib/optparse/version.rb
@@ -0,0 +1,71 @@
+# frozen_string_literal: false
+# Gem::OptionParser internal utility
+
+class << Gem::OptionParser
+  def show_version(*pkgs)
+    progname = ARGV.options.program_name
+    result = false
+    show = proc do |klass, cname, version|
+      str = "#{progname}"
+      unless klass == ::Object and cname == :VERSION
+        version = version.join(".") if Array === version
+        str << ": #{klass}" unless klass == Object
+        str << " version #{version}"
+      end
+      [:Release, :RELEASE].find do |rel|
+        if klass.const_defined?(rel)
+          str << " (#{klass.const_get(rel)})"
+        end
+      end
+      puts str
+      result = true
+    end
+    if pkgs.size == 1 and pkgs[0] == "all"
+      self.search_const(::Object, /\AV(?:ERSION|ersion)\z/) do |klass, cname, version|
+        unless cname[1] == ?e and klass.const_defined?(:Version)
+          show.call(klass, cname.intern, version)
+        end
+      end
+    else
+      pkgs.each do |pkg|
+        begin
+          pkg = pkg.split(/::|\//).inject(::Object) {|m, c| m.const_get(c)}
+          v = case
+              when pkg.const_defined?(:Version)
+                pkg.const_get(n = :Version)
+              when pkg.const_defined?(:VERSION)
+                pkg.const_get(n = :VERSION)
+              else
+                n = nil
+                "unknown"
+              end
+          show.call(pkg, n, v)
+        rescue NameError
+        end
+      end
+    end
+    result
+  end
+
+  def each_const(path, base = ::Object)
+    path.split(/::|\//).inject(base) do |klass, name|
+      raise NameError, path unless Module === klass
+      klass.constants.grep(/#{name}/i) do |c|
+        klass.const_defined?(c) or next
+        klass.const_get(c)
+      end
+    end
+  end
+
+  def search_const(klass, name)
+    klasses = [klass]
+    while klass = klasses.shift
+      klass.constants.each do |cname|
+        klass.const_defined?(cname) or next
+        const = klass.const_get(cname)
+        yield klass, cname, const if name === cname
+        klasses << const if Module === const and const != ::Object
+      end
+    end
+  end
+end
diff --git a/lib/rubygems/package.rb b/lib/rubygems/package.rb
index a4ae3e9..9470591 100644
--- a/lib/rubygems/package.rb
+++ b/lib/rubygems/package.rb
@@ -41,9 +41,9 @@
 # #files are the files in the .gem tar file, not the Ruby files in the gem
 # #extract_files and #contents automatically call #verify
 
-require "rubygems"
-require 'rubygems/security'
-require 'rubygems/user_interaction'
+require_relative "../rubygems"
+require_relative 'security'
+require_relative 'user_interaction'
 
 class Gem::Package
   include Gem::UserInteraction
@@ -71,6 +71,13 @@ class Gem::Package
     end
   end
 
+  class SymlinkError < Error
+    def initialize(name, destination, destination_dir)
+      super "installing symlink '%s' pointing to parent path %s of %s is not allowed" %
+              [name, destination, destination_dir]
+    end
+  end
+
   class NonSeekableIO < Error; end
 
   class TooLongFileName < Error; end
@@ -400,13 +407,21 @@ EOM
   # extracted.
 
   def extract_tar_gz(io, destination_dir, pattern = "*") # :nodoc:
-    directories = [] if dir_mode
+    directories = []
     open_tar_gz io do |tar|
       tar.each do |entry|
         next unless File.fnmatch pattern, entry.full_name, File::FNM_DOTMATCH
 
         destination = install_location entry.full_name, destination_dir
 
+        if entry.symlink?
+          link_target = entry.header.linkname
+          real_destination = link_target.start_with?("/") ? link_target : File.expand_path(link_target, File.dirname(destination))
+
+          raise Gem::Package::SymlinkError.new(entry.full_name, real_destination, destination_dir) unless
+            normalize_path(real_destination).start_with? normalize_path(destination_dir + '/')
+        end
+
         FileUtils.rm_rf destination
 
         mkdir_options = {}
@@ -417,9 +432,11 @@ EOM
           else
             File.dirname destination
           end
-        directories << mkdir if directories
 
-        mkdir_p_safe mkdir, mkdir_options, destination_dir, entry.full_name
+        unless directories.include?(mkdir)
+          FileUtils.mkdir_p mkdir, **mkdir_options
+          directories << mkdir
+        end
 
         File.open destination, 'wb' do |out|
           out.write entry.read
@@ -432,8 +449,7 @@ EOM
       end
     end
 
-    if directories
-      directories.uniq!
+    if dir_mode
       File.chmod(dir_mode, *directories)
     end
   end
@@ -466,21 +482,11 @@ EOM
     raise Gem::Package::PathError.new(filename, destination_dir) if
       filename.start_with? '/'
 
-    destination_dir = File.expand_path(File.realpath(destination_dir))
-    destination = File.expand_path(File.join(destination_dir, filename))
+    destination_dir = File.realpath(destination_dir)
+    destination = File.expand_path(filename, destination_dir)
 
     raise Gem::Package::PathError.new(destination, destination_dir) unless
-      destination.start_with? destination_dir + '/'
-
-    begin
-      real_destination = File.expand_path(File.realpath(destination))
-    rescue
-      # it's fine if the destination doesn't exist, because rm -rf'ing it can't cause any damage
-      nil
-    else
-      raise Gem::Package::PathError.new(real_destination, destination_dir) unless
-        real_destination.start_with? destination_dir + '/'
-    end
+      normalize_path(destination).start_with? normalize_path(destination_dir + '/')
 
     destination.tap(&Gem::UNTAINT)
     destination
@@ -494,22 +500,6 @@ EOM
     end
   end
 
-  def mkdir_p_safe(mkdir, mkdir_options, destination_dir, file_name)
-    destination_dir = File.realpath(File.expand_path(destination_dir))
-    parts = mkdir.split(File::SEPARATOR)
-    parts.reduce do |path, basename|
-      path = File.realpath(path) unless path == ""
-      path = File.expand_path(path + File::SEPARATOR + basename)
-      lstat = File.lstat path rescue nil
-      if !lstat || !lstat.directory?
-        unless normalize_path(path).start_with? normalize_path(destination_dir) and (FileUtils.mkdir path, **mkdir_options rescue false)
-          raise Gem::Package::PathError.new(file_name, destination_dir)
-        end
-      end
-      path
-    end
-  end
-
   ##
   # Loads a Gem::Specification from the TarEntry +entry+
 
@@ -702,12 +692,12 @@ EOM
   end
 end
 
-require 'rubygems/package/digest_io'
-require 'rubygems/package/source'
-require 'rubygems/package/file_source'
-require 'rubygems/package/io_source'
-require 'rubygems/package/old'
-require 'rubygems/package/tar_header'
-require 'rubygems/package/tar_reader'
-require 'rubygems/package/tar_reader/entry'
-require 'rubygems/package/tar_writer'
+require_relative 'package/digest_io'
+require_relative 'package/source'
+require_relative 'package/file_source'
+require_relative 'package/io_source'
+require_relative 'package/old'
+require_relative 'package/tar_header'
+require_relative 'package/tar_reader'
+require_relative 'package/tar_reader/entry'
+require_relative 'package/tar_writer'
diff --git a/lib/rubygems/package/io_source.rb b/lib/rubygems/package/io_source.rb
index 7d73831..03d7714 100644
--- a/lib/rubygems/package/io_source.rb
+++ b/lib/rubygems/package/io_source.rb
@@ -32,10 +32,14 @@ class Gem::Package::IOSource < Gem::Package::Source # :nodoc: all
 
   def with_read_io
     yield io
+  ensure
+    io.rewind
   end
 
   def with_write_io
     yield io
+  ensure
+    io.rewind
   end
 
   def path
diff --git a/lib/rubygems/package/tar_reader.rb b/lib/rubygems/package/tar_reader.rb
index e7c5620..41121f3 100644
--- a/lib/rubygems/package/tar_reader.rb
+++ b/lib/rubygems/package/tar_reader.rb
@@ -121,4 +121,4 @@ class Gem::Package::TarReader
   end
 end
 
-require 'rubygems/package/tar_reader/entry'
+require_relative 'tar_reader/entry'
diff --git a/lib/rubygems/package/tar_test_case.rb b/lib/rubygems/package/tar_test_case.rb
deleted file mode 100644
index 1161d0a..0000000
--- a/lib/rubygems/package/tar_test_case.rb
+++ /dev/null
@@ -1,139 +0,0 @@
-# frozen_string_literal: true
-require 'rubygems/test_case'
-require 'rubygems/package'
-
-##
-# A test case for Gem::Package::Tar* classes
-
-class Gem::Package::TarTestCase < Gem::TestCase
-  def ASCIIZ(str, length)
-    str + "\0" * (length - str.length)
-  end
-
-  def SP(s)
-    s + " "
-  end
-
-  def SP_Z(s)
-    s + " \0"
-  end
-
-  def Z(s)
-    s + "\0"
-  end
-
-  def assert_headers_equal(expected, actual)
-    expected = expected.to_s unless String === expected
-    actual = actual.to_s unless String === actual
-
-    fields = %w[
-      name 100
-      mode 8
-      uid 8
-      gid 8
-      size 12
-      mtime 12
-      checksum 8
-      typeflag 1
-      linkname 100
-      magic 6
-      version 2
-      uname 32
-      gname 32
-      devmajor 8
-      devminor 8
-      prefix 155
-    ]
-
-    offset = 0
-
-    until fields.empty? do
-      name = fields.shift
-      length = fields.shift.to_i
-
-      if name == "checksum"
-        chksum_off = offset
-        offset += length
-        next
-      end
-
-      assert_equal expected[offset, length], actual[offset, length],
-                   "Field #{name} of the tar header differs."
-
-      offset += length
-    end
-
-    assert_equal expected[chksum_off, 8], actual[chksum_off, 8]
-  end
-
-  def calc_checksum(header)
-    sum = header.unpack("C*").inject{|s,a| s + a }
-    SP(Z(to_oct(sum, 6)))
-  end
-
-  def header(type, fname, dname, length, mode, mtime, checksum = nil, linkname = "")
-    checksum ||= " " * 8
-
-    arr = [                  # struct tarfile_entry_posix
-      ASCIIZ(fname, 100),    # char name[100];     ASCII + (Z unless filled)
-      Z(to_oct(mode, 7)),    # char mode[8];       0 padded, octal null
-      Z(to_oct(0, 7)),       # char uid[8];        ditto
-      Z(to_oct(0, 7)),       # char gid[8];        ditto
-      Z(to_oct(length, 11)), # char size[12];      0 padded, octal, null
-      Z(to_oct(mtime, 11)),  # char mtime[12];     0 padded, octal, null
-      checksum,              # char checksum[8];   0 padded, octal, null, space
-      type,                  # char typeflag[1];   file: "0"  dir: "5"
-      ASCIIZ(linkname, 100), # char linkname[100]; ASCII + (Z unless filled)
-      "ustar\0",             # char magic[6];      "ustar\0"
-      "00",                  # char version[2];    "00"
-      ASCIIZ("wheel", 32),   # char uname[32];     ASCIIZ
-      ASCIIZ("wheel", 32),   # char gname[32];     ASCIIZ
-      Z(to_oct(0, 7)),       # char devmajor[8];   0 padded, octal, null
-      Z(to_oct(0, 7)),       # char devminor[8];   0 padded, octal, null
-      ASCIIZ(dname, 155), # char prefix[155];   ASCII + (Z unless filled)
-    ]
-
-    h = arr.join
-    ret = h + "\0" * (512 - h.size)
-    assert_equal(512, ret.size)
-    ret
-  end
-
-  def tar_dir_header(name, prefix, mode, mtime)
-    h = header("5", name, prefix, 0, mode, mtime)
-    checksum = calc_checksum(h)
-    header("5", name, prefix, 0, mode, mtime, checksum)
-  end
-
-  def tar_file_header(fname, dname, mode, length, mtime)
-    h = header("0", fname, dname, length, mode, mtime)
-    checksum = calc_checksum(h)
-    header("0", fname, dname, length, mode, mtime, checksum)
-  end
-
-  def tar_symlink_header(fname, prefix, mode, mtime, linkname)
-    h = header("2", fname, prefix, 0, mode, mtime, nil, linkname)
-    checksum = calc_checksum(h)
-    header("2", fname, prefix, 0, mode, mtime, checksum, linkname)
-  end
-
-  def to_oct(n, pad_size)
-    "%0#{pad_size}o" % n
-  end
-
-  def util_entry(tar)
-    io = TempIO.new tar
-
-    header = Gem::Package::TarHeader.from io
-
-    Gem::Package::TarReader::Entry.new header, io
-  end
-
-  def util_dir_entry
-    util_entry tar_dir_header("foo", "bar", 0, Time.now)
-  end
-
-  def util_symlink_entry
-    util_entry tar_symlink_header("foo", "bar", 0, Time.now, "link")
-  end
-end
diff --git a/lib/rubygems/package_task.rb b/lib/rubygems/package_task.rb
index d5a2885..bb48616 100644
--- a/lib/rubygems/package_task.rb
+++ b/lib/rubygems/package_task.rb
@@ -20,8 +20,8 @@
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
-require 'rubygems'
-require 'rubygems/package'
+require_relative '../rubygems'
+require_relative 'package'
 require 'rake/packagetask'
 
 ##
diff --git a/lib/rubygems/path_support.rb b/lib/rubygems/path_support.rb
index 8103caf..d601e65 100644
--- a/lib/rubygems/path_support.rb
+++ b/lib/rubygems/path_support.rb
@@ -72,12 +72,7 @@ class Gem::PathSupport
 
   # Return the default Gem path
   def default_path
-    gem_path = Gem.default_path + [@home]
-
-    if defined?(APPLE_GEM_HOME)
-      gem_path << APPLE_GEM_HOME
-    end
-    gem_path
+    Gem.default_path + [@home]
   end
 
   def expand(path)
diff --git a/lib/rubygems/platform.rb b/lib/rubygems/platform.rb
index fd1c0a6..a5e65f9 100644
--- a/lib/rubygems/platform.rb
+++ b/lib/rubygems/platform.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require "rubygems/deprecate"
+require_relative "deprecate"
 
 ##
 # Available list of platforms for targeting Gem installations.
@@ -40,6 +40,10 @@ class Gem::Platform
     match_platforms?(platform, Gem.platforms)
   end
 
+  def self.sort_priority(platform)
+    platform == Gem::Platform::RUBY ? -1 : 1
+  end
+
   def self.installable?(spec)
     if spec.respond_to? :installable_platform?
       spec.installable_platform?
@@ -100,6 +104,7 @@ class Gem::Platform
                       when /^dotnet([\d.]*)/ then       [ 'dotnet',    $1  ]
                       when /linux-?((?!gnu)\w+)?/ then  [ 'linux',     $1  ]
                       when /mingw32/ then               [ 'mingw32',   nil ]
+                      when /mingw-?(\w+)?/ then         [ 'mingw',     $1  ]
                       when /(mswin\d+)(\_(\d+))?/ then
                         os, version = $1, $3
                         @cpu = 'x86' if @cpu.nil? and os =~ /32$/
diff --git a/lib/rubygems/query_utils.rb b/lib/rubygems/query_utils.rb
index ea0f260..0acd5bf 100644
--- a/lib/rubygems/query_utils.rb
+++ b/lib/rubygems/query_utils.rb
@@ -1,9 +1,9 @@
 # frozen_string_literal: true
 
-require 'rubygems/local_remote_options'
-require 'rubygems/spec_fetcher'
-require 'rubygems/version_option'
-require 'rubygems/text'
+require_relative 'local_remote_options'
+require_relative 'spec_fetcher'
+require_relative 'version_option'
+require_relative 'text'
 
 module Gem::QueryUtils
 
diff --git a/lib/rubygems/rdoc.rb b/lib/rubygems/rdoc.rb
index c40bb7d..ac5e8f0 100644
--- a/lib/rubygems/rdoc.rb
+++ b/lib/rubygems/rdoc.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require 'rubygems'
+require_relative '../rubygems'
 
 begin
   require 'rdoc/rubygems_hook'
diff --git a/lib/rubygems/remote_fetcher.rb b/lib/rubygems/remote_fetcher.rb
index da7b46e..bd8165e 100644
--- a/lib/rubygems/remote_fetcher.rb
+++ b/lib/rubygems/remote_fetcher.rb
@@ -1,12 +1,11 @@
 # frozen_string_literal: true
-require 'rubygems'
-require 'rubygems/request'
-require 'rubygems/request/connection_pools'
-require 'rubygems/s3_uri_signer'
-require 'rubygems/uri_formatter'
-require 'rubygems/uri_parsing'
-require 'rubygems/user_interaction'
-require 'resolv'
+require_relative '../rubygems'
+require_relative 'request'
+require_relative 'request/connection_pools'
+require_relative 's3_uri_signer'
+require_relative 'uri_formatter'
+require_relative 'uri'
+require_relative 'user_interaction'
 
 ##
 # RemoteFetcher handles the details of fetching gems and gem information from
@@ -14,30 +13,24 @@ require 'resolv'
 
 class Gem::RemoteFetcher
   include Gem::UserInteraction
-  include Gem::UriParsing
 
   ##
   # A FetchError exception wraps up the various possible IO and HTTP failures
   # that could happen while downloading from the internet.
 
   class FetchError < Gem::Exception
-    include Gem::UriParsing
-
     ##
     # The URI which was being accessed when the exception happened.
 
     attr_accessor :uri, :original_uri
 
     def initialize(message, uri)
-      super message
-
-      uri = parse_uri(uri)
-
-      @original_uri = uri.dup
+      uri = Gem::Uri.new(uri)
 
-      uri.password = 'REDACTED' if uri.respond_to?(:password) && uri.password
+      super uri.redact_credentials_from(message)
 
-      @uri = uri.to_s
+      @original_uri = uri.to_s
+      @uri = uri.redacted.to_s
     end
 
     def to_s # :nodoc:
@@ -79,7 +72,7 @@ class Gem::RemoteFetcher
   #            fetching the gem.
 
   def initialize(proxy=nil, dns=nil, headers={})
-    require 'rubygems/core_ext/tcpsocket_init' if Gem.configuration.ipv4_fallback_enabled
+    require_relative 'core_ext/tcpsocket_init' if Gem.configuration.ipv4_fallback_enabled
     require 'net/http'
     require 'stringio'
     require 'uri'
@@ -88,7 +81,7 @@ class Gem::RemoteFetcher
 
     @proxy = proxy
     @pools = {}
-    @pool_lock = Mutex.new
+    @pool_lock = Thread::Mutex.new
     @cert_files = Gem::Request.get_cert_files
 
     @headers = headers
@@ -133,7 +126,7 @@ class Gem::RemoteFetcher
     require "fileutils"
     FileUtils.mkdir_p cache_dir rescue nil unless File.exist? cache_dir
 
-    source_uri = parse_uri(source_uri)
+    source_uri = Gem::Uri.new(source_uri)
 
     scheme = source_uri.scheme
 
@@ -228,7 +221,7 @@ class Gem::RemoteFetcher
       unless location = response['Location']
         raise FetchError.new("redirecting but no redirect location was given", uri)
       end
-      location = parse_uri location
+      location = Gem::Uri.new location
 
       if https?(uri) && !https?(location)
         raise FetchError.new("redirecting to non-https resource: #{location}", uri)
@@ -246,7 +239,7 @@ class Gem::RemoteFetcher
   # Downloads +uri+ and returns it as a String.
 
   def fetch_path(uri, mtime = nil, head = false)
-    uri = parse_uri uri
+    uri = Gem::Uri.new uri
 
     unless uri.scheme
       raise ArgumentError, "uri scheme is invalid: #{uri.scheme.inspect}"
@@ -291,7 +284,7 @@ class Gem::RemoteFetcher
 
     data = fetch_path(uri, mtime)
 
-    if data == nil # indicates the server returned 304 Not Modified
+    if data.nil? # indicates the server returned 304 Not Modified
       return Gem.read_binary(path)
     end
 
diff --git a/lib/rubygems/request.rb b/lib/rubygems/request.rb
index 5bda0b2..d6100c9 100644
--- a/lib/rubygems/request.rb
+++ b/lib/rubygems/request.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
 require 'net/http'
-require 'rubygems/user_interaction'
+require_relative 'user_interaction'
 
 class Gem::Request
   extend Gem::UserInteraction
@@ -96,8 +96,10 @@ class Gem::Request
     return unless cert
     case error_number
     when OpenSSL::X509::V_ERR_CERT_HAS_EXPIRED then
+      require 'time'
       "Certificate #{cert.subject} expired at #{cert.not_after.iso8601}"
     when OpenSSL::X509::V_ERR_CERT_NOT_YET_VALID then
+      require 'time'
       "Certificate #{cert.subject} not valid until #{cert.not_before.iso8601}"
     when OpenSSL::X509::V_ERR_CERT_REJECTED then
       "Certificate #{cert.subject} is rejected"
@@ -191,7 +193,7 @@ class Gem::Request
     begin
       @requests[connection.object_id] += 1
 
-      verbose "#{request.method} #{@uri}"
+      verbose "#{request.method} #{Gem::Uri.new(@uri).redacted}"
 
       file_name = File.basename(@uri.path)
       # perform download progress reporter only for gems
@@ -287,6 +289,6 @@ class Gem::Request
   end
 end
 
-require 'rubygems/request/http_pool'
-require 'rubygems/request/https_pool'
-require 'rubygems/request/connection_pools'
+require_relative 'request/http_pool'
+require_relative 'request/https_pool'
+require_relative 'request/connection_pools'
diff --git a/lib/rubygems/request/connection_pools.rb b/lib/rubygems/request/connection_pools.rb
index 7f39889..a4c2929 100644
--- a/lib/rubygems/request/connection_pools.rb
+++ b/lib/rubygems/request/connection_pools.rb
@@ -11,7 +11,7 @@ class Gem::Request::ConnectionPools # :nodoc:
     @proxy_uri  = proxy_uri
     @cert_files = cert_files
     @pools      = {}
-    @pool_mutex = Mutex.new
+    @pool_mutex = Thread::Mutex.new
   end
 
   def pool_for(uri)
diff --git a/lib/rubygems/request/http_pool.rb b/lib/rubygems/request/http_pool.rb
index 9985bba..f028516 100644
--- a/lib/rubygems/request/http_pool.rb
+++ b/lib/rubygems/request/http_pool.rb
@@ -12,7 +12,7 @@ class Gem::Request::HTTPPool # :nodoc:
     @http_args  = http_args
     @cert_files = cert_files
     @proxy_uri  = proxy_uri
-    @queue      = SizedQueue.new 1
+    @queue      = Thread::SizedQueue.new 1
     @queue << nil
   end
 
diff --git a/lib/rubygems/request_set.rb b/lib/rubygems/request_set.rb
index 5190cfc..01b0159 100644
--- a/lib/rubygems/request_set.rb
+++ b/lib/rubygems/request_set.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require 'tsort'
+require_relative 'tsort'
 
 ##
 # A RequestSet groups a request to activate a set of dependencies.
@@ -15,7 +15,7 @@ require 'tsort'
 #   #=> ["nokogiri-1.6.0", "mini_portile-0.5.1", "pg-0.17.0"]
 
 class Gem::RequestSet
-  include TSort
+  include Gem::TSort
 
   ##
   # Array of gems to install even if already installed
@@ -151,7 +151,7 @@ class Gem::RequestSet
     @prerelease = options[:prerelease]
 
     requests = []
-    download_queue = Queue.new
+    download_queue = Thread::Queue.new
 
     # Create a thread-safe list of gems to download
     sorted_requests.each do |req|
@@ -303,7 +303,7 @@ class Gem::RequestSet
       end
     end
 
-    require "rubygems/dependency_installer"
+    require_relative "dependency_installer"
     inst = Gem::DependencyInstaller.new options
     inst.installed_gems.replace specs
 
@@ -461,6 +461,6 @@ class Gem::RequestSet
   end
 end
 
-require 'rubygems/request_set/gem_dependency_api'
-require 'rubygems/request_set/lockfile'
-require 'rubygems/request_set/lockfile/tokenizer'
+require_relative 'request_set/gem_dependency_api'
+require_relative 'request_set/lockfile'
+require_relative 'request_set/lockfile/tokenizer'
diff --git a/lib/rubygems/request_set/lockfile.rb b/lib/rubygems/request_set/lockfile.rb
index 8f8f142..bec29ef 100644
--- a/lib/rubygems/request_set/lockfile.rb
+++ b/lib/rubygems/request_set/lockfile.rb
@@ -236,4 +236,4 @@ class Gem::RequestSet::Lockfile
   end
 end
 
-require 'rubygems/request_set/lockfile/tokenizer'
+require_relative 'lockfile/tokenizer'
diff --git a/lib/rubygems/request_set/lockfile/tokenizer.rb b/lib/rubygems/request_set/lockfile/tokenizer.rb
index 6918e8e..cb8030c 100644
--- a/lib/rubygems/request_set/lockfile/tokenizer.rb
+++ b/lib/rubygems/request_set/lockfile/tokenizer.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require 'rubygems/request_set/lockfile/parser'
+require_relative 'parser'
 
 class Gem::RequestSet::Lockfile::Tokenizer
   Token = Struct.new :type, :value, :column, :line
diff --git a/lib/rubygems/requirement.rb b/lib/rubygems/requirement.rb
index 6721de4..9edd6aa 100644
--- a/lib/rubygems/requirement.rb
+++ b/lib/rubygems/requirement.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require "rubygems/deprecate"
+require_relative "version"
 
 ##
 # A Requirement is a set of one or more version restrictions. It supports a
@@ -194,24 +194,19 @@ class Gem::Requirement
   end
 
   def marshal_dump # :nodoc:
-    fix_syck_default_key_in_requirements
-
     [@requirements]
   end
 
   def marshal_load(array) # :nodoc:
     @requirements = array[0]
 
-    fix_syck_default_key_in_requirements
+    raise TypeError, "wrong @requirements" unless Array === @requirements
   end
 
   def yaml_initialize(tag, vals) # :nodoc:
     vals.each do |ivar, val|
       instance_variable_set "@#{ivar}", val
     end
-
-    Gem.load_yaml
-    fix_syck_default_key_in_requirements
   end
 
   def init_with(coder) # :nodoc:
@@ -246,8 +241,7 @@ class Gem::Requirement
   def satisfied_by?(version)
     raise ArgumentError, "Need a Gem::Version: #{version.inspect}" unless
       Gem::Version === version
-    # #28965: syck has a bug with unquoted '=' YAML.loading as YAML::DefaultKey
-    requirements.all? {|op, rv| (OPS[op] || OPS["="]).call version, rv }
+    requirements.all? {|op, rv| OPS[op].call version, rv }
   end
 
   alias :=== :satisfied_by?
@@ -289,19 +283,6 @@ class Gem::Requirement
   def _tilde_requirements
     @_tilde_requirements ||= _sorted_requirements.select {|r| r.first == "~>" }
   end
-
-  private
-
-  def fix_syck_default_key_in_requirements # :nodoc:
-    Gem.load_yaml
-
-    # Fixup the Syck DefaultKey bug
-    @requirements.each do |r|
-      if r[0].kind_of? Gem::SyckDefaultKey
-        r[0] = "="
-      end
-    end
-  end
 end
 
 class Gem::Version
diff --git a/lib/rubygems/resolver.rb b/lib/rubygems/resolver.rb
index 71c35ea..51a11fe 100644
--- a/lib/rubygems/resolver.rb
+++ b/lib/rubygems/resolver.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: true
-require 'rubygems/dependency'
-require 'rubygems/exceptions'
-require 'rubygems/util/list'
+require_relative 'dependency'
+require_relative 'exceptions'
+require_relative 'util/list'
 
 ##
 # Given a set of Gem::Dependency objects as +needed+ and a way to query the
@@ -10,7 +10,7 @@ require 'rubygems/util/list'
 # all the requirements.
 
 class Gem::Resolver
-  require 'rubygems/resolver/molinillo'
+  require_relative 'resolver/molinillo'
 
   ##
   # If the DEBUG_RESOLVER environment variable is set then debugging mode is
@@ -318,30 +318,30 @@ class Gem::Resolver
   private :amount_constrained
 end
 
-require 'rubygems/resolver/activation_request'
-require 'rubygems/resolver/conflict'
-require 'rubygems/resolver/dependency_request'
-require 'rubygems/resolver/requirement_list'
-require 'rubygems/resolver/stats'
-
-require 'rubygems/resolver/set'
-require 'rubygems/resolver/api_set'
-require 'rubygems/resolver/composed_set'
-require 'rubygems/resolver/best_set'
-require 'rubygems/resolver/current_set'
-require 'rubygems/resolver/git_set'
-require 'rubygems/resolver/index_set'
-require 'rubygems/resolver/installer_set'
-require 'rubygems/resolver/lock_set'
-require 'rubygems/resolver/vendor_set'
-require 'rubygems/resolver/source_set'
-
-require 'rubygems/resolver/specification'
-require 'rubygems/resolver/spec_specification'
-require 'rubygems/resolver/api_specification'
-require 'rubygems/resolver/git_specification'
-require 'rubygems/resolver/index_specification'
-require 'rubygems/resolver/installed_specification'
-require 'rubygems/resolver/local_specification'
-require 'rubygems/resolver/lock_specification'
-require 'rubygems/resolver/vendor_specification'
+require_relative 'resolver/activation_request'
+require_relative 'resolver/conflict'
+require_relative 'resolver/dependency_request'
+require_relative 'resolver/requirement_list'
+require_relative 'resolver/stats'
+
+require_relative 'resolver/set'
+require_relative 'resolver/api_set'
+require_relative 'resolver/composed_set'
+require_relative 'resolver/best_set'
+require_relative 'resolver/current_set'
+require_relative 'resolver/git_set'
+require_relative 'resolver/index_set'
+require_relative 'resolver/installer_set'
+require_relative 'resolver/lock_set'
+require_relative 'resolver/vendor_set'
+require_relative 'resolver/source_set'
+
+require_relative 'resolver/specification'
+require_relative 'resolver/spec_specification'
+require_relative 'resolver/api_specification'
+require_relative 'resolver/git_specification'
+require_relative 'resolver/index_specification'
+require_relative 'resolver/installed_specification'
+require_relative 'resolver/local_specification'
+require_relative 'resolver/lock_specification'
+require_relative 'resolver/vendor_specification'
diff --git a/lib/rubygems/resolver/git_specification.rb b/lib/rubygems/resolver/git_specification.rb
index 555dcff..ee47080 100644
--- a/lib/rubygems/resolver/git_specification.rb
+++ b/lib/rubygems/resolver/git_specification.rb
@@ -21,7 +21,7 @@ class Gem::Resolver::GitSpecification < Gem::Resolver::SpecSpecification
   # the executables.
 
   def install(options = {})
-    require 'rubygems/installer'
+    require_relative '../installer'
 
     installer = Gem::Installer.for_spec spec, options
 
diff --git a/lib/rubygems/resolver/installer_set.rb b/lib/rubygems/resolver/installer_set.rb
index 6018131..237bc3f 100644
--- a/lib/rubygems/resolver/installer_set.rb
+++ b/lib/rubygems/resolver/installer_set.rb
@@ -71,17 +71,17 @@ class Gem::Resolver::InstallerSet < Gem::Resolver::Set
     end
 
     found = found.sort_by do |s|
-      [s.version, s.platform == Gem::Platform::RUBY ? -1 : 1]
+      [s.version, Gem::Platform.sort_priority(s.platform)]
     end
 
     newest = found.last
 
     unless @force
-      found_matching_metadata = found.select do |spec|
+      found_matching_metadata = found.reverse.find do |spec|
         metadata_satisfied?(spec)
       end
 
-      if found_matching_metadata.empty?
+      if found_matching_metadata.nil?
         if newest
           ensure_required_ruby_version_met(newest.spec)
           ensure_required_rubygems_version_met(newest.spec)
@@ -92,7 +92,7 @@ class Gem::Resolver::InstallerSet < Gem::Resolver::Set
           raise exc
         end
       else
-        newest = found_matching_metadata.last
+        newest = found_matching_metadata
       end
     end
 
diff --git a/lib/rubygems/resolver/molinillo.rb b/lib/rubygems/resolver/molinillo.rb
index 2357f41..12ca740 100644
--- a/lib/rubygems/resolver/molinillo.rb
+++ b/lib/rubygems/resolver/molinillo.rb
@@ -1,2 +1,2 @@
 # frozen_string_literal: true
-require 'rubygems/resolver/molinillo/lib/molinillo'
+require_relative 'molinillo/lib/molinillo'
diff --git a/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph.rb b/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph.rb
index 16430a7..95f8416 100644
--- a/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph.rb
+++ b/lib/rubygems/resolver/molinillo/lib/molinillo/dependency_graph.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
 
-require 'tsort'
+require_relative '../../../../tsort'
 
 require_relative 'dependency_graph/log'
 require_relative 'dependency_graph/vertex'
@@ -17,7 +17,7 @@ module Gem::Resolver::Molinillo
       vertices.values.each { |v| yield v }
     end
 
-    include TSort
+    include Gem::TSort
 
     # @!visibility private
     alias tsort_each_node each
diff --git a/lib/rubygems/resolver/set.rb b/lib/rubygems/resolver/set.rb
index 8046e18..5d8dd51 100644
--- a/lib/rubygems/resolver/set.rb
+++ b/lib/rubygems/resolver/set.rb
@@ -20,7 +20,6 @@ class Gem::Resolver::Set
   attr_accessor :prerelease
 
   def initialize # :nodoc:
-    require 'uri'
     @prerelease = false
     @remote     = true
     @errors     = []
diff --git a/lib/rubygems/resolver/specification.rb b/lib/rubygems/resolver/specification.rb
index 8c6fc9a..dfcb7eb 100644
--- a/lib/rubygems/resolver/specification.rb
+++ b/lib/rubygems/resolver/specification.rb
@@ -93,7 +93,7 @@ class Gem::Resolver::Specification
   # specification.
 
   def install(options = {})
-    require 'rubygems/installer'
+    require_relative '../installer'
 
     gem = download options
 
diff --git a/lib/rubygems/s3_uri_signer.rb b/lib/rubygems/s3_uri_signer.rb
index f1f9229..4d1deee 100644
--- a/lib/rubygems/s3_uri_signer.rb
+++ b/lib/rubygems/s3_uri_signer.rb
@@ -1,6 +1,4 @@
-require 'base64'
-require 'digest'
-require 'rubygems/openssl'
+require_relative 'openssl'
 
 ##
 # S3URISigner implements AWS SigV4 for S3 Source to avoid a dependency on the aws-sdk-* gems
@@ -88,7 +86,7 @@ class Gem::S3URISigner
       "AWS4-HMAC-SHA256",
       date_time,
       credential_info,
-      Digest::SHA256.hexdigest(canonical_request),
+      OpenSSL::Digest::SHA256.hexdigest(canonical_request),
     ].join("\n")
   end
 
@@ -141,8 +139,8 @@ class Gem::S3URISigner
 
   def ec2_metadata_credentials_json
     require 'net/http'
-    require 'rubygems/request'
-    require 'rubygems/request/connection_pools'
+    require_relative 'request'
+    require_relative 'request/connection_pools'
     require 'json'
 
     iam_info = ec2_metadata_request(EC2_IAM_INFO)
diff --git a/lib/rubygems/safe_yaml.rb b/lib/rubygems/safe_yaml.rb
index 29312ad..e905052 100644
--- a/lib/rubygems/safe_yaml.rb
+++ b/lib/rubygems/safe_yaml.rb
@@ -17,8 +17,6 @@ module Gem
       Gem::Specification
       Gem::Version
       Gem::Version::Requirement
-      YAML::Syck::DefaultKey
-      Syck::DefaultKey
     ].freeze
 
     PERMITTED_SYMBOLS = %w[
diff --git a/lib/rubygems/security.rb b/lib/rubygems/security.rb
index c80639a..f21c175 100644
--- a/lib/rubygems/security.rb
+++ b/lib/rubygems/security.rb
@@ -5,7 +5,7 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/exceptions'
+require_relative 'exceptions'
 require_relative 'openssl'
 
 ##
@@ -152,6 +152,7 @@ require_relative 'openssl'
 #                                      certificate for EMAIL_ADDR
 #     -C, --certificate CERT           Signing certificate for --sign
 #     -K, --private-key KEY            Key for --sign or --build
+#     -A, --key-algorithm ALGORITHM    Select key algorithm for --build from RSA, DSA, or EC. Defaults to RSA.
 #     -s, --sign CERT                  Signs CERT with the key from -K
 #                                      and the certificate from -C
 #     -d, --days NUMBER_OF_DAYS        Days before the certificate expires
@@ -317,7 +318,6 @@ require_relative 'openssl'
 # * Honor extension restrictions
 # * Might be better to store the certificate chain as a PKCS#7 or PKCS#12
 #   file, instead of an array embedded in the metadata.
-# * Flexible signature and key algorithms, not hard-coded to RSA and SHA1.
 #
 # == Original author
 #
@@ -337,17 +337,19 @@ module Gem::Security
   DIGEST_NAME = 'SHA256' # :nodoc:
 
   ##
-  # Algorithm for creating the key pair used to sign gems
+  # Length of keys created by RSA and DSA keys
 
-  KEY_ALGORITHM =
-    if defined?(OpenSSL::PKey::RSA)
-      OpenSSL::PKey::RSA
-    end
+  RSA_DSA_KEY_LENGTH = 3072
 
   ##
-  # Length of keys created by KEY_ALGORITHM
+  # Default algorithm to use when building a key pair
 
-  KEY_LENGTH = 3072
+  DEFAULT_KEY_ALGORITHM = 'RSA'
+
+  ##
+  # Named curve used for Elliptic Curve
+
+  EC_NAME = 'secp384r1'
 
   ##
   # Cipher used to encrypt the key pair used to sign gems.
@@ -400,7 +402,7 @@ module Gem::Security
                        serial = 1)
     cert = OpenSSL::X509::Certificate.new
 
-    cert.public_key = key.public_key
+    cert.public_key = get_public_key(key)
     cert.version    = 2
     cert.serial     = serial
 
@@ -418,6 +420,26 @@ module Gem::Security
     cert
   end
 
+  ##
+  # Gets the right public key from a PKey instance
+
+  def self.get_public_key(key)
+    # Ruby 3.0 (Ruby/OpenSSL 2.2) or later
+    return OpenSSL::PKey.read(key.public_to_der) if key.respond_to?(:public_to_der)
+    return key.public_key unless key.is_a?(OpenSSL::PKey::EC)
+
+    ec_key = OpenSSL::PKey::EC.new(key.group.curve_name)
+    ec_key.public_key = key.public_key
+    ec_key
+  end
+
+  ##
+  # In Ruby 2.3 EC doesn't implement the private_key? but not the private? method
+
+  if defined?(OpenSSL::PKey::EC) && Gem::Version.new(String.new(RUBY_VERSION)) < Gem::Version.new("2.4.0")
+    OpenSSL::PKey::EC.send(:alias_method, :private?, :private_key?)
+  end
+
   ##
   # Creates a self-signed certificate with an issuer and subject from +email+,
   # a subject alternative name of +email+ and the given +extensions+ for the
@@ -459,11 +481,29 @@ module Gem::Security
   end
 
   ##
-  # Creates a new key pair of the specified +length+ and +algorithm+.  The
-  # default is a 3072 bit RSA key.
-
-  def self.create_key(length = KEY_LENGTH, algorithm = KEY_ALGORITHM)
-    algorithm.new length
+  # Creates a new key pair of the specified +algorithm+. RSA, DSA, and EC
+  # are supported.
+
+  def self.create_key(algorithm)
+    if defined?(OpenSSL::PKey)
+      case algorithm.downcase
+      when 'dsa'
+        OpenSSL::PKey::DSA.new(RSA_DSA_KEY_LENGTH)
+      when 'rsa'
+        OpenSSL::PKey::RSA.new(RSA_DSA_KEY_LENGTH)
+      when 'ec'
+        if RUBY_VERSION >= "2.4.0"
+          OpenSSL::PKey::EC.generate(EC_NAME)
+        else
+          domain_key = OpenSSL::PKey::EC.new(EC_NAME)
+          domain_key.generate_key
+          domain_key
+        end
+      else
+        raise Gem::Security::Exception,
+        "#{algorithm} algorithm not found. RSA, DSA, and EC algorithms are supported."
+      end
+    end
   end
 
   ##
@@ -476,9 +516,10 @@ module Gem::Security
 
     dcs = dcs.split '.'
 
-    name = "CN=#{cn}/#{dcs.map {|dc| "DC=#{dc}" }.join '/'}"
-
-    OpenSSL::X509::Name.parse name
+    OpenSSL::X509::Name.new([
+      ["CN", cn],
+      *dcs.map {|dc| ["DC", dc] },
+    ])
   end
 
   ##
@@ -492,7 +533,7 @@ module Gem::Security
     raise Gem::Security::Exception,
           "incorrect signing key for re-signing " +
           "#{expired_certificate.subject}" unless
-      expired_certificate.public_key.to_pem == private_key.public_key.to_pem
+      expired_certificate.check_private_key(private_key)
 
     unless expired_certificate.subject.to_s ==
            expired_certificate.issuer.to_s
@@ -592,9 +633,9 @@ module Gem::Security
 end
 
 if Gem::HAVE_OPENSSL
-  require 'rubygems/security/policy'
-  require 'rubygems/security/policies'
-  require 'rubygems/security/trust_dir'
+  require_relative 'security/policy'
+  require_relative 'security/policies'
+  require_relative 'security/trust_dir'
 end
 
-require 'rubygems/security/signer'
+require_relative 'security/signer'
diff --git a/lib/rubygems/security/policy.rb b/lib/rubygems/security/policy.rb
index 7629d64..06eae07 100644
--- a/lib/rubygems/security/policy.rb
+++ b/lib/rubygems/security/policy.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require 'rubygems/user_interaction'
+require_relative '../user_interaction'
 
 ##
 # A Gem::Security::Policy object encapsulates the settings for verifying
@@ -117,7 +117,7 @@ class Gem::Security::Policy
 
     raise Gem::Security::Exception,
       "certificate #{signer.subject} does not match the signing key" unless
-        signer.public_key.to_pem == key.public_key.to_pem
+        signer.check_private_key(key)
 
     true
   end
@@ -164,9 +164,9 @@ class Gem::Security::Policy
     end
 
     save_cert = OpenSSL::X509::Certificate.new File.read path
-    save_dgst = digester.digest save_cert.public_key.to_s
+    save_dgst = digester.digest save_cert.public_key.to_pem
 
-    pkey_str = root.public_key.to_s
+    pkey_str = root.public_key.to_pem
     cert_dgst = digester.digest pkey_str
 
     raise Gem::Security::Exception,
diff --git a/lib/rubygems/security/signer.rb b/lib/rubygems/security/signer.rb
index 6c85ab0..968cf88 100644
--- a/lib/rubygems/security/signer.rb
+++ b/lib/rubygems/security/signer.rb
@@ -2,7 +2,7 @@
 ##
 # Basic OpenSSL-based package signing class.
 
-require "rubygems/user_interaction"
+require_relative "../user_interaction"
 
 class Gem::Security::Signer
   include Gem::UserInteraction
@@ -83,8 +83,8 @@ class Gem::Security::Signer
     @digest_name      = Gem::Security::DIGEST_NAME
     @digest_algorithm = Gem::Security.create_digest(@digest_name)
 
-    if @key && !@key.is_a?(OpenSSL::PKey::RSA)
-      @key = OpenSSL::PKey::RSA.new(File.read(@key), @passphrase)
+    if @key && !@key.is_a?(OpenSSL::PKey::PKey)
+      @key = OpenSSL::PKey.read(File.read(@key), @passphrase)
     end
 
     if @cert_chain
@@ -177,8 +177,7 @@ class Gem::Security::Signer
     disk_cert = File.read(disk_cert_path) rescue nil
 
     disk_key_path = File.join(Gem.default_key_path)
-    disk_key =
-      OpenSSL::PKey::RSA.new(File.read(disk_key_path), @passphrase) rescue nil
+    disk_key = OpenSSL::PKey.read(File.read(disk_key_path), @passphrase) rescue nil
 
     return unless disk_key
 
diff --git a/lib/rubygems/security_option.rb b/lib/rubygems/security_option.rb
index 3403aaa..a4c570d 100644
--- a/lib/rubygems/security_option.rb
+++ b/lib/rubygems/security_option.rb
@@ -5,7 +5,7 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems'
+require_relative '../rubygems'
 
 # forward-declare
 
@@ -19,16 +19,16 @@ end
 
 module Gem::SecurityOption
   def add_security_option
-    OptionParser.accept Gem::Security::Policy do |value|
-      require 'rubygems/security'
+    Gem::OptionParser.accept Gem::Security::Policy do |value|
+      require_relative 'security'
 
-      raise OptionParser::InvalidArgument, 'OpenSSL not installed' unless
+      raise Gem::OptionParser::InvalidArgument, 'OpenSSL not installed' unless
         defined?(Gem::Security::HighSecurity)
 
       policy = Gem::Security::Policies[value]
       unless policy
         valid = Gem::Security::Policies.keys.sort
-        raise OptionParser::InvalidArgument, "#{value} (#{valid.join ', '} are valid)"
+        raise Gem::OptionParser::InvalidArgument, "#{value} (#{valid.join ', '} are valid)"
       end
       policy
     end
diff --git a/lib/rubygems/server.rb b/lib/rubygems/server.rb
deleted file mode 100644
index 2c2805f..0000000
--- a/lib/rubygems/server.rb
+++ /dev/null
@@ -1,882 +0,0 @@
-# frozen_string_literal: true
-require 'zlib'
-require 'erb'
-require 'uri'
-
-require 'rubygems'
-require 'rubygems/rdoc'
-
-##
-# Gem::Server and allows users to serve gems for consumption by
-# `gem --remote-install`.
-#
-# gem_server starts an HTTP server on the given port and serves the following:
-# * "/" - Browsing of gem spec files for installed gems
-# * "/specs.#{Gem.marshal_version}.gz" - specs name/version/platform index
-# * "/latest_specs.#{Gem.marshal_version}.gz" - latest specs
-#   name/version/platform index
-# * "/quick/" - Individual gemspecs
-# * "/gems" - Direct access to download the installable gems
-# * "/rdoc?q=" - Search for installed rdoc documentation
-#
-# == Usage
-#
-#   gem_server = Gem::Server.new Gem.dir, 8089, false
-#   gem_server.run
-#
-#--
-# TODO Refactor into a real WEBrick servlet to remove code duplication.
-
-class Gem::Server
-  attr_reader :spec_dirs
-
-  include ERB::Util
-  include Gem::UserInteraction
-
-  SEARCH = <<-ERB.freeze
-      <form class="headerSearch" name="headerSearchForm" method="get" action="/rdoc">
-        <div id="search" style="float:right">
-          <label for="q">Filter/Search</label>
-          <input id="q" type="text" style="width:10em" name="q">
-          <button type="submit" style="display:none"></button>
-        </div>
-      </form>
-  ERB
-
-  DOC_TEMPLATE = <<-'ERB'.freeze
-  <?xml version="1.0" encoding="iso-8859-1"?>
-  <!DOCTYPE html
-       PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
-       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
-
-  <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
-  <head>
-    <title>RubyGems Documentation Index</title>
-    <link rel="stylesheet" href="gem-server-rdoc-style.css" type="text/css" media="screen" />
-  </head>
-  <body>
-    <div id="fileHeader">
-<%= SEARCH %>
-      <h1>RubyGems Documentation Index</h1>
-    </div>
-    <!-- banner header -->
-
-  <div id="bodyContent">
-    <div id="contextContent">
-      <div id="description">
-        <h1>Summary</h1>
-  <p>There are <%=values["gem_count"]%> gems installed:</p>
-  <p>
-  <%= values["specs"].map { |v| "<a href=\"##{u v["name"]}\">#{h v["name"]}</a>" }.join ', ' %>.
-  <h1>Gems</h1>
-
-  <dl>
-  <% values["specs"].each do |spec| %>
-    <dt>
-    <% if spec["first_name_entry"] then %>
-      <a name="<%=h spec["name"]%>"></a>
-    <% end %>
-
-    <b><%=h spec["name"]%> <%=h spec["version"]%></b>
-
-    <% if spec["ri_installed"] || spec["rdoc_installed"] then %>
-      <a href="<%=spec["doc_path"]%>">[rdoc]</a>
-    <% else %>
-      <span title="rdoc not installed">[rdoc]</span>
-    <% end %>
-
-    <% if spec["homepage"] then %>
-      <a href="<%=uri_encode spec["homepage"]%>" title="<%=h spec["homepage"]%>">[www]</a>
-    <% else %>
-      <span title="no homepage available">[www]</span>
-    <% end %>
-
-    <% if spec["has_deps"] then %>
-     - depends on
-      <%= spec["dependencies"].map { |v| "<a href=\"##{u v["name"]}\">#{h v["name"]}</a>" }.join ', ' %>.
-    <% end %>
-    </dt>
-    <dd>
-    <%=spec["summary"]%>
-    <% if spec["executables"] then %>
-      <br/>
-
-      <% if spec["only_one_executable"] then %>
-          Executable is
-      <% else %>
-          Executables are
-      <%end%>
-
-      <%= spec["executables"].map { |v| "<span class=\"context-item-name\">#{h v["executable"]}</span>"}.join ', ' %>.
-
-    <%end%>
-    <br/>
-    <br/>
-    </dd>
-  <% end %>
-  </dl>
-
-      </div>
-     </div>
-    </div>
-  <div id="validator-badges">
-    <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
-  </div>
-  </body>
-  </html>
-  ERB
-
-  # CSS is copy & paste from rdoc-style.css, RDoc V1.0.1 - 20041108
-  RDOC_CSS = <<-CSS.freeze
-body {
-    font-family: Verdana,Arial,Helvetica,sans-serif;
-    font-size:   90%;
-    margin: 0;
-    margin-left: 40px;
-    padding: 0;
-    background: white;
-}
-
-h1,h2,h3,h4 { margin: 0; color: #efefef; background: transparent; }
-h1 { font-size: 150%; }
-h2,h3,h4 { margin-top: 1em; }
-
-a { background: #eef; color: #039; text-decoration: none; }
-a:hover { background: #039; color: #eef; }
-
-/* Override the base stylesheets Anchor inside a table cell */
-td > a {
-  background: transparent;
-  color: #039;
-  text-decoration: none;
-}
-
-/* and inside a section title */
-.section-title > a {
-  background: transparent;
-  color: #eee;
-  text-decoration: none;
-}
-
-/* === Structural elements =================================== */
-
-div#index {
-    margin: 0;
-    margin-left: -40px;
-    padding: 0;
-    font-size: 90%;
-}
-
-
-div#index a {
-    margin-left: 0.7em;
-}
-
-div#index .section-bar {
-   margin-left: 0px;
-   padding-left: 0.7em;
-   background: #ccc;
-   font-size: small;
-}
-
-
-div#classHeader, div#fileHeader {
-    width: auto;
-    color: white;
-    padding: 0.5em 1.5em 0.5em 1.5em;
-    margin: 0;
-    margin-left: -40px;
-    border-bottom: 3px solid #006;
-}
-
-div#classHeader a, div#fileHeader a {
-    background: inherit;
-    color: white;
-}
-
-div#classHeader td, div#fileHeader td {
-    background: inherit;
-    color: white;
-}
-
-
-div#fileHeader {
-    background: #057;
-}
-
-div#classHeader {
-    background: #048;
-}
-
-
-.class-name-in-header {
-  font-size:  180%;
-  font-weight: bold;
-}
-
-
-div#bodyContent {
-    padding: 0 1.5em 0 1.5em;
-}
-
-div#description {
-    padding: 0.5em 1.5em;
-    background: #efefef;
-    border: 1px dotted #999;
-}
-
-div#description h1,h2,h3,h4,h5,h6 {
-    color: #125;;
-    background: transparent;
-}
-
-div#validator-badges {
-    text-align: center;
-}
-div#validator-badges img { border: 0; }
-
-div#copyright {
-    color: #333;
-    background: #efefef;
-    font: 0.75em sans-serif;
-    margin-top: 5em;
-    margin-bottom: 0;
-    padding: 0.5em 2em;
-}
-
-
-/* === Classes =================================== */
-
-table.header-table {
-    color: white;
-    font-size: small;
-}
-
-.type-note {
-    font-size: small;
-    color: #DEDEDE;
-}
-
-.xxsection-bar {
-    background: #eee;
-    color: #333;
-    padding: 3px;
-}
-
-.section-bar {
-   color: #333;
-   border-bottom: 1px solid #999;
-    margin-left: -20px;
-}
-
-
-.section-title {
-    background: #79a;
-    color: #eee;
-    padding: 3px;
-    margin-top: 2em;
-    margin-left: -30px;
-    border: 1px solid #999;
-}
-
-.top-aligned-row {  vertical-align: top }
-.bottom-aligned-row { vertical-align: bottom }
-
-/* --- Context section classes ----------------------- */
-
-.context-row { }
-.context-item-name { font-family: monospace; font-weight: bold; color: black; }
-.context-item-value { font-size: small; color: #448; }
-.context-item-desc { color: #333; padding-left: 2em; }
-
-/* --- Method classes -------------------------- */
-.method-detail {
-    background: #efefef;
-    padding: 0;
-    margin-top: 0.5em;
-    margin-bottom: 1em;
-    border: 1px dotted #ccc;
-}
-.method-heading {
-  color: black;
-  background: #ccc;
-  border-bottom: 1px solid #666;
-  padding: 0.2em 0.5em 0 0.5em;
-}
-.method-signature { color: black; background: inherit; }
-.method-name { font-weight: bold; }
-.method-args { font-style: italic; }
-.method-description { padding: 0 0.5em 0 0.5em; }
-
-/* --- Source code sections -------------------- */
-
-a.source-toggle { font-size: 90%; }
-div.method-source-code {
-    background: #262626;
-    color: #ffdead;
-    margin: 1em;
-    padding: 0.5em;
-    border: 1px dashed #999;
-    overflow: hidden;
-}
-
-div.method-source-code pre { color: #ffdead; overflow: hidden; }
-
-/* --- Ruby keyword styles --------------------- */
-
-.standalone-code { background: #221111; color: #ffdead; overflow: hidden; }
-
-.ruby-constant  { color: #7fffd4; background: transparent; }
-.ruby-keyword { color: #00ffff; background: transparent; }
-.ruby-ivar    { color: #eedd82; background: transparent; }
-.ruby-operator  { color: #00ffee; background: transparent; }
-.ruby-identifier { color: #ffdead; background: transparent; }
-.ruby-node    { color: #ffa07a; background: transparent; }
-.ruby-comment { color: #b22222; font-weight: bold; background: transparent; }
-.ruby-regexp  { color: #ffa07a; background: transparent; }
-.ruby-value   { color: #7fffd4; background: transparent; }
-  CSS
-
-  RDOC_NO_DOCUMENTATION = <<-'ERB'.freeze
-<?xml version="1.0" encoding="iso-8859-1"?>
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
-          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
-  <head>
-    <title>Found documentation</title>
-    <link rel="stylesheet" href="gem-server-rdoc-style.css" type="text/css" media="screen" />
-  </head>
-  <body>
-    <div id="fileHeader">
-<%= SEARCH %>
-      <h1>No documentation found</h1>
-    </div>
-
-    <div id="bodyContent">
-      <div id="contextContent">
-        <div id="description">
-          <p>No gems matched <%= h query.inspect %></p>
-
-          <p>
-            Back to <a href="/">complete gem index</a>
-          </p>
-
-        </div>
-      </div>
-    </div>
-    <div id="validator-badges">
-      <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
-    </div>
-  </body>
-</html>
-  ERB
-
-  RDOC_SEARCH_TEMPLATE = <<-'ERB'.freeze
-<?xml version="1.0" encoding="iso-8859-1"?>
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
-          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
-  <head>
-    <title>Found documentation</title>
-    <link rel="stylesheet" href="gem-server-rdoc-style.css" type="text/css" media="screen" />
-  </head>
-  <body>
-    <div id="fileHeader">
-<%= SEARCH %>
-      <h1>Found documentation</h1>
-    </div>
-    <!-- banner header -->
-
-    <div id="bodyContent">
-      <div id="contextContent">
-        <div id="description">
-          <h1>Summary</h1>
-          <p><%=doc_items.length%> documentation topics found.</p>
-          <h1>Topics</h1>
-
-          <dl>
-          <% doc_items.each do |doc_item| %>
-            <dt>
-              <b><%=doc_item[:name]%></b>
-              <a href="<%=u doc_item[:url]%>">[rdoc]</a>
-            </dt>
-            <dd>
-              <%=h doc_item[:summary]%>
-              <br/>
-              <br/>
-            </dd>
-          <% end %>
-          </dl>
-
-          <p>
-            Back to <a href="/">complete gem index</a>
-          </p>
-
-        </div>
-      </div>
-    </div>
-    <div id="validator-badges">
-      <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
-    </div>
-  </body>
-</html>
-  ERB
-
-  def self.run(options)
-    new(options[:gemdir], options[:port], options[:daemon],
-        options[:launch], options[:addresses]).run
-  end
-
-  def initialize(gem_dirs, port, daemon, launch = nil, addresses = nil)
-    begin
-      require 'webrick'
-    rescue LoadError
-      abort "webrick is not found. You may need to `gem install webrick` to install webrick."
-    end
-
-    Gem::RDoc.load_rdoc
-    Socket.do_not_reverse_lookup = true
-
-    @gem_dirs  = Array gem_dirs
-    @port      = port
-    @daemon    = daemon
-    @launch    = launch
-    @addresses = addresses
-
-    logger  = WEBrick::Log.new nil, WEBrick::BasicLog::FATAL
-    @server = WEBrick::HTTPServer.new :DoNotListen => true, :Logger => logger
-
-    @spec_dirs = @gem_dirs.map {|gem_dir| File.join gem_dir, 'specifications' }
-    @spec_dirs.reject! {|spec_dir| !File.directory? spec_dir }
-
-    reset_gems
-
-    @have_rdoc_4_plus = nil
-  end
-
-  def add_date(res)
-    res['date'] = @spec_dirs.map do |spec_dir|
-      File.stat(spec_dir).mtime
-    end.max
-  end
-
-  def uri_encode(str)
-    str.gsub(URI::UNSAFE) do |match|
-      match.each_byte.map {|c| sprintf('%%%02X', c.ord) }.join
-    end
-  end
-
-  def doc_root(gem_name)
-    if have_rdoc_4_plus?
-      "/doc_root/#{u gem_name}/"
-    else
-      "/doc_root/#{u gem_name}/rdoc/index.html"
-    end
-  end
-
-  def have_rdoc_4_plus?
-    @have_rdoc_4_plus ||=
-      Gem::Requirement.new('>= 4.0.0.preview2').satisfied_by? Gem::RDoc.rdoc_version
-  end
-
-  def latest_specs(req, res)
-    reset_gems
-
-    res['content-type'] = 'application/x-gzip'
-
-    add_date res
-
-    latest_specs = Gem::Specification.latest_specs
-
-    specs = latest_specs.sort.map do |spec|
-      platform = spec.original_platform || Gem::Platform::RUBY
-      [spec.name, spec.version, platform]
-    end
-
-    specs = Marshal.dump specs
-
-    if req.path =~ /\.gz$/
-      specs = Gem::Util.gzip specs
-      res['content-type'] = 'application/x-gzip'
-    else
-      res['content-type'] = 'application/octet-stream'
-    end
-
-    if req.request_method == 'HEAD'
-      res['content-length'] = specs.length
-    else
-      res.body << specs
-    end
-  end
-
-  ##
-  # Creates server sockets based on the addresses option.  If no addresses
-  # were given a server socket for all interfaces is created.
-
-  def listen(addresses = @addresses)
-    addresses = [nil] unless addresses
-
-    listeners = 0
-
-    addresses.each do |address|
-      begin
-        @server.listen address, @port
-        @server.listeners[listeners..-1].each do |listener|
-          host, port = listener.addr.values_at 2, 1
-          host = "[#{host}]" if host =~ /:/ # we don't reverse lookup
-          say "Server started at http://#{host}:#{port}"
-        end
-
-        listeners = @server.listeners.length
-      rescue SystemCallError
-        next
-      end
-    end
-
-    if @server.listeners.empty?
-      say "Unable to start a server."
-      say "Check for running servers or your --bind and --port arguments"
-      terminate_interaction 1
-    end
-  end
-
-  def prerelease_specs(req, res)
-    reset_gems
-
-    res['content-type'] = 'application/x-gzip'
-
-    add_date res
-
-    specs = Gem::Specification.select do |spec|
-      spec.version.prerelease?
-    end.sort.map do |spec|
-      platform = spec.original_platform || Gem::Platform::RUBY
-      [spec.name, spec.version, platform]
-    end
-
-    specs = Marshal.dump specs
-
-    if req.path =~ /\.gz$/
-      specs = Gem::Util.gzip specs
-      res['content-type'] = 'application/x-gzip'
-    else
-      res['content-type'] = 'application/octet-stream'
-    end
-
-    if req.request_method == 'HEAD'
-      res['content-length'] = specs.length
-    else
-      res.body << specs
-    end
-  end
-
-  def quick(req, res)
-    reset_gems
-
-    res['content-type'] = 'text/plain'
-    add_date res
-
-    case req.request_uri.path
-    when %r{^/quick/(Marshal.#{Regexp.escape Gem.marshal_version}/)?(.*?)\.gemspec\.rz$} then
-      marshal_format, full_name = $1, $2
-      specs = Gem::Specification.find_all_by_full_name(full_name)
-
-      selector = full_name.inspect
-
-      if specs.empty?
-        res.status = 404
-        res.body = "No gems found matching #{selector}"
-      elsif specs.length > 1
-        res.status = 500
-        res.body = "Multiple gems found matching #{selector}"
-      elsif marshal_format
-        res['content-type'] = 'application/x-deflate'
-        res.body << Gem.deflate(Marshal.dump(specs.first))
-      end
-    else
-      raise WEBrick::HTTPStatus::NotFound, "`#{req.path}' not found."
-    end
-  end
-
-  def root(req, res)
-    reset_gems
-
-    add_date res
-
-    raise WEBrick::HTTPStatus::NotFound, "`#{req.path}' not found." unless
-      req.path == '/'
-
-    specs = []
-    total_file_count = 0
-
-    Gem::Specification.each do |spec|
-      total_file_count += spec.files.size
-      deps = spec.dependencies.map do |dep|
-        {
-          "name"    => dep.name,
-          "type"    => dep.type,
-          "version" => dep.requirement.to_s,
-        }
-      end
-
-      deps = deps.sort_by {|dep| [dep["name"].downcase, dep["version"]] }
-      deps.last["is_last"] = true unless deps.empty?
-
-      # executables
-      executables = spec.executables.sort.collect {|exec| {"executable" => exec} }
-      executables = nil if executables.empty?
-      executables.last["is_last"] = true if executables
-
-      # Pre-process spec homepage for safety reasons
-      begin
-        homepage_uri = URI.parse(spec.homepage)
-        if [URI::HTTP, URI::HTTPS].member? homepage_uri.class
-          homepage_uri = spec.homepage
-        else
-          homepage_uri = "."
-        end
-      rescue URI::InvalidURIError
-        homepage_uri = "."
-      end
-
-      specs << {
-        "authors"             => spec.authors.sort.join(", "),
-        "date"                => spec.date.to_s,
-        "dependencies"        => deps,
-        "doc_path"            => doc_root(spec.full_name),
-        "executables"         => executables,
-        "only_one_executable" => (executables && executables.size == 1),
-        "full_name"           => spec.full_name,
-        "has_deps"            => !deps.empty?,
-        "homepage"            => homepage_uri,
-        "name"                => spec.name,
-        "rdoc_installed"      => Gem::RDoc.new(spec).rdoc_installed?,
-        "ri_installed"        => Gem::RDoc.new(spec).ri_installed?,
-        "summary"             => spec.summary,
-        "version"             => spec.version.to_s,
-      }
-    end
-
-    specs << {
-      "authors" => "Chad Fowler, Rich Kilmer, Jim Weirich, Eric Hodel and others",
-      "dependencies" => [],
-      "doc_path" => doc_root("rubygems-#{Gem::VERSION}"),
-      "executables" => [{"executable" => 'gem', "is_last" => true}],
-      "only_one_executable" => true,
-      "full_name" => "rubygems-#{Gem::VERSION}",
-      "has_deps" => false,
-      "homepage" => "https://guides.rubygems.org/",
-      "name" => 'rubygems',
-      "ri_installed" => true,
-      "summary" => "RubyGems itself",
-      "version" => Gem::VERSION,
-    }
-
-    specs = specs.sort_by {|spec| [spec["name"].downcase, spec["version"]] }
-    specs.last["is_last"] = true
-
-    # tag all specs with first_name_entry
-    last_spec = nil
-    specs.each do |spec|
-      is_first = last_spec.nil? || (last_spec["name"].downcase != spec["name"].downcase)
-      spec["first_name_entry"] = is_first
-      last_spec = spec
-    end
-
-    # create page from template
-    template = ERB.new(DOC_TEMPLATE)
-    res['content-type'] = 'text/html'
-
-    values = { "gem_count" => specs.size.to_s, "specs" => specs,
-               "total_file_count" => total_file_count.to_s }
-
-    # suppress 1.9.3dev warning about unused variable
-    values = values
-
-    result = template.result binding
-    res.body = result
-  end
-
-  ##
-  # Can be used for quick navigation to the rdoc documentation.  You can then
-  # define a search shortcut for your browser.  E.g. in Firefox connect
-  # 'shortcut:rdoc' to http://localhost:8808/rdoc?q=%s template. Then you can
-  # directly open the ActionPack documentation by typing 'rdoc actionp'. If
-  # there are multiple hits for the search term, they are presented as a list
-  # with links.
-  #
-  # Search algorithm aims for an intuitive search:
-  # 1. first try to find the gems and documentation folders which name
-  #    starts with the search term
-  # 2. search for entries, that *contain* the search term
-  # 3. show all the gems
-  #
-  # If there is only one search hit, user is immediately redirected to the
-  # documentation for the particular gem, otherwise a list with results is
-  # shown.
-  #
-  # === Additional trick - install documentation for Ruby core
-  #
-  # Note: please adjust paths accordingly use for example 'locate yaml.rb' and
-  # 'gem environment' to identify directories, that are specific for your
-  # local installation
-  #
-  # 1. install Ruby sources
-  #      cd /usr/src
-  #      sudo apt-get source ruby
-  #
-  # 2. generate documentation
-  #      rdoc -o /usr/lib/ruby/gems/1.8/doc/core/rdoc \
-  #        /usr/lib/ruby/1.8 ruby1.8-1.8.7.72
-  #
-  # By typing 'rdoc core' you can now access the core documentation
-
-  def rdoc(req, res)
-    query = req.query['q']
-    show_rdoc_for_pattern("#{query}*", res) && return
-    show_rdoc_for_pattern("*#{query}*", res) && return
-
-    template = ERB.new RDOC_NO_DOCUMENTATION
-
-    res['content-type'] = 'text/html'
-    res.body = template.result binding
-  end
-
-  ##
-  # Updates the server to use the latest installed gems.
-
-  def reset_gems # :nodoc:
-    Gem::Specification.dirs = @gem_dirs
-  end
-
-  ##
-  # Returns true and prepares http response, if rdoc for the requested gem
-  # name pattern was found.
-  #
-  # The search is based on the file system content, not on the gems metadata.
-  # This allows additional documentation folders like 'core' for the Ruby core
-  # documentation - just put it underneath the main doc folder.
-
-  def show_rdoc_for_pattern(pattern, res)
-    found_gems = Dir.glob("{#{@gem_dirs.join ','}}/doc/#{pattern}").select do |path|
-      File.exist? File.join(path, 'rdoc/index.html')
-    end
-    case found_gems.length
-    when 0
-      return false
-    when 1
-      new_path = File.basename(found_gems[0])
-      res.status = 302
-      res['Location'] = doc_root new_path
-      return true
-    else
-      doc_items = []
-      found_gems.each do |file_name|
-        base_name = File.basename(file_name)
-        doc_items << {
-          :name    => base_name,
-          :url     => doc_root(new_path),
-          :summary => '',
-        }
-      end
-
-      template = ERB.new(RDOC_SEARCH_TEMPLATE)
-      res['content-type'] = 'text/html'
-      result = template.result binding
-      res.body = result
-      return true
-    end
-  end
-
-  def run
-    listen
-
-    WEBrick::Daemon.start if @daemon
-
-    @server.mount_proc "/specs.#{Gem.marshal_version}", method(:specs)
-    @server.mount_proc "/specs.#{Gem.marshal_version}.gz", method(:specs)
-
-    @server.mount_proc "/latest_specs.#{Gem.marshal_version}",
-                       method(:latest_specs)
-    @server.mount_proc "/latest_specs.#{Gem.marshal_version}.gz",
-                       method(:latest_specs)
-
-    @server.mount_proc "/prerelease_specs.#{Gem.marshal_version}",
-                       method(:prerelease_specs)
-    @server.mount_proc "/prerelease_specs.#{Gem.marshal_version}.gz",
-                       method(:prerelease_specs)
-
-    @server.mount_proc "/quick/", method(:quick)
-
-    @server.mount_proc("/gem-server-rdoc-style.css") do |req, res|
-      res['content-type'] = 'text/css'
-      add_date res
-      res.body << RDOC_CSS
-    end
-
-    @server.mount_proc "/", method(:root)
-
-    @server.mount_proc "/rdoc", method(:rdoc)
-
-    file_handlers = {
-      '/gems' => '/cache/',
-    }
-
-    if have_rdoc_4_plus?
-      @server.mount '/doc_root', RDoc::Servlet, '/doc_root'
-    else
-      file_handlers['/doc_root'] = '/doc/'
-    end
-
-    @gem_dirs.each do |gem_dir|
-      file_handlers.each do |mount_point, mount_dir|
-        @server.mount(mount_point, WEBrick::HTTPServlet::FileHandler,
-                      File.join(gem_dir, mount_dir), true)
-      end
-    end
-
-    trap("INT") { @server.shutdown; exit! }
-    trap("TERM") { @server.shutdown; exit! }
-
-    launch if @launch
-
-    @server.start
-  end
-
-  def specs(req, res)
-    reset_gems
-
-    add_date res
-
-    specs = Gem::Specification.sort_by(&:sort_obj).map do |spec|
-      platform = spec.original_platform || Gem::Platform::RUBY
-      [spec.name, spec.version, platform]
-    end
-
-    specs = Marshal.dump specs
-
-    if req.path =~ /\.gz$/
-      specs = Gem::Util.gzip specs
-      res['content-type'] = 'application/x-gzip'
-    else
-      res['content-type'] = 'application/octet-stream'
-    end
-
-    if req.request_method == 'HEAD'
-      res['content-length'] = specs.length
-    else
-      res.body << specs
-    end
-  end
-
-  def launch
-    listeners = @server.listeners.map{|l| l.addr[2] }
-
-    # TODO: 0.0.0.0 == any, not localhost.
-    host = listeners.any?{|l| l == '0.0.0.0' } ? 'localhost' : listeners.first
-
-    say "Launching browser to http://#{host}:#{@port}"
-
-    system("#{@launch} http://#{host}:#{@port}")
-  end
-end
diff --git a/lib/rubygems/source.rb b/lib/rubygems/source.rb
index 4ae84cf..f03e098 100644
--- a/lib/rubygems/source.rb
+++ b/lib/rubygems/source.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: true
 
-require "rubygems/text"
+require_relative "text"
 ##
 # A Source knows how to list and fetch gems from a RubyGems marshal index.
 #
@@ -35,6 +35,7 @@ class Gem::Source
     end
 
     @uri = uri
+    @update_cache = nil
   end
 
   ##
@@ -118,7 +119,8 @@ class Gem::Source
   # Returns true when it is possible and safe to update the cache directory.
 
   def update_cache?
-    @update_cache ||=
+    return @update_cache unless @update_cache.nil?
+    @update_cache =
       begin
         File.stat(Gem.user_home).uid == Process.uid
       rescue Errno::ENOENT
@@ -238,9 +240,9 @@ class Gem::Source
   end
 end
 
-require 'rubygems/source/git'
-require 'rubygems/source/installed'
-require 'rubygems/source/specific_file'
-require 'rubygems/source/local'
-require 'rubygems/source/lock'
-require 'rubygems/source/vendor'
+require_relative 'source/git'
+require_relative 'source/installed'
+require_relative 'source/specific_file'
+require_relative 'source/local'
+require_relative 'source/lock'
+require_relative 'source/vendor'
diff --git a/lib/rubygems/source/git.rb b/lib/rubygems/source/git.rb
index 9876adc..cda5aa8 100644
--- a/lib/rubygems/source/git.rb
+++ b/lib/rubygems/source/git.rb
@@ -225,7 +225,7 @@ class Gem::Source::Git < Gem::Source
   # A hash for the git gem based on the git repository URI.
 
   def uri_hash # :nodoc:
-    require 'digest' # required here to avoid deadlocking in Gem.activate_bin_path (because digest is a gem on 2.5+)
+    require_relative '../openssl'
 
     normalized =
       if @repository =~ %r{^\w+://(\w+@)?}
@@ -235,6 +235,6 @@ class Gem::Source::Git < Gem::Source
         @repository
       end
 
-    Digest::SHA1.hexdigest normalized
+    OpenSSL::Digest::SHA1.hexdigest normalized
   end
 end
diff --git a/lib/rubygems/spec_fetcher.rb b/lib/rubygems/spec_fetcher.rb
index b2bcadc..b97bd49 100644
--- a/lib/rubygems/spec_fetcher.rb
+++ b/lib/rubygems/spec_fetcher.rb
@@ -1,9 +1,9 @@
 # frozen_string_literal: true
-require 'rubygems/remote_fetcher'
-require 'rubygems/user_interaction'
-require 'rubygems/errors'
-require 'rubygems/text'
-require 'rubygems/name_tuple'
+require_relative 'remote_fetcher'
+require_relative 'user_interaction'
+require_relative 'errors'
+require_relative 'text'
+require_relative 'name_tuple'
 
 ##
 # SpecFetcher handles metadata updates from remote gem repositories.
@@ -121,7 +121,7 @@ class Gem::SpecFetcher
       end
     end
 
-    tuples = tuples.sort_by {|x| x[0] }
+    tuples = tuples.sort_by {|x| x[0].version }
 
     return [tuples, errors]
   end
diff --git a/lib/rubygems/specification.rb b/lib/rubygems/specification.rb
index 167e798..031a37f 100644
--- a/lib/rubygems/specification.rb
+++ b/lib/rubygems/specification.rb
@@ -6,11 +6,13 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/deprecate'
-require 'rubygems/basic_specification'
-require 'rubygems/stub_specification'
-require 'rubygems/specification_policy'
-require 'rubygems/util/list'
+require_relative 'deprecate'
+require_relative 'basic_specification'
+require_relative 'stub_specification'
+require_relative 'platform'
+require_relative 'requirement'
+require_relative 'specification_policy'
+require_relative 'util/list'
 
 ##
 # The Specification class contains the information for a gem.  Typically
@@ -102,12 +104,8 @@ class Gem::Specification < Gem::BasicSpecification
   today = Time.now.utc
   TODAY = Time.utc(today.year, today.month, today.day) # :nodoc:
 
-  # rubocop:disable Style/MutableConstant
-  LOAD_CACHE = {} # :nodoc:
-  # rubocop:enable Style/MutableConstant
-  LOAD_CACHE_MUTEX = Mutex.new
-
-  private_constant :LOAD_CACHE if defined? private_constant
+  @load_cache = {} # :nodoc:
+  @load_cache_mutex = Thread::Mutex.new
 
   VALID_NAME_PATTERN = /\A[a-zA-Z0-9\.\-\_]+\z/.freeze # :nodoc:
 
@@ -182,13 +180,19 @@ class Gem::Specification < Gem::BasicSpecification
     @@default_value[k].nil?
   end
 
-  @@stubs = nil
-  @@stubs_by_name = {}
+  def self.clear_specs # :nodoc:
+    @@all = nil
+    @@stubs = nil
+    @@stubs_by_name = {}
+    @@spec_with_requirable_file = {}
+    @@active_stub_with_requirable_file = {}
+  end
+  private_class_method :clear_specs
+
+  clear_specs
 
   # Sentinel object to represent "not found" stubs
   NOT_FOUND = Struct.new(:to_spec, :this).new # :nodoc:
-  @@spec_with_requirable_file = {}
-  @@active_stub_with_requirable_file = {}
 
   # Tracking removed method calls to warn users during build time.
   REMOVED_METHODS = [:rubyforge_project=].freeze # :nodoc:
@@ -281,6 +285,15 @@ class Gem::Specification < Gem::BasicSpecification
   ######################################################################
   # :section: Recommended gemspec attributes
 
+  ##
+  # The version of Ruby required by this gem
+  #
+  # Usage:
+  #
+  #   spec.required_ruby_version = '>= 2.7.0'
+
+  attr_reader :required_ruby_version
+
   ##
   # A long description of this gem
   #
@@ -324,17 +337,21 @@ class Gem::Specification < Gem::BasicSpecification
   # This should just be the name of your license. The full text of the license
   # should be inside of the gem (at the top level) when you build it.
   #
-  # The simplest way, is to specify the standard SPDX ID
+  # The simplest way is to specify the standard SPDX ID
   # https://spdx.org/licenses/ for the license.
-  # Ideally you should pick one that is OSI (Open Source Initiative)
+  # Ideally, you should pick one that is OSI (Open Source Initiative)
   # http://opensource.org/licenses/alphabetical approved.
   #
-  # The most commonly used OSI approved licenses are MIT and Apache-2.0.
+  # The most commonly used OSI-approved licenses are MIT and Apache-2.0.
   # GitHub also provides a license picker at http://choosealicense.com/.
   #
+  # You can also use a custom license file along with your gemspec and specify
+  # a LicenseRef-<idstring>, where idstring is the name of the file containing
+  # the license text.
+  #
   # You should specify a license for your gem so that people know how they are
-  # permitted to use it, and any restrictions you're placing on it.  Not
-  # specifying a license means all rights are reserved; others have no rights
+  # permitted to use it and any restrictions you're placing on it.  Not
+  # specifying a license means all rights are reserved; others have no right
   # to use the code for any purpose.
   #
   # You can set multiple licenses with #licenses=
@@ -512,11 +529,6 @@ class Gem::Specification < Gem::BasicSpecification
     @require_paths = Array(val)
   end
 
-  ##
-  # The version of Ruby required by this gem
-
-  attr_reader :required_ruby_version
-
   ##
   # The RubyGems version required by this gem
 
@@ -744,23 +756,15 @@ class Gem::Specification < Gem::BasicSpecification
   attr_accessor :specification_version
 
   def self._all # :nodoc:
-    unless defined?(@@all) && @@all
-      @@all = stubs.map(&:to_spec)
-
-      # After a reset, make sure already loaded specs
-      # are still marked as activated.
-      specs = {}
-      Gem.loaded_specs.each_value{|s| specs[s] = true }
-      @@all.each{|s| s.activated = true if specs[s] }
-    end
-    @@all
+    @@all ||= Gem.loaded_specs.values | stubs.map(&:to_spec)
   end
 
-  def self._clear_load_cache # :nodoc:
-    LOAD_CACHE_MUTEX.synchronize do
-      LOAD_CACHE.clear
+  def self.clear_load_cache # :nodoc:
+    @load_cache_mutex.synchronize do
+      @load_cache.clear
     end
   end
+  private_class_method :clear_load_cache
 
   def self.each_gemspec(dirs) # :nodoc:
     dirs.each do |dir|
@@ -855,7 +859,7 @@ class Gem::Specification < Gem::BasicSpecification
       next names if names.nonzero?
       versions = b.version <=> a.version
       next versions if versions.nonzero?
-      b.platform == Gem::Platform::RUBY ? -1 : 1
+      Gem::Platform.sort_priority(b.platform)
     end
   end
 
@@ -991,7 +995,6 @@ class Gem::Specification < Gem::BasicSpecification
   def self.find_by_path(path)
     path = path.dup.freeze
     spec = @@spec_with_requirable_file[path] ||= (stubs.find do |s|
-      next unless Gem::BundlerVersionFinder.compatible?(s)
       s.contains_requirable_file? path
     end || NOT_FOUND)
     spec.to_spec
@@ -1004,7 +1007,6 @@ class Gem::Specification < Gem::BasicSpecification
   def self.find_inactive_by_path(path)
     stub = stubs.find do |s|
       next if s.activated?
-      next unless Gem::BundlerVersionFinder.compatible?(s)
       s.contains_requirable_file? path
     end
     stub && stub.to_spec
@@ -1080,7 +1082,7 @@ class Gem::Specification < Gem::BasicSpecification
   # +prerelease+ is true.
 
   def self.latest_specs(prerelease = false)
-    _latest_specs Gem::Specification._all, prerelease
+    _latest_specs Gem::Specification.stubs, prerelease
   end
 
   ##
@@ -1108,13 +1110,13 @@ class Gem::Specification < Gem::BasicSpecification
   def self.load(file)
     return unless file
 
-    _spec = LOAD_CACHE_MUTEX.synchronize { LOAD_CACHE[file] }
+    _spec = @load_cache_mutex.synchronize { @load_cache[file] }
     return _spec if _spec
 
     file = file.dup.tap(&Gem::UNTAINT)
     return unless File.file?(file)
 
-    code = File.read file, :mode => 'r:UTF-8:-'
+    code = Gem.open_with_flock(file, 'r:UTF-8:-', &:read)
 
     code.tap(&Gem::UNTAINT)
 
@@ -1123,12 +1125,12 @@ class Gem::Specification < Gem::BasicSpecification
 
       if Gem::Specification === _spec
         _spec.loaded_from = File.expand_path file.to_s
-        LOAD_CACHE_MUTEX.synchronize do
-          prev = LOAD_CACHE[file]
+        @load_cache_mutex.synchronize do
+          prev = @load_cache[file]
           if prev
             _spec = prev
           else
-            LOAD_CACHE[file] = _spec
+            @load_cache[file] = _spec
           end
         end
         return _spec
@@ -1226,12 +1228,8 @@ class Gem::Specification < Gem::BasicSpecification
   def self.reset
     @@dirs = nil
     Gem.pre_reset_hooks.each {|hook| hook.call }
-    @@all = nil
-    @@stubs = nil
-    @@stubs_by_name = {}
-    @@spec_with_requirable_file = {}
-    @@active_stub_with_requirable_file = {}
-    _clear_load_cache
+    clear_specs
+    clear_load_cache
     unresolved = unresolved_deps
     unless unresolved.empty?
       w = "W" + "ARN"
@@ -1556,8 +1554,8 @@ class Gem::Specification < Gem::BasicSpecification
   # the gem.build_complete file is missing.
 
   def build_extensions # :nodoc:
-    return if default_gem?
     return if extensions.empty?
+    return if default_gem?
     return if File.exist? gem_build_complete_path
     return if !File.writable?(base_dir)
     return if !File.exist?(File.join(base_dir, 'extensions'))
@@ -1568,9 +1566,9 @@ class Gem::Specification < Gem::BasicSpecification
       unresolved_deps = Gem::Specification.unresolved_deps.dup
       Gem::Specification.unresolved_deps.clear
 
-      require 'rubygems/config_file'
-      require 'rubygems/ext'
-      require 'rubygems/user_interaction'
+      require_relative 'config_file'
+      require_relative 'ext'
+      require_relative 'user_interaction'
 
       ui = Gem::SilentUI.new
       Gem::DefaultUserInteraction.use_ui ui do
@@ -1690,19 +1688,11 @@ class Gem::Specification < Gem::BasicSpecification
             when String then
               if DateTimeFormat =~ date
                 Time.utc($1.to_i, $2.to_i, $3.to_i)
-
-              # Workaround for where the date format output from psych isn't
-              # parsed as a Time object by syck and thus comes through as a
-              # string.
-              elsif /\A(\d{4})-(\d{2})-(\d{2}) \d{2}:\d{2}:\d{2}\.\d+?Z\z/ =~ date
-                Time.utc($1.to_i, $2.to_i, $3.to_i)
               else
                 raise(Gem::InvalidSpecificationException,
                       "invalid date format in specification: #{date.inspect}")
               end
-            when Time then
-              Time.utc(date.utc.year, date.utc.month, date.utc.day)
-            when DateLike then
+            when Time, DateLike then
               Time.utc(date.year, date.month, date.day)
             else
               TODAY
@@ -2128,8 +2118,8 @@ class Gem::Specification < Gem::BasicSpecification
   # probably want to build_extensions
 
   def missing_extensions?
-    return false if default_gem?
     return false if extensions.empty?
+    return false if default_gem?
     return false if File.exist? gem_build_complete_path
 
     true
@@ -2341,7 +2331,7 @@ class Gem::Specification < Gem::BasicSpecification
   # Returns an object you can use to sort specifications in #sort_by.
 
   def sort_obj
-    [@name, @version, @new_platform == Gem::Platform::RUBY ? -1 : 1]
+    [@name, @version, Gem::Platform.sort_priority(@new_platform)]
   end
 
   ##
@@ -2533,7 +2523,7 @@ class Gem::Specification < Gem::BasicSpecification
     # back, we have to check again here to make sure that our
     # psych code was properly loaded, and load it if not.
     unless Gem.const_defined?(:NoAliasYAMLTree)
-      require 'rubygems/psych_tree'
+      require_relative 'psych_tree'
     end
 
     builder = Gem::NoAliasYAMLTree.create
diff --git a/lib/rubygems/specification_policy.rb b/lib/rubygems/specification_policy.rb
index 86277a2..73bd319 100644
--- a/lib/rubygems/specification_policy.rb
+++ b/lib/rubygems/specification_policy.rb
@@ -1,4 +1,4 @@
-require 'rubygems/user_interaction'
+require_relative 'user_interaction'
 
 class Gem::SpecificationPolicy
   include Gem::UserInteraction
@@ -381,7 +381,7 @@ http://spdx.org/licenses or '#{Gem::Licenses::NONSTANDARD}' for a nonstandard li
   end
 
   LAZY = '"FIxxxXME" or "TOxxxDO"'.gsub(/xxx/, '')
-  LAZY_PATTERN = /FI XME|TO DO/x.freeze
+  LAZY_PATTERN = /\AFI XME|\ATO DO/x.freeze
   HOMEPAGE_URI_PATTERN = /\A[a-z][a-z\d+.-]*:/i.freeze
 
   def validate_lazy_metadata
diff --git a/lib/rubygems/stub_specification.rb b/lib/rubygems/stub_specification.rb
index 4246f9d..47fe7da 100644
--- a/lib/rubygems/stub_specification.rb
+++ b/lib/rubygems/stub_specification.rb
@@ -110,7 +110,7 @@ class Gem::StubSpecification < Gem::BasicSpecification
       begin
         saved_lineno = $.
 
-        File.open loaded_from, OPEN_MODE do |file|
+        Gem.open_with_flock loaded_from, OPEN_MODE do |file|
           begin
             file.readline # discard encoding line
             stubline = file.readline.chomp
diff --git a/lib/rubygems/syck_hack.rb b/lib/rubygems/syck_hack.rb
deleted file mode 100644
index 051483e..0000000
--- a/lib/rubygems/syck_hack.rb
+++ /dev/null
@@ -1,77 +0,0 @@
-# frozen_string_literal: true
-# :stopdoc:
-
-# Hack to handle syck's DefaultKey bug
-#
-# This file is always loaded AFTER either syck or psych are already
-# loaded. It then looks at what constants are available and creates
-# a consistent view on all rubys.
-#
-# All this is so that there is always a YAML::Syck::DefaultKey
-# class no matter if the full yaml library has loaded or not.
-#
-
-module YAML # :nodoc:
-  # In newer 1.9.2, there is a Syck toplevel constant instead of it
-  # being underneath YAML. If so, reference it back under YAML as
-  # well.
-  if defined? ::Syck
-    # for tests that change YAML::ENGINE
-    # 1.8 does not support the second argument to const_defined?
-    remove_const :Syck rescue nil
-
-    Syck = ::Syck
-
-  # JRuby's "Syck" is called "Yecht"
-  elsif defined? YAML::Yecht
-    Syck = YAML::Yecht
-
-  # Otherwise, if there is no YAML::Syck, then we've got just psych
-  # loaded, so lets define a stub for DefaultKey.
-  elsif !defined? YAML::Syck
-    module Syck
-      class DefaultKey # :nodoc:
-      end
-    end
-  end
-
-  # Now that we've got something that is always here, define #to_s
-  # so when code tries to use this, it at least just shows up like it
-  # should.
-  module Syck
-    class DefaultKey
-      remove_method :to_s rescue nil
-
-      def to_s
-        '='
-      end
-    end
-  end
-
-  SyntaxError = Error unless defined? SyntaxError
-end
-
-# Sometime in the 1.9 dev cycle, the Syck constant was moved from under YAML
-# to be a toplevel constant. So gemspecs created under these versions of Syck
-# will have references to Syck::DefaultKey.
-#
-# So we need to be sure that we reference Syck at the toplevel too so that
-# we can always load these kind of gemspecs.
-#
-if !defined?(Syck)
-  Syck = YAML::Syck
-end
-
-# Now that we've got Syck setup in all the right places, store
-# a reference to the DefaultKey class inside Gem. We do this so that
-# if later on YAML, etc are redefined, we've still got a consistent
-# place to find the DefaultKey class for comparison.
-
-module Gem
-  # for tests that change YAML::ENGINE
-  remove_const :SyckDefaultKey if const_defined? :SyckDefaultKey
-
-  SyckDefaultKey = YAML::Syck::DefaultKey
-end
-
-# :startdoc:
diff --git a/lib/rubygems/test_case.rb b/lib/rubygems/test_case.rb
deleted file mode 100644
index 24e8ac8..0000000
--- a/lib/rubygems/test_case.rb
+++ /dev/null
@@ -1,1610 +0,0 @@
-# frozen_string_literal: true
-
-require 'rubygems'
-
-# If bundler gemspec exists, add to stubs
-bundler_gemspec = File.expand_path("../../../bundler/bundler.gemspec", __FILE__)
-if File.exist?(bundler_gemspec)
-  Gem::Specification.dirs.unshift File.dirname(bundler_gemspec)
-  Gem::Specification.class_variable_set :@@stubs, nil
-  Gem::Specification.stubs
-  Gem::Specification.dirs.shift
-end
-
-begin
-  gem 'test-unit', '~> 3.0'
-rescue Gem::LoadError
-end
-
-begin
-  require 'simplecov'
-  SimpleCov.start do
-    add_filter "/test/"
-    add_filter "/bundler/"
-    add_filter "/lib/rubygems/resolver/molinillo"
-  end
-rescue LoadError
-end
-
-if File.exist?(bundler_gemspec)
-  require_relative '../../bundler/lib/bundler'
-else
-  require 'bundler'
-end
-
-require 'test/unit'
-
-ENV["JARS_SKIP"] = "true" if Gem.java_platform? # avoid unnecessary and noisy `jar-dependencies` post install hook
-
-require 'rubygems/deprecate'
-
-require 'fileutils'
-require 'pathname'
-require 'pp'
-require 'rubygems/package'
-require 'shellwords'
-require 'tmpdir'
-require 'uri'
-require 'zlib'
-require 'benchmark' # stdlib
-require 'rubygems/mock_gem_ui'
-
-module Gem
-
-  ##
-  # Allows setting the gem path searcher.  This method is available when
-  # requiring 'rubygems/test_case'
-
-  def self.searcher=(searcher)
-    @searcher = searcher
-  end
-
-  ##
-  # Allows toggling Windows behavior.  This method is available when requiring
-  # 'rubygems/test_case'
-
-  def self.win_platform=(val)
-    @@win_platform = val
-  end
-
-  ##
-  # Allows setting path to Ruby.  This method is available when requiring
-  # 'rubygems/test_case'
-
-  def self.ruby=(ruby)
-    @ruby = ruby
-  end
-
-  ##
-  # When rubygems/test_case is required the default user interaction is a
-  # MockGemUi.
-
-  module DefaultUserInteraction
-    @ui = Gem::MockGemUi.new
-  end
-end
-
-require "rubygems/command"
-
-class Gem::Command
-  ##
-  # Allows resetting the hash of specific args per command.  This method is
-  # available when requiring 'rubygems/test_case'
-
-  def self.specific_extra_args_hash=(value)
-    @specific_extra_args_hash = value
-  end
-end
-
-##
-# RubyGemTestCase provides a variety of methods for testing rubygems and
-# gem-related behavior in a sandbox.  Through RubyGemTestCase you can install
-# and uninstall gems, fetch remote gems through a stub fetcher and be assured
-# your normal set of gems is not affected.
-
-class Gem::TestCase < Test::Unit::TestCase
-  extend Gem::Deprecate
-
-  attr_accessor :fetcher # :nodoc:
-
-  attr_accessor :gem_repo # :nodoc:
-
-  attr_accessor :uri # :nodoc:
-
-  TEST_PATH = ENV.fetch('RUBYGEMS_TEST_PATH', File.expand_path('../../../test/rubygems', __FILE__))
-
-  def assert_activate(expected, *specs)
-    specs.each do |spec|
-      case spec
-      when String then
-        Gem::Specification.find_by_name(spec).activate
-      when Gem::Specification then
-        spec.activate
-      else
-        flunk spec.inspect
-      end
-    end
-
-    loaded = Gem.loaded_specs.values.map(&:full_name)
-
-    assert_equal expected.sort, loaded.sort if expected
-  end
-
-  def assert_directory_exists(path, msg = nil)
-    msg = build_message(msg, "Expected path '#{path}' to be a directory")
-    assert_path_exist path
-    assert File.directory?(path), msg
-  end
-
-  # https://github.com/seattlerb/minitest/blob/21d9e804b63c619f602f3f4ece6c71b48974707a/lib/minitest/assertions.rb#L188
-  def _synchronize
-    yield
-  end
-
-  # https://github.com/seattlerb/minitest/blob/21d9e804b63c619f602f3f4ece6c71b48974707a/lib/minitest/assertions.rb#L546
-  def capture_subprocess_io
-    _synchronize do
-      begin
-        require "tempfile"
-
-        captured_stdout, captured_stderr = Tempfile.new("out"), Tempfile.new("err")
-
-        orig_stdout, orig_stderr = $stdout.dup, $stderr.dup
-        $stdout.reopen captured_stdout
-        $stderr.reopen captured_stderr
-
-        yield
-
-        $stdout.rewind
-        $stderr.rewind
-
-        return captured_stdout.read, captured_stderr.read
-      ensure
-        captured_stdout.unlink
-        captured_stderr.unlink
-        $stdout.reopen orig_stdout
-        $stderr.reopen orig_stderr
-
-        orig_stdout.close
-        orig_stderr.close
-        captured_stdout.close
-        captured_stderr.close
-      end
-    end
-  end
-
-  ##
-  # Sets the ENABLE_SHARED entry in RbConfig::CONFIG to +value+ and restores
-  # the original value when the block ends
-
-  def enable_shared(value)
-    enable_shared = RbConfig::CONFIG['ENABLE_SHARED']
-    RbConfig::CONFIG['ENABLE_SHARED'] = value
-
-    yield
-  ensure
-    if enable_shared
-      RbConfig::CONFIG['enable_shared'] = enable_shared
-    else
-      RbConfig::CONFIG.delete 'enable_shared'
-    end
-  end
-
-  ##
-  # Sets the vendordir entry in RbConfig::CONFIG to +value+ and restores the
-  # original value when the block ends
-  #
-  def vendordir(value)
-    vendordir = RbConfig::CONFIG['vendordir']
-
-    if value
-      RbConfig::CONFIG['vendordir'] = value
-    else
-      RbConfig::CONFIG.delete 'vendordir'
-    end
-
-    yield
-  ensure
-    if vendordir
-      RbConfig::CONFIG['vendordir'] = vendordir
-    else
-      RbConfig::CONFIG.delete 'vendordir'
-    end
-  end
-
-  ##
-  # Sets the bindir entry in RbConfig::CONFIG to +value+ and restores the
-  # original value when the block ends
-  #
-  def bindir(value)
-    with_clean_path_to_ruby do
-      bindir = RbConfig::CONFIG['bindir']
-
-      if value
-        RbConfig::CONFIG['bindir'] = value
-      else
-        RbConfig::CONFIG.delete 'bindir'
-      end
-
-      begin
-        yield
-      ensure
-        if bindir
-          RbConfig::CONFIG['bindir'] = bindir
-        else
-          RbConfig::CONFIG.delete 'bindir'
-        end
-      end
-    end
-  end
-
-  ##
-  # Sets the EXEEXT entry in RbConfig::CONFIG to +value+ and restores the
-  # original value when the block ends
-  #
-  def exeext(value)
-    exeext = RbConfig::CONFIG['EXEEXT']
-
-    if value
-      RbConfig::CONFIG['EXEEXT'] = value
-    else
-      RbConfig::CONFIG.delete 'EXEEXT'
-    end
-
-    yield
-  ensure
-    if exeext
-      RbConfig::CONFIG['EXEEXT'] = exeext
-    else
-      RbConfig::CONFIG.delete 'EXEEXT'
-    end
-  end
-
-  def scan_make_command_lines(output)
-    output.scan(/^#{Regexp.escape make_command}(?:[[:blank:]].*)?$/)
-  end
-
-  def parse_make_command_line(line)
-    command, *args = line.shellsplit
-
-    targets = []
-    macros = {}
-
-    args.each do |arg|
-      case arg
-      when /\A(\w+)=/
-        macros[$1] = $'
-      else
-        targets << arg
-      end
-    end
-
-    targets << '' if targets.empty?
-
-    {
-      :command => command,
-      :targets => targets,
-      :macros => macros,
-    }
-  end
-
-  def assert_contains_make_command(target, output, msg = nil)
-    if output.match(/\n/)
-      msg = build_message(msg,
-        "Expected output containing make command \"%s\", but was \n\nBEGIN_OF_OUTPUT\n%sEND_OF_OUTPUT" % [
-          ('%s %s' % [make_command, target]).rstrip,
-          output,
-        ]
-      )
-    else
-      msg = build_message(msg,
-        'Expected make command "%s": %s' % [
-          ('%s %s' % [make_command, target]).rstrip,
-          output,
-        ]
-      )
-    end
-
-    assert scan_make_command_lines(output).any? {|line|
-      make = parse_make_command_line(line)
-
-      if make[:targets].include?(target)
-        yield make, line if block_given?
-        true
-      else
-        false
-      end
-    }, msg
-  end
-
-  include Gem::DefaultUserInteraction
-
-  ##
-  # #setup prepares a sandboxed location to install gems.  All installs are
-  # directed to a temporary directory.  All install plugins are removed.
-  #
-  # If the +RUBY+ environment variable is set the given path is used for
-  # Gem::ruby.  The local platform is set to <tt>i386-mswin32</tt> for Windows
-  # or <tt>i686-darwin8.10.1</tt> otherwise.
-
-  def setup
-    @orig_env = ENV.to_hash
-    @tmp = File.expand_path("tmp")
-
-    FileUtils.mkdir_p @tmp
-
-    ENV['GEM_VENDOR'] = nil
-    ENV['GEMRC'] = nil
-    ENV['XDG_CACHE_HOME'] = nil
-    ENV['XDG_CONFIG_HOME'] = nil
-    ENV['XDG_DATA_HOME'] = nil
-    ENV['SOURCE_DATE_EPOCH'] = nil
-    ENV['BUNDLER_VERSION'] = nil
-
-    @current_dir = Dir.pwd
-    @fetcher     = nil
-
-    @back_ui                       = Gem::DefaultUserInteraction.ui
-    @ui                            = Gem::MockGemUi.new
-    # This needs to be a new instance since we call use_ui(@ui) when we want to
-    # capture output
-    Gem::DefaultUserInteraction.ui = Gem::MockGemUi.new
-
-    @tempdir = Dir.mktmpdir("test_rubygems_", @tmp)
-    @tempdir.tap(&Gem::UNTAINT)
-
-    ENV["TMPDIR"] = @tempdir
-
-    @orig_SYSTEM_WIDE_CONFIG_FILE = Gem::ConfigFile::SYSTEM_WIDE_CONFIG_FILE
-    Gem::ConfigFile.send :remove_const, :SYSTEM_WIDE_CONFIG_FILE
-    Gem::ConfigFile.send :const_set, :SYSTEM_WIDE_CONFIG_FILE,
-                         File.join(@tempdir, 'system-gemrc')
-
-    @gemhome  = File.join @tempdir, 'gemhome'
-    @userhome = File.join @tempdir, 'userhome'
-    ENV["GEM_SPEC_CACHE"] = File.join @tempdir, 'spec_cache'
-
-    @orig_ruby = if ENV['RUBY']
-                   ruby = Gem.ruby
-                   Gem.ruby = ENV['RUBY']
-                   ruby
-                 end
-
-    @git = ENV['GIT'] || (win_platform? ? 'git.exe' : 'git')
-
-    Gem.ensure_gem_subdirectories @gemhome
-    Gem.ensure_default_gem_subdirectories @gemhome
-
-    @orig_LOAD_PATH = $LOAD_PATH.dup
-    $LOAD_PATH.map! do |s|
-      expand_path = File.realpath(s) rescue File.expand_path(s)
-      if expand_path != s
-        expand_path.tap(&Gem::UNTAINT)
-        if s.instance_variable_defined?(:@gem_prelude_index)
-          expand_path.instance_variable_set(:@gem_prelude_index, expand_path)
-        end
-        expand_path.freeze if s.frozen?
-        s = expand_path
-      end
-      s
-    end
-
-    Dir.chdir @tempdir
-
-    ENV['HOME'] = @userhome
-    Gem.instance_variable_set :@config_file, nil
-    Gem.instance_variable_set :@user_home, nil
-    Gem.instance_variable_set :@config_home, nil
-    Gem.instance_variable_set :@data_home, nil
-    Gem.instance_variable_set :@gemdeps, nil
-    Gem.instance_variable_set :@env_requirements_by_name, nil
-    Gem.send :remove_instance_variable, :@ruby_version if
-      Gem.instance_variables.include? :@ruby_version
-
-    FileUtils.mkdir_p @userhome
-
-    ENV['GEM_PRIVATE_KEY_PASSPHRASE'] = PRIVATE_KEY_PASSPHRASE
-
-    if Gem.java_platform?
-      @orig_default_gem_home = RbConfig::CONFIG['default_gem_home']
-      RbConfig::CONFIG['default_gem_home'] = @gemhome
-    else
-      Gem.instance_variable_set(:@default_dir, @gemhome)
-    end
-
-    @orig_bindir = RbConfig::CONFIG["bindir"]
-    RbConfig::CONFIG["bindir"] = File.join @gemhome, "bin"
-
-    Gem::Specification.unresolved_deps.clear
-    Gem.use_paths(@gemhome)
-
-    Gem.loaded_specs.clear
-    Gem.instance_variable_set(:@activated_gem_paths, 0)
-    Gem.clear_default_specs
-    Bundler.reset!
-
-    Gem.configuration.verbose = true
-    Gem.configuration.update_sources = true
-
-    Gem::RemoteFetcher.fetcher = Gem::FakeFetcher.new
-
-    @gem_repo = "http://gems.example.com/"
-    @uri = URI.parse @gem_repo
-    Gem.sources.replace [@gem_repo]
-
-    Gem.searcher = nil
-    Gem::SpecFetcher.fetcher = nil
-
-    @orig_arch = RbConfig::CONFIG['arch']
-
-    if win_platform?
-      util_set_arch 'i386-mswin32'
-    else
-      util_set_arch 'i686-darwin8.10.1'
-    end
-
-    @orig_hooks = {}
-    %w[post_install_hooks done_installing_hooks post_uninstall_hooks pre_uninstall_hooks pre_install_hooks pre_reset_hooks post_reset_hooks post_build_hooks].each do |name|
-      @orig_hooks[name] = Gem.send(name).dup
-    end
-
-    @marshal_version = "#{Marshal::MAJOR_VERSION}.#{Marshal::MINOR_VERSION}"
-    @orig_LOADED_FEATURES = $LOADED_FEATURES.dup
-  end
-
-  ##
-  # #teardown restores the process to its original state and removes the
-  # tempdir
-
-  def teardown
-    $LOAD_PATH.replace @orig_LOAD_PATH if @orig_LOAD_PATH
-    if @orig_LOADED_FEATURES
-      if @orig_LOAD_PATH
-        ($LOADED_FEATURES - @orig_LOADED_FEATURES).each do |feat|
-          $LOADED_FEATURES.delete(feat) if feat.start_with?(@tmp)
-        end
-      else
-        $LOADED_FEATURES.replace @orig_LOADED_FEATURES
-      end
-    end
-
-    RbConfig::CONFIG['arch'] = @orig_arch
-
-    if defined? Gem::RemoteFetcher
-      Gem::RemoteFetcher.fetcher = nil
-    end
-
-    Dir.chdir @current_dir
-
-    FileUtils.rm_rf @tempdir
-
-    ENV.replace(@orig_env)
-
-    Gem::ConfigFile.send :remove_const, :SYSTEM_WIDE_CONFIG_FILE
-    Gem::ConfigFile.send :const_set, :SYSTEM_WIDE_CONFIG_FILE,
-                         @orig_SYSTEM_WIDE_CONFIG_FILE
-
-    Gem.ruby = @orig_ruby if @orig_ruby
-
-    RbConfig::CONFIG['bindir'] = @orig_bindir
-
-    if Gem.java_platform?
-      RbConfig::CONFIG['default_gem_home'] = @orig_default_gem_home
-    else
-      Gem.instance_variable_set :@default_dir, nil
-    end
-
-    Gem::Specification._clear_load_cache
-    Gem::Specification.unresolved_deps.clear
-    Gem::refresh
-
-    @orig_hooks.each do |name, hooks|
-      Gem.send(name).replace hooks
-    end
-
-    @back_ui.close
-  end
-
-  def credential_setup
-    @temp_cred = File.join(@userhome, '.gem', 'credentials')
-    FileUtils.mkdir_p File.dirname(@temp_cred)
-    File.write @temp_cred, ':rubygems_api_key: 701229f217cdf23b1344c7b4b54ca97'
-    File.chmod 0600, @temp_cred
-  end
-
-  def credential_teardown
-    FileUtils.rm_rf @temp_cred
-  end
-
-  def common_installer_setup
-    common_installer_teardown
-
-    Gem.post_build do |installer|
-      @post_build_hook_arg = installer
-      true
-    end
-
-    Gem.post_install do |installer|
-      @post_install_hook_arg = installer
-    end
-
-    Gem.post_uninstall do |uninstaller|
-      @post_uninstall_hook_arg = uninstaller
-    end
-
-    Gem.pre_install do |installer|
-      @pre_install_hook_arg = installer
-      true
-    end
-
-    Gem.pre_uninstall do |uninstaller|
-      @pre_uninstall_hook_arg = uninstaller
-    end
-  end
-
-  def common_installer_teardown
-    Gem.post_build_hooks.clear
-    Gem.post_install_hooks.clear
-    Gem.done_installing_hooks.clear
-    Gem.post_reset_hooks.clear
-    Gem.post_uninstall_hooks.clear
-    Gem.pre_install_hooks.clear
-    Gem.pre_reset_hooks.clear
-    Gem.pre_uninstall_hooks.clear
-  end
-
-  def without_any_upwards_gemfiles
-    ENV["BUNDLE_GEMFILE"] = File.join(@tempdir, "Gemfile")
-  end
-
-  ##
-  # A git_gem is used with a gem dependencies file.  The gem created here
-  # has no files, just a gem specification for the given +name+ and +version+.
-  #
-  # Yields the +specification+ to the block, if given
-
-  def git_gem(name = 'a', version = 1)
-    have_git?
-
-    directory = File.join 'git', name
-    directory = File.expand_path directory
-
-    git_spec = Gem::Specification.new name, version do |specification|
-      yield specification if block_given?
-    end
-
-    FileUtils.mkdir_p directory
-
-    gemspec = "#{name}.gemspec"
-
-    File.open File.join(directory, gemspec), 'w' do |io|
-      io.write git_spec.to_ruby
-    end
-
-    head = nil
-
-    Dir.chdir directory do
-      unless File.exist? '.git'
-        system @git, 'init', '--quiet'
-        system @git, 'config', 'user.name',  'RubyGems Tests'
-        system @git, 'config', 'user.email', 'rubygems@example'
-      end
-
-      system @git, 'add', gemspec
-      system @git, 'commit', '-a', '-m', 'a non-empty commit message', '--quiet'
-      head = Gem::Util.popen(@git, 'rev-parse', 'master').strip
-    end
-
-    return name, git_spec.version, directory, head
-  end
-
-  ##
-  # Skips this test unless you have a git executable
-
-  def have_git?
-    return if in_path? @git
-
-    skip 'cannot find git executable, use GIT environment variable to set'
-  end
-
-  def in_path?(executable) # :nodoc:
-    return true if %r{\A([A-Z]:|/)} =~ executable and File.exist? executable
-
-    ENV['PATH'].split(File::PATH_SEPARATOR).any? do |directory|
-      File.exist? File.join directory, executable
-    end
-  end
-
-  ##
-  # Builds and installs the Gem::Specification +spec+
-
-  def install_gem(spec, options = {})
-    require 'rubygems/installer'
-
-    gem = spec.cache_file
-
-    unless File.exist? gem
-      use_ui Gem::MockGemUi.new do
-        Dir.chdir @tempdir do
-          Gem::Package.build spec
-        end
-      end
-
-      gem = File.join(@tempdir, File.basename(gem)).tap(&Gem::UNTAINT)
-    end
-
-    Gem::Installer.at(gem, options.merge({:wrappers => true})).install
-  end
-
-  ##
-  # Builds and installs the Gem::Specification +spec+ into the user dir
-
-  def install_gem_user(spec)
-    install_gem spec, :user_install => true
-  end
-
-  ##
-  # Uninstalls the Gem::Specification +spec+
-  def uninstall_gem(spec)
-    require 'rubygems/uninstaller'
-
-    Class.new(Gem::Uninstaller) do
-      def ask_if_ok(spec)
-        true
-      end
-    end.new(spec.name, :executables => true, :user_install => true).uninstall
-  end
-
-  ##
-  # Enables pretty-print for all tests
-
-  def mu_pp(obj)
-    s = String.new
-    s = PP.pp obj, s
-    s = s.force_encoding(Encoding.default_external)
-    s.chomp
-  end
-
-  ##
-  # Reads a Marshal file at +path+
-
-  def read_cache(path)
-    File.open path.dup.tap(&Gem::UNTAINT), 'rb' do |io|
-      Marshal.load io.read
-    end
-  end
-
-  ##
-  # Reads a binary file at +path+
-
-  def read_binary(path)
-    Gem.read_binary path
-  end
-
-  ##
-  # Writes a binary file to +path+ which is relative to +@gemhome+
-
-  def write_file(path)
-    path = File.join @gemhome, path unless Pathname.new(path).absolute?
-    dir = File.dirname path
-    FileUtils.mkdir_p dir unless File.directory? dir
-
-    File.open path, 'wb' do |io|
-      yield io if block_given?
-    end
-
-    path
-  end
-
-  ##
-  # Load a YAML string, the psych 3 way
-
-  def load_yaml(yaml)
-    if YAML.respond_to?(:unsafe_load)
-      YAML.unsafe_load(yaml)
-    else
-      YAML.load(yaml)
-    end
-  end
-
-  ##
-  # Load a YAML file, the psych 3 way
-
-  def load_yaml_file(file)
-    if YAML.respond_to?(:unsafe_load_file)
-      YAML.unsafe_load_file(file)
-    else
-      YAML.load_file(file)
-    end
-  end
-
-  def all_spec_names
-    Gem::Specification.map(&:full_name)
-  end
-
-  ##
-  # Creates a Gem::Specification with a minimum of extra work.  +name+ and
-  # +version+ are the gem's name and version,  platform, author, email,
-  # homepage, summary and description are defaulted.  The specification is
-  # yielded for customization.
-  #
-  # The gem is added to the installed gems in +@gemhome+ and the runtime.
-  #
-  # Use this with #write_file to build an installed gem.
-
-  def quick_gem(name, version='2')
-    require 'rubygems/specification'
-
-    spec = Gem::Specification.new do |s|
-      s.platform    = Gem::Platform::RUBY
-      s.name        = name
-      s.version     = version
-      s.author      = 'A User'
-      s.email       = 'example@example.com'
-      s.homepage    = 'http://example.com'
-      s.summary     = "this is a summary"
-      s.description = "This is a test description"
-
-      yield(s) if block_given?
-    end
-
-    written_path = write_file spec.spec_file do |io|
-      io.write spec.to_ruby_for_cache
-    end
-
-    spec.loaded_from = written_path
-
-    Gem::Specification.reset
-
-    return spec
-  end
-
-  ##
-  # Builds a gem from +spec+ and places it in <tt>File.join @gemhome,
-  # 'cache'</tt>.  Automatically creates files based on +spec.files+
-
-  def util_build_gem(spec)
-    dir = spec.gem_dir
-    FileUtils.mkdir_p dir
-
-    Dir.chdir dir do
-      spec.files.each do |file|
-        next if File.exist? file
-        FileUtils.mkdir_p File.dirname(file)
-
-        File.open file, 'w' do |fp|
-          fp.puts "# #{file}"
-        end
-      end
-
-      use_ui Gem::MockGemUi.new do
-        Gem::Package.build spec
-      end
-
-      cache = spec.cache_file
-      FileUtils.mv File.basename(cache), cache
-    end
-  end
-
-  def util_remove_gem(spec)
-    FileUtils.rm_rf spec.cache_file
-    FileUtils.rm_rf spec.spec_file
-  end
-
-  ##
-  # Removes all installed gems from +@gemhome+.
-
-  def util_clear_gems
-    FileUtils.rm_rf File.join(@gemhome, "gems")
-    FileUtils.mkdir File.join(@gemhome, "gems")
-    FileUtils.rm_rf File.join(@gemhome, "specifications")
-    FileUtils.mkdir File.join(@gemhome, "specifications")
-    Gem::Specification.reset
-  end
-
-  ##
-  # Install the provided specs
-
-  def install_specs(*specs)
-    specs.each do |spec|
-      Gem::Installer.for_spec(spec, :force => true).install
-    end
-
-    Gem.searcher = nil
-  end
-
-  ##
-  # Installs the provided default specs including writing the spec file
-
-  def install_default_gems(*specs)
-    specs.each do |spec|
-      installer = Gem::Installer.for_spec(spec, :install_as_default => true)
-      installer.install
-      Gem.register_default_spec(spec)
-    end
-  end
-
-  def loaded_spec_names
-    Gem.loaded_specs.values.map(&:full_name).sort
-  end
-
-  def unresolved_names
-    Gem::Specification.unresolved_deps.values.map(&:to_s).sort
-  end
-
-  def save_loaded_features
-    old_loaded_features = $LOADED_FEATURES.dup
-    yield
-  ensure
-    prefix = File.dirname(__FILE__) + "/"
-    new_features = ($LOADED_FEATURES - old_loaded_features)
-    old_loaded_features.concat(new_features.select {|f| f.rindex(prefix, 0) })
-    $LOADED_FEATURES.replace old_loaded_features
-  end
-
-  def new_default_spec(name, version, deps = nil, *files)
-    spec = util_spec name, version, deps
-
-    spec.loaded_from = File.join(@gemhome, "specifications", "default", spec.spec_name)
-    spec.files = files
-
-    lib_dir = File.join(@tempdir, "default_gems", "lib")
-    lib_dir.instance_variable_set(:@gem_prelude_index, lib_dir)
-    Gem.instance_variable_set(:@default_gem_load_paths, [*Gem.send(:default_gem_load_paths), lib_dir])
-    $LOAD_PATH.unshift(lib_dir)
-    files.each do |file|
-      rb_path = File.join(lib_dir, file)
-      FileUtils.mkdir_p(File.dirname(rb_path))
-      File.open(rb_path, "w") do |rb|
-        rb << "# #{file}"
-      end
-    end
-
-    spec
-  end
-
-  ##
-  # Creates a spec with +name+, +version+.  +deps+ can specify the dependency
-  # or a +block+ can be given for full customization of the specification.
-
-  def util_spec(name, version = 2, deps = nil, *files) # :yields: specification
-    raise "deps or block, not both" if deps and block_given?
-
-    spec = Gem::Specification.new do |s|
-      s.platform    = Gem::Platform::RUBY
-      s.name        = name
-      s.version     = version
-      s.author      = 'A User'
-      s.email       = 'example@example.com'
-      s.homepage    = 'http://example.com'
-      s.summary     = "this is a summary"
-      s.description = "This is a test description"
-
-      s.files.push(*files) unless files.empty?
-
-      yield s if block_given?
-    end
-
-    if deps
-      deps.keys.each do |n|
-        spec.add_dependency n, (deps[n] || '>= 0')
-      end
-    end
-
-    unless files.empty?
-      write_file spec.spec_file do |io|
-        io.write spec.to_ruby_for_cache
-      end
-
-      util_build_gem spec
-
-      FileUtils.rm spec.spec_file
-    end
-
-    return spec
-  end
-
-  ##
-  # Creates a gem with +name+, +version+ and +deps+.  The specification will
-  # be yielded before gem creation for customization.  The gem will be placed
-  # in <tt>File.join @tempdir, 'gems'</tt>.  The specification and .gem file
-  # location are returned.
-
-  def util_gem(name, version, deps = nil, &block)
-    if deps
-      block = proc do |s|
-        deps.keys.each do |n|
-          s.add_dependency n, (deps[n] || '>= 0')
-        end
-      end
-    end
-
-    spec = quick_gem(name, version, &block)
-
-    util_build_gem spec
-
-    cache_file = File.join @tempdir, 'gems', "#{spec.original_name}.gem"
-    FileUtils.mkdir_p File.dirname cache_file
-    FileUtils.mv spec.cache_file, cache_file
-    FileUtils.rm spec.spec_file
-
-    spec.loaded_from = nil
-
-    [spec, cache_file]
-  end
-
-  ##
-  # Gzips +data+.
-
-  def util_gzip(data)
-    out = StringIO.new
-
-    Zlib::GzipWriter.wrap out do |io|
-      io.write data
-    end
-
-    out.string
-  end
-
-  ##
-  # Creates several default gems which all have a lib/code.rb file.  The gems
-  # are not installed but are available in the cache dir.
-  #
-  # +@a1+:: gem a version 1, this is the best-described gem.
-  # +@a2+:: gem a version 2
-  # +@a3a:: gem a version 3.a
-  # +@a_evil9+:: gem a_evil version 9, use this to ensure similarly-named gems
-  #              don't collide with a.
-  # +@b2+:: gem b version 2
-  # +@c1_2+:: gem c version 1.2
-  # +@pl1+:: gem pl version 1, this gem has a legacy platform of i386-linux.
-  #
-  # Additional +prerelease+ gems may also be created:
-  #
-  # +@a2_pre+:: gem a version 2.a
-  # TODO: nuke this and fix tests. this should speed up a lot
-
-  def util_make_gems(prerelease = false)
-    @a1 = quick_gem 'a', '1' do |s|
-      s.files = %w[lib/code.rb]
-      s.require_paths = %w[lib]
-      s.date = Gem::Specification::TODAY - 86400
-      s.homepage = 'http://a.example.com'
-      s.email = %w[example@example.com example2@example.com]
-      s.authors = %w[Example Example2]
-      s.description = <<-DESC
-This line is really, really long.  So long, in fact, that it is more than eighty characters long!  The purpose of this line is for testing wrapping behavior because sometimes people don't wrap their text to eighty characters.  Without the wrapping, the text might not look good in the RSS feed.
-
-Also, a list:
-  * An entry that\'s actually kind of sort
-  * an entry that\'s really long, which will probably get wrapped funny.  That's ok, somebody wasn't thinking straight when they made it more than eighty characters.
-      DESC
-    end
-
-    init = proc do |s|
-      s.files = %w[lib/code.rb]
-      s.require_paths = %w[lib]
-    end
-
-    @a2      = quick_gem('a', '2',      &init)
-    @a3a     = quick_gem('a', '3.a',    &init)
-    @a_evil9 = quick_gem('a_evil', '9', &init)
-    @b2      = quick_gem('b', '2',      &init)
-    @c1_2    = quick_gem('c', '1.2',    &init)
-    @x       = quick_gem('x', '1',      &init)
-    @dep_x   = quick_gem('dep_x', '1') do |s|
-      s.files = %w[lib/code.rb]
-      s.require_paths = %w[lib]
-      s.add_dependency 'x', '>= 1'
-    end
-
-    @pl1 = quick_gem 'pl', '1' do |s| # l for legacy
-      s.files = %w[lib/code.rb]
-      s.require_paths = %w[lib]
-      s.platform = Gem::Platform.new 'i386-linux'
-      s.instance_variable_set :@original_platform, 'i386-linux'
-    end
-
-    if prerelease
-      @a2_pre = quick_gem('a', '2.a', &init)
-      write_file File.join(*%W[gems #{@a2_pre.original_name} lib code.rb])
-      util_build_gem @a2_pre
-    end
-
-    write_file File.join(*%W[gems #{@a1.original_name}      lib code.rb])
-    write_file File.join(*%W[gems #{@a2.original_name}      lib code.rb])
-    write_file File.join(*%W[gems #{@a3a.original_name}     lib code.rb])
-    write_file File.join(*%W[gems #{@a_evil9.original_name} lib code.rb])
-    write_file File.join(*%W[gems #{@b2.original_name}      lib code.rb])
-    write_file File.join(*%W[gems #{@c1_2.original_name}    lib code.rb])
-    write_file File.join(*%W[gems #{@pl1.original_name}     lib code.rb])
-    write_file File.join(*%W[gems #{@x.original_name}       lib code.rb])
-    write_file File.join(*%W[gems #{@dep_x.original_name}   lib code.rb])
-
-    [@a1, @a2, @a3a, @a_evil9, @b2, @c1_2, @pl1, @x, @dep_x].each do |spec|
-      util_build_gem spec
-    end
-
-    FileUtils.rm_r File.join(@gemhome, "gems", @pl1.original_name)
-  end
-
-  ##
-  # Set the platform to +arch+
-
-  def util_set_arch(arch)
-    RbConfig::CONFIG['arch'] = arch
-    platform = Gem::Platform.new arch
-
-    Gem.instance_variable_set :@platforms, nil
-    Gem::Platform.instance_variable_set :@local, nil
-
-    yield if block_given?
-
-    platform
-  end
-
-  ##
-  # Add +spec+ to +@fetcher+ serving the data in the file +path+.
-  # +repo+ indicates which repo to make +spec+ appear to be in.
-
-  def add_to_fetcher(spec, path=nil, repo=@gem_repo)
-    path ||= spec.cache_file
-    @fetcher.data["#{@gem_repo}gems/#{spec.file_name}"] = read_binary(path)
-  end
-
-  ##
-  # Sets up Gem::SpecFetcher to return information from the gems in +specs+.
-
-  def util_setup_spec_fetcher(*specs)
-    all_specs = Gem::Specification.to_a + specs
-    Gem::Specification._resort! all_specs
-
-    spec_fetcher = Gem::SpecFetcher.fetcher
-
-    prerelease, all = all_specs.partition {|spec| spec.version.prerelease? }
-    latest = Gem::Specification._latest_specs all_specs
-
-    spec_fetcher.specs[@uri] = []
-    all.each do |spec|
-      spec_fetcher.specs[@uri] << spec.name_tuple
-    end
-
-    spec_fetcher.latest_specs[@uri] = []
-    latest.each do |spec|
-      spec_fetcher.latest_specs[@uri] << spec.name_tuple
-    end
-
-    spec_fetcher.prerelease_specs[@uri] = []
-    prerelease.each do |spec|
-      spec_fetcher.prerelease_specs[@uri] << spec.name_tuple
-    end
-
-    # HACK for test_download_to_cache
-    unless Gem::RemoteFetcher === @fetcher
-      v = Gem.marshal_version
-
-      specs = all.map {|spec| spec.name_tuple }
-      s_zip = util_gzip Marshal.dump Gem::NameTuple.to_basic specs
-
-      latest_specs = latest.map do |spec|
-        spec.name_tuple
-      end
-
-      l_zip = util_gzip Marshal.dump Gem::NameTuple.to_basic latest_specs
-
-      prerelease_specs = prerelease.map {|spec| spec.name_tuple }
-      p_zip = util_gzip Marshal.dump Gem::NameTuple.to_basic prerelease_specs
-
-      @fetcher.data["#{@gem_repo}specs.#{v}.gz"]            = s_zip
-      @fetcher.data["#{@gem_repo}latest_specs.#{v}.gz"]     = l_zip
-      @fetcher.data["#{@gem_repo}prerelease_specs.#{v}.gz"] = p_zip
-
-      v = Gem.marshal_version
-
-      all_specs.each do |spec|
-        path = "#{@gem_repo}quick/Marshal.#{v}/#{spec.original_name}.gemspec.rz"
-        data = Marshal.dump spec
-        data_deflate = Zlib::Deflate.deflate data
-        @fetcher.data[path] = data_deflate
-      end
-    end
-
-    nil # force errors
-  end
-
-  ##
-  # Deflates +data+
-
-  def util_zip(data)
-    Zlib::Deflate.deflate data
-  end
-
-  def util_set_RUBY_VERSION(version, patchlevel = nil, revision = nil, description = nil, engine = "ruby", engine_version = nil)
-    if Gem.instance_variables.include? :@ruby_version
-      Gem.send :remove_instance_variable, :@ruby_version
-    end
-
-    @RUBY_VERSION        = RUBY_VERSION
-    @RUBY_PATCHLEVEL     = RUBY_PATCHLEVEL     if defined?(RUBY_PATCHLEVEL)
-    @RUBY_REVISION       = RUBY_REVISION       if defined?(RUBY_REVISION)
-    @RUBY_DESCRIPTION    = RUBY_DESCRIPTION    if defined?(RUBY_DESCRIPTION)
-    @RUBY_ENGINE         = RUBY_ENGINE
-    @RUBY_ENGINE_VERSION = RUBY_ENGINE_VERSION if defined?(RUBY_ENGINE_VERSION)
-
-    util_clear_RUBY_VERSION
-
-    Object.const_set :RUBY_VERSION,        version
-    Object.const_set :RUBY_PATCHLEVEL,     patchlevel     if patchlevel
-    Object.const_set :RUBY_REVISION,       revision       if revision
-    Object.const_set :RUBY_DESCRIPTION,    description    if description
-    Object.const_set :RUBY_ENGINE,         engine
-    Object.const_set :RUBY_ENGINE_VERSION, engine_version if engine_version
-  end
-
-  def util_restore_RUBY_VERSION
-    util_clear_RUBY_VERSION
-
-    Object.const_set :RUBY_VERSION,        @RUBY_VERSION
-    Object.const_set :RUBY_PATCHLEVEL,     @RUBY_PATCHLEVEL  if
-      defined?(@RUBY_PATCHLEVEL)
-    Object.const_set :RUBY_REVISION,       @RUBY_REVISION    if
-      defined?(@RUBY_REVISION)
-    Object.const_set :RUBY_DESCRIPTION,    @RUBY_DESCRIPTION if
-      defined?(@RUBY_DESCRIPTION)
-    Object.const_set :RUBY_ENGINE,         @RUBY_ENGINE
-    Object.const_set :RUBY_ENGINE_VERSION, @RUBY_ENGINE_VERSION if
-      defined?(@RUBY_ENGINE_VERSION)
-  end
-
-  def util_clear_RUBY_VERSION
-    Object.send :remove_const, :RUBY_VERSION
-    Object.send :remove_const, :RUBY_PATCHLEVEL     if defined?(RUBY_PATCHLEVEL)
-    Object.send :remove_const, :RUBY_REVISION       if defined?(RUBY_REVISION)
-    Object.send :remove_const, :RUBY_DESCRIPTION    if defined?(RUBY_DESCRIPTION)
-    Object.send :remove_const, :RUBY_ENGINE
-    Object.send :remove_const, :RUBY_ENGINE_VERSION if defined?(RUBY_ENGINE_VERSION)
-  end
-
-  ##
-  # Is this test being run on a Windows platform?
-
-  def self.win_platform?
-    Gem.win_platform?
-  end
-
-  ##
-  # Is this test being run on a Windows platform?
-
-  def win_platform?
-    Gem.win_platform?
-  end
-
-  ##
-  # Is this test being run on a Java platform?
-
-  def self.java_platform?
-    Gem.java_platform?
-  end
-
-  ##
-  # Is this test being run on a Java platform?
-
-  def java_platform?
-    Gem.java_platform?
-  end
-
-  ##
-  # Returns whether or not we're on a version of Ruby built with VC++ (or
-  # Borland) versus Cygwin, Mingw, etc.
-
-  def self.vc_windows?
-    RUBY_PLATFORM.match('mswin')
-  end
-
-  ##
-  # Returns whether or not we're on a version of Ruby built with VC++ (or
-  # Borland) versus Cygwin, Mingw, etc.
-
-  def vc_windows?
-    RUBY_PLATFORM.match('mswin')
-  end
-
-  ##
-  # Returns the make command for the current platform. For versions of Ruby
-  # built on MS Windows with VC++ or Borland it will return 'nmake'. On all
-  # other platforms, including Cygwin, it will return 'make'.
-
-  def self.make_command
-    ENV["make"] || ENV["MAKE"] || (vc_windows? ? 'nmake' : 'make')
-  end
-
-  ##
-  # Returns the make command for the current platform. For versions of Ruby
-  # built on MS Windows with VC++ or Borland it will return 'nmake'. On all
-  # other platforms, including Cygwin, it will return 'make'.
-
-  def make_command
-    ENV["make"] || ENV["MAKE"] || (vc_windows? ? 'nmake' : 'make')
-  end
-
-  ##
-  # Returns whether or not the nmake command could be found.
-
-  def nmake_found?
-    system('nmake /? 1>NUL 2>&1')
-  end
-
-  # In case we're building docs in a background process, this method waits for
-  # that process to exit (or if it's already been reaped, or never happened,
-  # swallows the Errno::ECHILD error).
-  def wait_for_child_process_to_exit
-    Process.wait if Process.respond_to?(:fork)
-  rescue Errno::ECHILD
-  end
-
-  ##
-  # Allows tests to use a random (but controlled) port number instead of
-  # a hardcoded one. This helps CI tools when running parallels builds on
-  # the same builder slave.
-
-  def self.process_based_port
-    @@process_based_port ||= 8000 + $$ % 1000
-  end
-
-  ##
-  # See ::process_based_port
-
-  def process_based_port
-    self.class.process_based_port
-  end
-
-  ##
-  # Allows the proper version of +rake+ to be used for the test.
-
-  def build_rake_in(good=true)
-    gem_ruby = Gem.ruby
-    Gem.ruby = self.class.rubybin
-    env_rake = ENV["rake"]
-    rake = (good ? @@good_rake : @@bad_rake)
-    ENV["rake"] = rake
-    yield rake
-  ensure
-    Gem.ruby = gem_ruby
-    if env_rake
-      ENV["rake"] = env_rake
-    else
-      ENV.delete("rake")
-    end
-  end
-
-  ##
-  # Finds the path to the Ruby executable
-
-  def self.rubybin
-    ruby = ENV["RUBY"]
-    return ruby if ruby
-    ruby = "ruby"
-    rubyexe = "#{ruby}.exe"
-
-    3.times do
-      if File.exist? ruby and File.executable? ruby and !File.directory? ruby
-        return File.expand_path(ruby)
-      end
-      if File.exist? rubyexe and File.executable? rubyexe
-        return File.expand_path(rubyexe)
-      end
-      ruby = File.join("..", ruby)
-    end
-
-    begin
-      Gem.ruby
-    rescue LoadError
-      "ruby"
-    end
-  end
-
-  def ruby_with_rubygems_in_load_path
-    [Gem.ruby, "-I", File.expand_path("..", __dir__)]
-  end
-
-  def with_clean_path_to_ruby
-    orig_ruby = Gem.ruby
-
-    Gem.instance_variable_set :@ruby, nil
-
-    yield
-  ensure
-    Gem.instance_variable_set :@ruby, orig_ruby
-  end
-
-  class << self
-    # :nodoc:
-    ##
-    # Return the join path, with escaping backticks, dollars, and
-    # double-quotes.  Unlike `shellescape`, equal-sign is not escaped.
-
-    private
-
-    def escape_path(*path)
-      path = File.join(*path)
-      if %r{\A[-+:/=@,.\w]+\z} =~ path
-        path
-      else
-        "\"#{path.gsub(/[`$"]/, '\\&')}\""
-      end
-    end
-  end
-
-  @@good_rake = "#{rubybin} #{escape_path(TEST_PATH, 'good_rake.rb')}"
-  @@bad_rake = "#{rubybin} #{escape_path(TEST_PATH, 'bad_rake.rb')}"
-
-  ##
-  # Construct a new Gem::Dependency.
-
-  def dep(name, *requirements)
-    Gem::Dependency.new name, *requirements
-  end
-
-  ##
-  # Constructs a Gem::Resolver::DependencyRequest from a
-  # Gem::Dependency +dep+, a +from_name+ and +from_version+ requesting the
-  # dependency and a +parent+ DependencyRequest
-
-  def dependency_request(dep, from_name, from_version, parent = nil)
-    remote = Gem::Source.new @uri
-
-    unless parent
-      parent_dep = dep from_name, from_version
-      parent = Gem::Resolver::DependencyRequest.new parent_dep, nil
-    end
-
-    spec = Gem::Resolver::IndexSpecification.new \
-      nil, from_name, from_version, remote, Gem::Platform::RUBY
-    activation = Gem::Resolver::ActivationRequest.new spec, parent
-
-    Gem::Resolver::DependencyRequest.new dep, activation
-  end
-
-  ##
-  # Constructs a new Gem::Requirement.
-
-  def req(*requirements)
-    return requirements.first if Gem::Requirement === requirements.first
-    Gem::Requirement.create requirements
-  end
-
-  ##
-  # Constructs a new Gem::Specification.
-
-  def spec(name, version, &block)
-    Gem::Specification.new name, v(version), &block
-  end
-
-  ##
-  # Creates a SpecFetcher pre-filled with the gems or specs defined in the
-  # block.
-  #
-  # Yields a +fetcher+ object that responds to +spec+ and +gem+.  +spec+ adds
-  # a specification to the SpecFetcher while +gem+ adds both a specification
-  # and the gem data to the RemoteFetcher so the built gem can be downloaded.
-  #
-  # If only the a-3 gem is supposed to be downloaded you can save setup
-  # time by creating only specs for the other versions:
-  #
-  #   spec_fetcher do |fetcher|
-  #     fetcher.spec 'a', 1
-  #     fetcher.spec 'a', 2, 'b' => 3 # dependency on b = 3
-  #     fetcher.gem 'a', 3 do |spec|
-  #       # spec is a Gem::Specification
-  #       # ...
-  #     end
-  #   end
-
-  def spec_fetcher(repository = @gem_repo)
-    Gem::TestCase::SpecFetcherSetup.declare self, repository do |spec_fetcher_setup|
-      yield spec_fetcher_setup if block_given?
-    end
-  end
-
-  ##
-  # Construct a new Gem::Version.
-
-  def v(string)
-    Gem::Version.create string
-  end
-
-  ##
-  # A vendor_gem is used with a gem dependencies file.  The gem created here
-  # has no files, just a gem specification for the given +name+ and +version+.
-  #
-  # Yields the +specification+ to the block, if given
-
-  def vendor_gem(name = 'a', version = 1)
-    directory = File.join 'vendor', name
-
-    FileUtils.mkdir_p directory
-
-    save_gemspec name, version, directory
-  end
-
-  ##
-  # create_gemspec creates gem specification in given +directory+ or '.'
-  # for the given +name+ and +version+.
-  #
-  # Yields the +specification+ to the block, if given
-
-  def save_gemspec(name = 'a', version = 1, directory = '.')
-    vendor_spec = Gem::Specification.new name, version do |specification|
-      yield specification if block_given?
-    end
-
-    File.open File.join(directory, "#{name}.gemspec"), 'w' do |io|
-      io.write vendor_spec.to_ruby
-    end
-
-    return name, vendor_spec.version, directory
-  end
-
-  ##
-  # The StaticSet is a static set of gem specifications used for testing only.
-  # It is available by requiring Gem::TestCase.
-
-  class StaticSet < Gem::Resolver::Set
-    ##
-    # A StaticSet ignores remote because it has a fixed set of gems.
-
-    attr_accessor :remote
-
-    ##
-    # Creates a new StaticSet for the given +specs+
-
-    def initialize(specs)
-      super()
-
-      @specs = specs
-
-      @remote = true
-    end
-
-    ##
-    # Adds +spec+ to this set.
-
-    def add(spec)
-      @specs << spec
-    end
-
-    ##
-    # Finds +dep+ in this set.
-
-    def find_spec(dep)
-      @specs.reverse_each do |s|
-        return s if dep.matches_spec? s
-      end
-    end
-
-    ##
-    # Finds all gems matching +dep+ in this set.
-
-    def find_all(dep)
-      @specs.find_all {|s| dep.match? s, @prerelease }
-    end
-
-    ##
-    # Loads a Gem::Specification from this set which has the given +name+,
-    # version +ver+, +platform+.  The +source+ is ignored.
-
-    def load_spec(name, ver, platform, source)
-      dep = Gem::Dependency.new name, ver
-      spec = find_spec dep
-
-      Gem::Specification.new spec.name, spec.version do |s|
-        s.platform = spec.platform
-      end
-    end
-
-    def prefetch(reqs) # :nodoc:
-    end
-  end
-
-  ##
-  # Loads certificate named +cert_name+ from <tt>test/rubygems/</tt>.
-
-  def self.load_cert(cert_name)
-    cert_file = cert_path cert_name
-
-    cert = File.read cert_file
-
-    OpenSSL::X509::Certificate.new cert
-  end
-
-  ##
-  # Returns the path to the certificate named +cert_name+ from
-  # <tt>test/rubygems/</tt>.
-
-  def self.cert_path(cert_name)
-    if 32 == (Time.at(2**32) rescue 32)
-      cert_file = "#{TEST_PATH}/#{cert_name}_cert_32.pem"
-
-      return cert_file if File.exist? cert_file
-    end
-
-    "#{TEST_PATH}/#{cert_name}_cert.pem"
-  end
-
-  ##
-  # Loads an RSA private key named +key_name+ with +passphrase+ in <tt>test/rubygems/</tt>
-
-  def self.load_key(key_name, passphrase = nil)
-    key_file = key_path key_name
-
-    key = File.read key_file
-
-    OpenSSL::PKey::RSA.new key, passphrase
-  end
-
-  ##
-  # Returns the path to the key named +key_name+ from <tt>test/rubygems</tt>
-
-  def self.key_path(key_name)
-    "#{TEST_PATH}/#{key_name}_key.pem"
-  end
-
-  # :stopdoc:
-  # only available in RubyGems tests
-
-  PRIVATE_KEY_PASSPHRASE = 'Foo bar'.freeze
-
-  begin
-    PRIVATE_KEY                 = load_key 'private'
-    PRIVATE_KEY_PATH            = key_path 'private'
-
-    # ENCRYPTED_PRIVATE_KEY is PRIVATE_KEY encrypted with PRIVATE_KEY_PASSPHRASE
-    ENCRYPTED_PRIVATE_KEY       = load_key 'encrypted_private', PRIVATE_KEY_PASSPHRASE
-    ENCRYPTED_PRIVATE_KEY_PATH  = key_path 'encrypted_private'
-
-    PUBLIC_KEY                  = PRIVATE_KEY.public_key
-
-    PUBLIC_CERT                 = load_cert 'public'
-    PUBLIC_CERT_PATH            = cert_path 'public'
-  rescue Errno::ENOENT
-    PRIVATE_KEY = nil
-    PUBLIC_KEY  = nil
-    PUBLIC_CERT = nil
-  end if Gem::HAVE_OPENSSL
-end
-
-# https://github.com/seattlerb/minitest/blob/13c48a03d84a2a87855a4de0c959f96800100357/lib/minitest/mock.rb#L192
-class Object
-  def stub(name, val_or_callable, *block_args)
-    new_name = "__minitest_stub__#{name}"
-
-    metaclass = class << self; self; end
-
-    if respond_to? name and not methods.map(&:to_s).include? name.to_s
-      metaclass.send :define_method, name do |*args|
-        super(*args)
-      end
-    end
-
-    metaclass.send :alias_method, new_name, name
-
-    metaclass.send :define_method, name do |*args, &blk|
-      if val_or_callable.respond_to? :call
-        val_or_callable.call(*args, &blk)
-      else
-        blk.call(*block_args) if blk
-        val_or_callable
-      end
-    end
-
-    metaclass.send(:ruby2_keywords, name) if metaclass.respond_to?(:ruby2_keywords, true)
-
-    yield self
-  ensure
-    metaclass.send :undef_method, name
-    metaclass.send :alias_method, name, new_name
-    metaclass.send :undef_method, new_name
-  end
-end
-
-require 'rubygems/test_utilities'
diff --git a/lib/rubygems/test_utilities.rb b/lib/rubygems/test_utilities.rb
deleted file mode 100644
index 08faef6..0000000
--- a/lib/rubygems/test_utilities.rb
+++ /dev/null
@@ -1,373 +0,0 @@
-# frozen_string_literal: true
-require 'tempfile'
-require 'rubygems'
-require 'rubygems/remote_fetcher'
-
-##
-# A fake Gem::RemoteFetcher for use in tests or to avoid real live HTTP
-# requests when testing code that uses RubyGems.
-#
-# Example:
-#
-#   @fetcher = Gem::FakeFetcher.new
-#   @fetcher.data['http://gems.example.com/yaml'] = source_index.to_yaml
-#   Gem::RemoteFetcher.fetcher = @fetcher
-#
-#   use nested array if multiple response is needed
-#
-#   @fetcher.data['http://gems.example.com/sequence'] = [['Success', 200, 'OK'], ['Failed', 401, 'Unauthorized']]
-#
-#   @fetcher.fetch_path('http://gems.example.com/sequence') # => ['Success', 200, 'OK']
-#   @fetcher.fetch_path('http://gems.example.com/sequence') # => ['Failed', 401, 'Unauthorized']
-#
-#   # invoke RubyGems code
-#
-#   paths = @fetcher.paths
-#   assert_equal 'http://gems.example.com/yaml', paths.shift
-#   assert paths.empty?, paths.join(', ')
-#
-# See RubyGems' tests for more examples of FakeFetcher.
-
-class Gem::FakeFetcher
-  attr_reader :data
-  attr_reader :last_request
-  attr_accessor :paths
-
-  def initialize
-    @data = {}
-    @paths = []
-  end
-
-  def find_data(path)
-    return Gem.read_binary path.path if URI === path and 'file' == path.scheme
-
-    if URI === path and "URI::#{path.scheme.upcase}" != path.class.name
-      raise ArgumentError,
-        "mismatch for scheme #{path.scheme} and class #{path.class}"
-    end
-
-    path = path.to_s
-    @paths << path
-    raise ArgumentError, 'need full URI' unless path.start_with?("https://", "http://")
-
-    unless @data.key? path
-      raise Gem::RemoteFetcher::FetchError.new("no data for #{path}", path)
-    end
-
-    if @data[path].kind_of?(Array) && @data[path].first.kind_of?(Array)
-      @data[path].shift
-    else
-      @data[path]
-    end
-  end
-
-  def fetch_path(path, mtime = nil, head = false)
-    data = find_data(path)
-
-    if data.respond_to?(:call)
-      data.call
-    else
-      if path.to_s.end_with?(".gz") and not data.nil? and not data.empty?
-        data = Gem::Util.gunzip data
-      end
-      data
-    end
-  end
-
-  def cache_update_path(uri, path = nil, update = true)
-    if data = fetch_path(uri)
-      File.open(path, 'wb') {|io| io.write data } if path and update
-      data
-    else
-      Gem.read_binary(path) if path
-    end
-  end
-
-  # Thanks, FakeWeb!
-  def open_uri_or_path(path)
-    data = find_data(path)
-    body, code, msg = data
-
-    response = Net::HTTPResponse.send(:response_class, code.to_s).new("1.0", code.to_s, msg)
-    response.instance_variable_set(:@body, body)
-    response.instance_variable_set(:@read, true)
-    response
-  end
-
-  def request(uri, request_class, last_modified = nil)
-    data = find_data(uri)
-    body, code, msg = (data.respond_to?(:call) ? data.call : data)
-
-    @last_request = request_class.new uri.request_uri
-    yield @last_request if block_given?
-
-    response = Net::HTTPResponse.send(:response_class, code.to_s).new("1.0", code.to_s, msg)
-    response.instance_variable_set(:@body, body)
-    response.instance_variable_set(:@read, true)
-    response
-  end
-
-  def pretty_print(q) # :nodoc:
-    q.group 2, '[FakeFetcher', ']' do
-      q.breakable
-      q.text 'URIs:'
-
-      q.breakable
-      q.pp @data.keys
-    end
-  end
-
-  def fetch_size(path)
-    path = path.to_s
-    @paths << path
-
-    raise ArgumentError, 'need full URI' unless path =~ %r{^http://}
-
-    unless @data.key? path
-      raise Gem::RemoteFetcher::FetchError.new("no data for #{path}", path)
-    end
-
-    data = @data[path]
-
-    data.respond_to?(:call) ? data.call : data.length
-  end
-
-  def download(spec, source_uri, install_dir = Gem.dir)
-    name = File.basename spec.cache_file
-    path = if Dir.pwd == install_dir # see fetch_command
-             install_dir
-           else
-             File.join install_dir, "cache"
-           end
-
-    path = File.join path, name
-
-    if source_uri =~ /^http/
-      File.open(path, "wb") do |f|
-        f.write fetch_path(File.join(source_uri, "gems", name))
-      end
-    else
-      FileUtils.cp source_uri, path
-    end
-
-    path
-  end
-
-  def download_to_cache(dependency)
-    found, _ = Gem::SpecFetcher.fetcher.spec_for_dependency dependency
-
-    return if found.empty?
-
-    spec, source = found.first
-
-    download spec, source.uri.to_s
-  end
-end
-
-# :stopdoc:
-class Gem::RemoteFetcher
-  def self.fetcher=(fetcher)
-    @fetcher = fetcher
-  end
-end
-# :startdoc:
-
-##
-# The SpecFetcherSetup allows easy setup of a remote source in RubyGems tests:
-#
-#   spec_fetcher do |f|
-#     f.gem  'a', 1
-#     f.spec 'a', 2
-#     f.gem  'b', 1' 'a' => '~> 1.0'
-#   end
-#
-# The above declaration creates two gems, a-1 and b-1, with a dependency from
-# b to a.  The declaration creates an additional spec a-2, but no gem for it
-# (so it cannot be installed).
-#
-# After the gems are created they are removed from Gem.dir.
-
-class Gem::TestCase::SpecFetcherSetup
-  ##
-  # Executes a SpecFetcher setup block.  Yields an instance then creates the
-  # gems and specifications defined in the instance.
-
-  def self.declare(test, repository)
-    setup = new test, repository
-
-    yield setup
-
-    setup.execute
-  end
-
-  def initialize(test, repository) # :nodoc:
-    @test       = test
-    @repository = repository
-
-    @gems       = {}
-    @downloaded = []
-    @installed  = []
-    @operations = []
-  end
-
-  ##
-  # Returns a Hash of created Specification full names and the corresponding
-  # Specification.
-
-  def created_specs
-    created = {}
-
-    @gems.keys.each do |spec|
-      created[spec.full_name] = spec
-    end
-
-    created
-  end
-
-  ##
-  # Creates any defined gems or specifications
-
-  def execute # :nodoc:
-    execute_operations
-
-    setup_fetcher
-
-    created_specs
-  end
-
-  def execute_operations # :nodoc:
-    @operations.each do |operation, *arguments|
-      block = arguments.pop
-      case operation
-      when :gem then
-        spec, gem = @test.util_gem(*arguments, &block)
-
-        write_spec spec
-
-        @gems[spec] = gem
-        @installed << spec
-      when :download then
-        spec, gem = @test.util_gem(*arguments, &block)
-
-        @gems[spec] = gem
-        @downloaded << spec
-      when :spec then
-        spec = @test.util_spec(*arguments, &block)
-
-        write_spec spec
-
-        @gems[spec] = nil
-        @installed << spec
-      end
-    end
-  end
-
-  ##
-  # Creates a gem with +name+, +version+ and +deps+.  The created gem can be
-  # downloaded and installed.
-  #
-  # The specification will be yielded before gem creation for customization,
-  # but only the block or the dependencies may be set, not both.
-
-  def gem(name, version, dependencies = nil, &block)
-    @operations << [:gem, name, version, dependencies, block]
-  end
-
-  ##
-  # Creates a gem with +name+, +version+ and +deps+.  The created gem is
-  # downloaded in to the cache directory but is not installed
-  #
-  # The specification will be yielded before gem creation for customization,
-  # but only the block or the dependencies may be set, not both.
-
-  def download(name, version, dependencies = nil, &block)
-    @operations << [:download, name, version, dependencies, block]
-  end
-
-  ##
-  # Creates a legacy platform spec with the name 'pl' and version 1
-
-  def legacy_platform
-    spec 'pl', 1 do |s|
-      s.platform = Gem::Platform.new 'i386-linux'
-      s.instance_variable_set :@original_platform, 'i386-linux'
-    end
-  end
-
-  def setup_fetcher # :nodoc:
-    require 'zlib'
-    require 'socket'
-    require 'rubygems/remote_fetcher'
-
-    unless @test.fetcher
-      @test.fetcher = Gem::FakeFetcher.new
-      Gem::RemoteFetcher.fetcher = @test.fetcher
-    end
-
-    Gem::Specification.reset
-
-    begin
-      gem_repo, @test.gem_repo = @test.gem_repo, @repository
-      @test.uri = URI @repository
-
-      @test.util_setup_spec_fetcher(*@downloaded)
-    ensure
-      @test.gem_repo = gem_repo
-      @test.uri = URI gem_repo
-    end
-
-    @gems.each do |spec, gem|
-      next unless gem
-
-      @test.fetcher.data["#{@repository}gems/#{spec.file_name}"] =
-        Gem.read_binary(gem)
-
-      FileUtils.cp gem, spec.cache_file
-    end
-  end
-
-  ##
-  # Creates a spec with +name+, +version+ and +deps+.  The created gem can be
-  # downloaded and installed.
-  #
-  # The specification will be yielded before creation for customization,
-  # but only the block or the dependencies may be set, not both.
-
-  def spec(name, version, dependencies = nil, &block)
-    @operations << [:spec, name, version, dependencies, block]
-  end
-
-  def write_spec(spec) # :nodoc:
-    File.open spec.spec_file, 'w' do |io|
-      io.write spec.to_ruby_for_cache
-    end
-  end
-end
-
-##
-# A StringIO duck-typed class that uses Tempfile instead of String as the
-# backing store.
-#
-# This is available when rubygems/test_utilities is required.
-#--
-# This class was added to flush out problems in Rubinius' IO implementation.
-
-class TempIO < Tempfile
-  ##
-  # Creates a new TempIO that will be initialized to contain +string+.
-
-  def initialize(string = '')
-    super "TempIO"
-    binmode
-    write string
-    rewind
-  end
-
-  ##
-  # The content of the TempIO as a String.
-
-  def string
-    flush
-    Gem.read_binary path
-  end
-end
diff --git a/lib/rubygems/text.rb b/lib/rubygems/text.rb
index 6678111..acf25a0 100644
--- a/lib/rubygems/text.rb
+++ b/lib/rubygems/text.rb
@@ -49,37 +49,38 @@ module Gem::Text
     end
   end
 
-  # This code is based directly on the Text gem implementation
   # Returns a value representing the "cost" of transforming str1 into str2
+  # Vendored version of DidYouMean::Levenshtein.distance from the ruby/did_you_mean gem @ 1.4.0
+  # https://git.io/JJgZI
   def levenshtein_distance(str1, str2)
-    s = str1
-    t = str2
-    n = s.length
-    m = t.length
-
-    return m if (0 == n)
-    return n if (0 == m)
+    n = str1.length
+    m = str2.length
+    return m if n.zero?
+    return n if m.zero?
 
     d = (0..m).to_a
     x = nil
 
-    str1.each_char.each_with_index do |char1,i|
-      e = i + 1
+    # to avoid duplicating an enumerable object, create it outside of the loop
+    str2_codepoints = str2.codepoints
 
-      str2.each_char.each_with_index do |char2,j|
-        cost = (char1 == char2) ? 0 : 1
+    str1.each_codepoint.with_index(1) do |char1, i|
+      j = 0
+      while j < m
+        cost = (char1 == str2_codepoints[j]) ? 0 : 1
         x = min3(
-             d[j + 1] + 1, # insertion
-             e + 1,      # deletion
-             d[j] + cost # substitution
-           )
-        d[j] = e
-        e = x
+          d[j + 1] + 1, # insertion
+          i + 1,      # deletion
+          d[j] + cost # substitution
+        )
+        d[j] = i
+        i = x
+
+        j += 1
       end
-
       d[m] = x
     end
 
-    return x
+    x
   end
 end
diff --git a/lib/rubygems/tsort.rb b/lib/rubygems/tsort.rb
new file mode 100644
index 0000000..ebe7c33
--- /dev/null
+++ b/lib/rubygems/tsort.rb
@@ -0,0 +1,3 @@
+# frozen_string_literal: true
+
+require_relative 'tsort/lib/tsort'
diff --git a/lib/rubygems/tsort/.document b/lib/rubygems/tsort/.document
new file mode 100644
index 0000000..0c43bbd
--- /dev/null
+++ b/lib/rubygems/tsort/.document
@@ -0,0 +1 @@
+# Vendored files do not need to be documented
diff --git a/lib/rubygems/tsort/lib/tsort.rb b/lib/rubygems/tsort/lib/tsort.rb
new file mode 100644
index 0000000..f68c594
--- /dev/null
+++ b/lib/rubygems/tsort/lib/tsort.rb
@@ -0,0 +1,454 @@
+# frozen_string_literal: true
+
+#--
+# tsort.rb - provides a module for topological sorting and strongly connected components.
+#++
+#
+
+#
+# Gem::TSort implements topological sorting using Tarjan's algorithm for
+# strongly connected components.
+#
+# Gem::TSort is designed to be able to be used with any object which can be
+# interpreted as a directed graph.
+#
+# Gem::TSort requires two methods to interpret an object as a graph,
+# tsort_each_node and tsort_each_child.
+#
+# * tsort_each_node is used to iterate for all nodes over a graph.
+# * tsort_each_child is used to iterate for child nodes of a given node.
+#
+# The equality of nodes are defined by eql? and hash since
+# Gem::TSort uses Hash internally.
+#
+# == A Simple Example
+#
+# The following example demonstrates how to mix the Gem::TSort module into an
+# existing class (in this case, Hash). Here, we're treating each key in
+# the hash as a node in the graph, and so we simply alias the required
+# #tsort_each_node method to Hash's #each_key method. For each key in the
+# hash, the associated value is an array of the node's child nodes. This
+# choice in turn leads to our implementation of the required #tsort_each_child
+# method, which fetches the array of child nodes and then iterates over that
+# array using the user-supplied block.
+#
+#   require 'rubygems/tsort/lib/tsort'
+#
+#   class Hash
+#     include Gem::TSort
+#     alias tsort_each_node each_key
+#     def tsort_each_child(node, &block)
+#       fetch(node).each(&block)
+#     end
+#   end
+#
+#   {1=>[2, 3], 2=>[3], 3=>[], 4=>[]}.tsort
+#   #=> [3, 2, 1, 4]
+#
+#   {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}.strongly_connected_components
+#   #=> [[4], [2, 3], [1]]
+#
+# == A More Realistic Example
+#
+# A very simple `make' like tool can be implemented as follows:
+#
+#   require 'rubygems/tsort/lib/tsort'
+#
+#   class Make
+#     def initialize
+#       @dep = {}
+#       @dep.default = []
+#     end
+#
+#     def rule(outputs, inputs=[], &block)
+#       triple = [outputs, inputs, block]
+#       outputs.each {|f| @dep[f] = [triple]}
+#       @dep[triple] = inputs
+#     end
+#
+#     def build(target)
+#       each_strongly_connected_component_from(target) {|ns|
+#         if ns.length != 1
+#           fs = ns.delete_if {|n| Array === n}
+#           raise Gem::TSort::Cyclic.new("cyclic dependencies: #{fs.join ', '}")
+#         end
+#         n = ns.first
+#         if Array === n
+#           outputs, inputs, block = n
+#           inputs_time = inputs.map {|f| File.mtime f}.max
+#           begin
+#             outputs_time = outputs.map {|f| File.mtime f}.min
+#           rescue Errno::ENOENT
+#             outputs_time = nil
+#           end
+#           if outputs_time == nil ||
+#              inputs_time != nil && outputs_time <= inputs_time
+#             sleep 1 if inputs_time != nil && inputs_time.to_i == Time.now.to_i
+#             block.call
+#           end
+#         end
+#       }
+#     end
+#
+#     def tsort_each_child(node, &block)
+#       @dep[node].each(&block)
+#     end
+#     include Gem::TSort
+#   end
+#
+#   def command(arg)
+#     print arg, "\n"
+#     system arg
+#   end
+#
+#   m = Make.new
+#   m.rule(%w[t1]) { command 'date > t1' }
+#   m.rule(%w[t2]) { command 'date > t2' }
+#   m.rule(%w[t3]) { command 'date > t3' }
+#   m.rule(%w[t4], %w[t1 t3]) { command 'cat t1 t3 > t4' }
+#   m.rule(%w[t5], %w[t4 t2]) { command 'cat t4 t2 > t5' }
+#   m.build('t5')
+#
+# == Bugs
+#
+# * 'tsort.rb' is wrong name because this library uses
+#   Tarjan's algorithm for strongly connected components.
+#   Although 'strongly_connected_components.rb' is correct but too long.
+#
+# == References
+#
+# R. E. Tarjan, "Depth First Search and Linear Graph Algorithms",
+# <em>SIAM Journal on Computing</em>, Vol. 1, No. 2, pp. 146-160, June 1972.
+#
+
+module Gem
+  module TSort
+    class Cyclic < StandardError
+    end
+
+    # Returns a topologically sorted array of nodes.
+    # The array is sorted from children to parents, i.e.
+    # the first element has no child and the last node has no parent.
+    #
+    # If there is a cycle, Gem::TSort::Cyclic is raised.
+    #
+    #   class G
+    #     include Gem::TSort
+    #     def initialize(g)
+    #       @g = g
+    #     end
+    #     def tsort_each_child(n, &b) @g[n].each(&b) end
+    #     def tsort_each_node(&b) @g.each_key(&b) end
+    #   end
+    #
+    #   graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
+    #   p graph.tsort #=> [4, 2, 3, 1]
+    #
+    #   graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
+    #   p graph.tsort # raises Gem::TSort::Cyclic
+    #
+    def tsort
+      each_node = method(:tsort_each_node)
+      each_child = method(:tsort_each_child)
+      Gem::TSort.tsort(each_node, each_child)
+    end
+
+    # Returns a topologically sorted array of nodes.
+    # The array is sorted from children to parents, i.e.
+    # the first element has no child and the last node has no parent.
+    #
+    # The graph is represented by _each_node_ and _each_child_.
+    # _each_node_ should have +call+ method which yields for each node in the graph.
+    # _each_child_ should have +call+ method which takes a node argument and yields for each child node.
+    #
+    # If there is a cycle, Gem::TSort::Cyclic is raised.
+    #
+    #   g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
+    #   each_node = lambda {|&b| g.each_key(&b) }
+    #   each_child = lambda {|n, &b| g[n].each(&b) }
+    #   p Gem::TSort.tsort(each_node, each_child) #=> [4, 2, 3, 1]
+    #
+    #   g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
+    #   each_node = lambda {|&b| g.each_key(&b) }
+    #   each_child = lambda {|n, &b| g[n].each(&b) }
+    #   p Gem::TSort.tsort(each_node, each_child) # raises Gem::TSort::Cyclic
+    #
+    def TSort.tsort(each_node, each_child)
+      Gem::TSort.tsort_each(each_node, each_child).to_a
+    end
+
+    # The iterator version of the #tsort method.
+    # <tt><em>obj</em>.tsort_each</tt> is similar to <tt><em>obj</em>.tsort.each</tt>, but
+    # modification of _obj_ during the iteration may lead to unexpected results.
+    #
+    # #tsort_each returns +nil+.
+    # If there is a cycle, Gem::TSort::Cyclic is raised.
+    #
+    #   class G
+    #     include Gem::TSort
+    #     def initialize(g)
+    #       @g = g
+    #     end
+    #     def tsort_each_child(n, &b) @g[n].each(&b) end
+    #     def tsort_each_node(&b) @g.each_key(&b) end
+    #   end
+    #
+    #   graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
+    #   graph.tsort_each {|n| p n }
+    #   #=> 4
+    #   #   2
+    #   #   3
+    #   #   1
+    #
+    def tsort_each(&block) # :yields: node
+      each_node = method(:tsort_each_node)
+      each_child = method(:tsort_each_child)
+      Gem::TSort.tsort_each(each_node, each_child, &block)
+    end
+
+    # The iterator version of the Gem::TSort.tsort method.
+    #
+    # The graph is represented by _each_node_ and _each_child_.
+    # _each_node_ should have +call+ method which yields for each node in the graph.
+    # _each_child_ should have +call+ method which takes a node argument and yields for each child node.
+    #
+    #   g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
+    #   each_node = lambda {|&b| g.each_key(&b) }
+    #   each_child = lambda {|n, &b| g[n].each(&b) }
+    #   Gem::TSort.tsort_each(each_node, each_child) {|n| p n }
+    #   #=> 4
+    #   #   2
+    #   #   3
+    #   #   1
+    #
+    def TSort.tsort_each(each_node, each_child) # :yields: node
+      return to_enum(__method__, each_node, each_child) unless block_given?
+
+      Gem::TSort.each_strongly_connected_component(each_node, each_child) {|component|
+        if component.size == 1
+          yield component.first
+        else
+          raise Cyclic.new("topological sort failed: #{component.inspect}")
+        end
+      }
+    end
+
+    # Returns strongly connected components as an array of arrays of nodes.
+    # The array is sorted from children to parents.
+    # Each elements of the array represents a strongly connected component.
+    #
+    #   class G
+    #     include Gem::TSort
+    #     def initialize(g)
+    #       @g = g
+    #     end
+    #     def tsort_each_child(n, &b) @g[n].each(&b) end
+    #     def tsort_each_node(&b) @g.each_key(&b) end
+    #   end
+    #
+    #   graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
+    #   p graph.strongly_connected_components #=> [[4], [2], [3], [1]]
+    #
+    #   graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
+    #   p graph.strongly_connected_components #=> [[4], [2, 3], [1]]
+    #
+    def strongly_connected_components
+      each_node = method(:tsort_each_node)
+      each_child = method(:tsort_each_child)
+      Gem::TSort.strongly_connected_components(each_node, each_child)
+    end
+
+    # Returns strongly connected components as an array of arrays of nodes.
+    # The array is sorted from children to parents.
+    # Each elements of the array represents a strongly connected component.
+    #
+    # The graph is represented by _each_node_ and _each_child_.
+    # _each_node_ should have +call+ method which yields for each node in the graph.
+    # _each_child_ should have +call+ method which takes a node argument and yields for each child node.
+    #
+    #   g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
+    #   each_node = lambda {|&b| g.each_key(&b) }
+    #   each_child = lambda {|n, &b| g[n].each(&b) }
+    #   p Gem::TSort.strongly_connected_components(each_node, each_child)
+    #   #=> [[4], [2], [3], [1]]
+    #
+    #   g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
+    #   each_node = lambda {|&b| g.each_key(&b) }
+    #   each_child = lambda {|n, &b| g[n].each(&b) }
+    #   p Gem::TSort.strongly_connected_components(each_node, each_child)
+    #   #=> [[4], [2, 3], [1]]
+    #
+    def TSort.strongly_connected_components(each_node, each_child)
+      Gem::TSort.each_strongly_connected_component(each_node, each_child).to_a
+    end
+
+    # The iterator version of the #strongly_connected_components method.
+    # <tt><em>obj</em>.each_strongly_connected_component</tt> is similar to
+    # <tt><em>obj</em>.strongly_connected_components.each</tt>, but
+    # modification of _obj_ during the iteration may lead to unexpected results.
+    #
+    # #each_strongly_connected_component returns +nil+.
+    #
+    #   class G
+    #     include Gem::TSort
+    #     def initialize(g)
+    #       @g = g
+    #     end
+    #     def tsort_each_child(n, &b) @g[n].each(&b) end
+    #     def tsort_each_node(&b) @g.each_key(&b) end
+    #   end
+    #
+    #   graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
+    #   graph.each_strongly_connected_component {|scc| p scc }
+    #   #=> [4]
+    #   #   [2]
+    #   #   [3]
+    #   #   [1]
+    #
+    #   graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
+    #   graph.each_strongly_connected_component {|scc| p scc }
+    #   #=> [4]
+    #   #   [2, 3]
+    #   #   [1]
+    #
+    def each_strongly_connected_component(&block) # :yields: nodes
+      each_node = method(:tsort_each_node)
+      each_child = method(:tsort_each_child)
+      Gem::TSort.each_strongly_connected_component(each_node, each_child, &block)
+    end
+
+    # The iterator version of the Gem::TSort.strongly_connected_components method.
+    #
+    # The graph is represented by _each_node_ and _each_child_.
+    # _each_node_ should have +call+ method which yields for each node in the graph.
+    # _each_child_ should have +call+ method which takes a node argument and yields for each child node.
+    #
+    #   g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
+    #   each_node = lambda {|&b| g.each_key(&b) }
+    #   each_child = lambda {|n, &b| g[n].each(&b) }
+    #   Gem::TSort.each_strongly_connected_component(each_node, each_child) {|scc| p scc }
+    #   #=> [4]
+    #   #   [2]
+    #   #   [3]
+    #   #   [1]
+    #
+    #   g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
+    #   each_node = lambda {|&b| g.each_key(&b) }
+    #   each_child = lambda {|n, &b| g[n].each(&b) }
+    #   Gem::TSort.each_strongly_connected_component(each_node, each_child) {|scc| p scc }
+    #   #=> [4]
+    #   #   [2, 3]
+    #   #   [1]
+    #
+    def TSort.each_strongly_connected_component(each_node, each_child) # :yields: nodes
+      return to_enum(__method__, each_node, each_child) unless block_given?
+
+      id_map = {}
+      stack = []
+      each_node.call {|node|
+        unless id_map.include? node
+          Gem::TSort.each_strongly_connected_component_from(node, each_child, id_map, stack) {|c|
+            yield c
+          }
+        end
+      }
+      nil
+    end
+
+    # Iterates over strongly connected component in the subgraph reachable from
+    # _node_.
+    #
+    # Return value is unspecified.
+    #
+    # #each_strongly_connected_component_from doesn't call #tsort_each_node.
+    #
+    #   class G
+    #     include Gem::TSort
+    #     def initialize(g)
+    #       @g = g
+    #     end
+    #     def tsort_each_child(n, &b) @g[n].each(&b) end
+    #     def tsort_each_node(&b) @g.each_key(&b) end
+    #   end
+    #
+    #   graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
+    #   graph.each_strongly_connected_component_from(2) {|scc| p scc }
+    #   #=> [4]
+    #   #   [2]
+    #
+    #   graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
+    #   graph.each_strongly_connected_component_from(2) {|scc| p scc }
+    #   #=> [4]
+    #   #   [2, 3]
+    #
+    def each_strongly_connected_component_from(node, id_map={}, stack=[], &block) # :yields: nodes
+      Gem::TSort.each_strongly_connected_component_from(node, method(:tsort_each_child), id_map, stack, &block)
+    end
+
+    # Iterates over strongly connected components in a graph.
+    # The graph is represented by _node_ and _each_child_.
+    #
+    # _node_ is the first node.
+    # _each_child_ should have +call+ method which takes a node argument
+    # and yields for each child node.
+    #
+    # Return value is unspecified.
+    #
+    # #Gem::TSort.each_strongly_connected_component_from is a class method and
+    # it doesn't need a class to represent a graph which includes Gem::TSort.
+    #
+    #   graph = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
+    #   each_child = lambda {|n, &b| graph[n].each(&b) }
+    #   Gem::TSort.each_strongly_connected_component_from(1, each_child) {|scc|
+    #     p scc
+    #   }
+    #   #=> [4]
+    #   #   [2, 3]
+    #   #   [1]
+    #
+    def TSort.each_strongly_connected_component_from(node, each_child, id_map={}, stack=[]) # :yields: nodes
+      return to_enum(__method__, node, each_child, id_map, stack) unless block_given?
+
+      minimum_id = node_id = id_map[node] = id_map.size
+      stack_length = stack.length
+      stack << node
+
+      each_child.call(node) {|child|
+        if id_map.include? child
+          child_id = id_map[child]
+          minimum_id = child_id if child_id && child_id < minimum_id
+        else
+          sub_minimum_id =
+            Gem::TSort.each_strongly_connected_component_from(child, each_child, id_map, stack) {|c|
+              yield c
+            }
+          minimum_id = sub_minimum_id if sub_minimum_id < minimum_id
+        end
+      }
+
+      if node_id == minimum_id
+        component = stack.slice!(stack_length .. -1)
+        component.each {|n| id_map[n] = nil}
+        yield component
+      end
+
+      minimum_id
+    end
+
+    # Should be implemented by a extended class.
+    #
+    # #tsort_each_node is used to iterate for all nodes over a graph.
+    #
+    def tsort_each_node # :yields: node
+      raise NotImplementedError.new
+    end
+
+    # Should be implemented by a extended class.
+    #
+    # #tsort_each_child is used to iterate for child nodes of _node_.
+    #
+    def tsort_each_child(node) # :yields: child
+      raise NotImplementedError.new
+    end
+  end
+end
diff --git a/lib/rubygems/uninstaller.rb b/lib/rubygems/uninstaller.rb
index 51ac349..11fb611 100644
--- a/lib/rubygems/uninstaller.rb
+++ b/lib/rubygems/uninstaller.rb
@@ -6,11 +6,11 @@
 #++
 
 require 'fileutils'
-require 'rubygems'
-require 'rubygems/installer_uninstaller_utils'
-require 'rubygems/dependency_list'
-require 'rubygems/rdoc'
-require 'rubygems/user_interaction'
+require_relative '../rubygems'
+require_relative 'installer_uninstaller_utils'
+require_relative 'dependency_list'
+require_relative 'rdoc'
+require_relative 'user_interaction'
 
 ##
 # An Uninstaller.
@@ -70,6 +70,9 @@ class Gem::Uninstaller
     # only add user directory if install_dir is not set
     @user_install = false
     @user_install = options[:user_install] unless options[:install_dir]
+
+    # Optimization: populated during #uninstall
+    @default_specs_matching_uninstall_params = []
   end
 
   ##
@@ -98,10 +101,8 @@ class Gem::Uninstaller
     default_specs, list = list.partition do |spec|
       spec.default_gem?
     end
-
-    default_specs.each do |default_spec|
-      say "Gem #{default_spec.full_name} cannot be uninstalled because it is a default gem"
-    end
+    warn_cannot_uninstall_default_gems(default_specs - list)
+    @default_specs_matching_uninstall_params = default_specs
 
     list, other_repo_specs = list.partition do |spec|
       @gem_home == spec.base_dir or
@@ -261,7 +262,10 @@ class Gem::Uninstaller
 
     safe_delete { FileUtils.rm_r gem }
 
-    Gem::RDoc.new(spec).remove
+    begin
+      Gem::RDoc.new(spec).remove
+    rescue NameError
+    end
 
     gemspec = spec.spec_file
 
@@ -270,7 +274,7 @@ class Gem::Uninstaller
     end
 
     safe_delete { FileUtils.rm_r gemspec }
-    say "Successfully uninstalled #{spec.full_name}"
+    announce_deletion_of(spec)
 
     Gem::Specification.reset
   end
@@ -356,7 +360,7 @@ class Gem::Uninstaller
     # of what it did for us to find rather than trying to recreate
     # it again.
     if @format_executable
-      require 'rubygems/installer'
+      require_relative 'installer'
       Gem::Installer.exec_format % File.basename(filename)
     else
       filename
@@ -373,4 +377,34 @@ class Gem::Uninstaller
 
     raise e
   end
+
+  private
+
+  def announce_deletion_of(spec)
+    name = spec.full_name
+    say "Successfully uninstalled #{name}"
+    if default_spec_matches?(spec)
+      say(
+        "There was both a regular copy and a default copy of #{name}. The " \
+          "regular copy was successfully uninstalled, but the default copy " \
+          "was left around because default gems can't be removed."
+      )
+    end
+  end
+
+  # @return true if the specs of any default gems are `==` to the given `spec`.
+  def default_spec_matches?(spec)
+    !default_specs_that_match(spec).empty?
+  end
+
+  # @return [Array] specs of default gems that are `==` to the given `spec`.
+  def default_specs_that_match(spec)
+    @default_specs_matching_uninstall_params.select {|default_spec| spec == default_spec }
+  end
+
+  def warn_cannot_uninstall_default_gems(specs)
+    specs.each do |spec|
+      say "Gem #{spec.full_name} cannot be uninstalled because it is a default gem"
+    end
+  end
 end
diff --git a/lib/rubygems/unknown_command_spell_checker.rb b/lib/rubygems/unknown_command_spell_checker.rb
new file mode 100644
index 0000000..ee5c2fb
--- /dev/null
+++ b/lib/rubygems/unknown_command_spell_checker.rb
@@ -0,0 +1,21 @@
+# frozen_string_literal: true
+
+class Gem::UnknownCommandSpellChecker
+  attr_reader :error
+
+  def initialize(error)
+    @error = error
+  end
+
+  def corrections
+    @corrections ||=
+      spell_checker.correct(error.unknown_command).map(&:inspect)
+  end
+
+  private
+
+  def spell_checker
+    dictionary = Gem::CommandManager.instance.command_names
+    DidYouMean::SpellChecker.new(dictionary: dictionary)
+  end
+end
diff --git a/lib/rubygems/uri.rb b/lib/rubygems/uri.rb
new file mode 100644
index 0000000..ba30fac
--- /dev/null
+++ b/lib/rubygems/uri.rb
@@ -0,0 +1,111 @@
+# frozen_string_literal: true
+
+##
+# The Uri handles rubygems source URIs.
+#
+
+class Gem::Uri
+  def initialize(source_uri)
+    @parsed_uri = parse(source_uri)
+  end
+
+  def redacted
+    return self unless valid_uri?
+
+    if token? || oauth_basic?
+      with_redacted_user
+    elsif password?
+      with_redacted_password
+    else
+      self
+    end
+  end
+
+  def to_s
+    @parsed_uri.to_s
+  end
+
+  def redact_credentials_from(text)
+    return text unless valid_uri? && password?
+
+    text.sub(password, 'REDACTED')
+  end
+
+  def method_missing(method_name, *args, &blk)
+    if @parsed_uri.respond_to?(method_name)
+      @parsed_uri.send(method_name, *args, &blk)
+    else
+      super
+    end
+  end
+
+  def respond_to_missing?(method_name, include_private = false)
+    @parsed_uri.respond_to?(method_name, include_private) || super
+  end
+
+  protected
+
+  # Add a protected reader for the cloned instance to access the original object's parsed uri
+  attr_reader :parsed_uri
+
+  private
+
+  ##
+  # Parses the #uri, raising if it's invalid
+
+  def parse!(uri)
+    require "uri"
+
+    raise URI::InvalidURIError unless uri
+
+    # Always escape URI's to deal with potential spaces and such
+    # It should also be considered that source_uri may already be
+    # a valid URI with escaped characters. e.g. "{DESede}" is encoded
+    # as "%7BDESede%7D". If this is escaped again the percentage
+    # symbols will be escaped.
+    begin
+      URI.parse(uri)
+    rescue URI::InvalidURIError
+      URI.parse(URI::DEFAULT_PARSER.escape(uri))
+    end
+  end
+
+  ##
+  # Parses the #uri, returning the original uri if it's invalid
+
+  def parse(uri)
+    return uri unless uri.is_a?(String)
+
+    parse!(uri)
+  rescue URI::InvalidURIError
+    uri
+  end
+
+  def with_redacted_user
+    clone.tap {|uri| uri.user = 'REDACTED' }
+  end
+
+  def with_redacted_password
+    clone.tap {|uri| uri.password = 'REDACTED' }
+  end
+
+  def valid_uri?
+    !@parsed_uri.is_a?(String)
+  end
+
+  def password?
+    !!password
+  end
+
+  def oauth_basic?
+    password == 'x-oauth-basic'
+  end
+
+  def token?
+    !user.nil? && password.nil?
+  end
+
+  def initialize_copy(original)
+    @parsed_uri = original.parsed_uri.clone
+  end
+end
diff --git a/lib/rubygems/uri_parser.rb b/lib/rubygems/uri_parser.rb
deleted file mode 100644
index f350ede..0000000
--- a/lib/rubygems/uri_parser.rb
+++ /dev/null
@@ -1,34 +0,0 @@
-# frozen_string_literal: true
-
-##
-# The UriParser handles parsing URIs.
-#
-
-class Gem::UriParser
-  ##
-  # Parses the #uri, raising if it's invalid
-
-  def parse!(uri)
-    raise URI::InvalidURIError unless uri
-
-    # Always escape URI's to deal with potential spaces and such
-    # It should also be considered that source_uri may already be
-    # a valid URI with escaped characters. e.g. "{DESede}" is encoded
-    # as "%7BDESede%7D". If this is escaped again the percentage
-    # symbols will be escaped.
-    begin
-      URI.parse(uri)
-    rescue URI::InvalidURIError
-      URI.parse(URI::DEFAULT_PARSER.escape(uri))
-    end
-  end
-
-  ##
-  # Parses the #uri, returning the original uri if it's invalid
-
-  def parse(uri)
-    parse!(uri)
-  rescue URI::InvalidURIError
-    uri
-  end
-end
diff --git a/lib/rubygems/uri_parsing.rb b/lib/rubygems/uri_parsing.rb
deleted file mode 100644
index 941d7e0..0000000
--- a/lib/rubygems/uri_parsing.rb
+++ /dev/null
@@ -1,23 +0,0 @@
-# frozen_string_literal: true
-
-require "rubygems/uri_parser"
-
-module Gem::UriParsing
-
-  def parse_uri(source_uri)
-    return source_uri unless source_uri.is_a?(String)
-
-    uri_parser.parse(source_uri)
-  end
-
-  private :parse_uri
-
-  def uri_parser
-    require "uri"
-
-    Gem::UriParser.new
-  end
-
-  private :uri_parser
-
-end
diff --git a/lib/rubygems/user_interaction.rb b/lib/rubygems/user_interaction.rb
index 27a9957..0ab44fb 100644
--- a/lib/rubygems/user_interaction.rb
+++ b/lib/rubygems/user_interaction.rb
@@ -5,8 +5,8 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/deprecate'
-require 'rubygems/text'
+require_relative 'deprecate'
+require_relative 'text'
 
 ##
 # Module that defines the default UserInteraction.  Any class including this
@@ -543,7 +543,7 @@ class Gem::StreamUI
   # A progress reporter that behaves nicely with threaded downloading.
 
   class ThreadedDownloadReporter
-    MUTEX = Mutex.new
+    MUTEX = Thread::Mutex.new
 
     ##
     # The current file name being displayed
diff --git a/lib/rubygems/util.rb b/lib/rubygems/util.rb
index 2a55305..4363c5a 100644
--- a/lib/rubygems/util.rb
+++ b/lib/rubygems/util.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
-require 'rubygems/deprecate'
+require_relative 'deprecate'
 
 ##
 # This module contains various utility methods as module methods.
diff --git a/lib/rubygems/util/licenses.rb b/lib/rubygems/util/licenses.rb
index 98cbd89..3f4178c 100644
--- a/lib/rubygems/util/licenses.rb
+++ b/lib/rubygems/util/licenses.rb
@@ -1,10 +1,11 @@
 # frozen_string_literal: true
-require 'rubygems/text'
+require_relative '../text'
 
 class Gem::Licenses
   extend Gem::Text
 
   NONSTANDARD = 'Nonstandard'.freeze
+  LICENSE_REF = 'LicenseRef-.+'.freeze
 
   # Software Package Data Exchange (SPDX) standard open-source software
   # license identifiers
@@ -523,6 +524,7 @@ class Gem::Licenses
       \+?
       (?:\s WITH \s #{Regexp.union(EXCEPTION_IDENTIFIERS)})?
       | #{NONSTANDARD}
+      | #{LICENSE_REF}
     )
     \Z
   }ox.freeze
diff --git a/lib/rubygems/validator.rb b/lib/rubygems/validator.rb
index 30cdd93..728595e 100644
--- a/lib/rubygems/validator.rb
+++ b/lib/rubygems/validator.rb
@@ -5,8 +5,8 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/package'
-require 'rubygems/installer'
+require_relative 'package'
+require_relative 'installer'
 
 ##
 # Validator performs various gem file and gem database validation
diff --git a/lib/rubygems/version.rb b/lib/rubygems/version.rb
index 20bbff4..42e0f23 100644
--- a/lib/rubygems/version.rb
+++ b/lib/rubygems/version.rb
@@ -149,6 +149,8 @@
 # For the last example, single-digit versions are automatically extended with
 # a zero to give a sensible result.
 
+require_relative "deprecate"
+
 class Gem::Version
   autoload :Requirement, File.expand_path('requirement', __dir__)
 
diff --git a/lib/rubygems/version_option.rb b/lib/rubygems/version_option.rb
index be71ef4..1db382f 100644
--- a/lib/rubygems/version_option.rb
+++ b/lib/rubygems/version_option.rb
@@ -5,7 +5,7 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems'
+require_relative '../rubygems'
 
 ##
 # Mixin methods for --version and --platform Gem::Command options.
@@ -16,7 +16,7 @@ module Gem::VersionOption
   # Add the --platform option to the option parser.
 
   def add_platform_option(task = command, *wrap)
-    OptionParser.accept Gem::Platform do |value|
+    Gem::OptionParser.accept Gem::Platform do |value|
       if value == Gem::Platform::RUBY
         value
       else
@@ -51,7 +51,7 @@ module Gem::VersionOption
   # Add the --version option to the option parser.
 
   def add_version_option(task = command, *wrap)
-    OptionParser.accept Gem::Requirement do |value|
+    Gem::OptionParser.accept Gem::Requirement do |value|
       Gem::Requirement.new(*value.split(/\s*,\s*/))
     end
 
